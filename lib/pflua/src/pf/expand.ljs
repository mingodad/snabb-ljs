module(...,package.seeall);

var utils = require('pf.utils');

var verbose = os.getenv("PF_VERBOSE");

var expand_arith, expand_relop, expand_bool;

var set, concat, pp = utils.set, utils.concat, utils.pp;
var uint16, uint32 = utils.uint16, utils.uint32;
var ipv4_to_int, ipv6_as_4x32 = utils.ipv4_to_int, utils.ipv6_as_4x32;
var filter_args = utils.filter_args;

var llc_types = set(
   'i', 's', 'u', 'rr', 'rnr', 'rej', 'ui', 'ua',
   'disc', 'sabme', 'test', 'xis', 'frmr'
);

var pf_reasons = set(
   'match', 'bad-offset', 'fragment', 'short', 'normalize', 'memory'
);

var pf_actions = set(
   'pass', 'block', 'nat', 'rdr', 'binat', 'scrub'
);

var wlan_frame_types = set('mgt', 'ctl', 'data');
var wlan_frame_mgt_subtypes = set(
   'assoc-req', 'assoc-resp', 'reassoc-req', 'reassoc-resp',
   'probe-req', 'probe-resp', 'beacon', 'atim', 'disassoc', 'auth', 'deauth'
);
var wlan_frame_ctl_subtypes = set(
   'ps-poll', 'rts', 'cts', 'ack', 'cf-end', 'cf-end-ack'
);
var wlan_frame_data_subtypes = set(
   'data', 'data-cf-ack', 'data-cf-poll', 'data-cf-ack-poll', 'null',
   'cf-ack', 'cf-poll', 'cf-ack-poll', 'qos-data', 'qos-data-cf-ack',
   'qos-data-cf-poll', 'qos-data-cf-ack-poll', 'qos', 'qos-cf-poll',
   'quos-cf-ack-poll'
);

var wlan_directions = set('nods', 'tods', 'fromds', 'dstods');

var function unimplemented(expr, dlt) {
   error("not implemented: "..expr[1]);
}

// Ethernet protocols
var PROTO_AARP    = 33011; // 0x80f3
var PROTO_ARP     = 2054;  // 0x806
var PROTO_ATALK   = 32923; // 0x809b
var PROTO_DECNET  = 24579; // 0x6003
var PROTO_IPV4    = 2048;  // 0x800
var PROTO_IPV6    = 34525; // 0x86dd
var PROTO_IPX     = 33079; // 0X8137
var PROTO_ISO     = 65278; // 0xfefe
var PROTO_LAT     = 24580; // 0x6004
var PROTO_MOPDL   = 24577; // 0x6001
var PROTO_MOPRC   = 24578; // 0x6002
var PROTO_NETBEUI = 61680; // 0xf0f0
var PROTO_RARP    = 32821; // 0x8035
var PROTO_SCA     = 24583; // 0x6007
var PROTO_STP     = 66;    // 0x42

var ether_min_payloads = {
   [PROTO_IPV4] = 20,
   [PROTO_ARP]  = 28,
   [PROTO_RARP] = 28,
   [PROTO_IPV6] = 40
};

// IP protocols
var PROTO_AH    = 51;  // 0x33
var PROTO_ESP   = 50;  // 0x32
var PROTO_ICMP  = 1;   // 0x1
var PROTO_ICMP6 = 58;  // 0x3a
var PROTO_IGMP  = 2;   // 0x2
var PROTO_IGRP  = 9;   // 0x9
var PROTO_PIM   = 103; // 0x67
var PROTO_SCTP  = 132; // 0x84
var PROTO_TCP   = 6;   // 0x6
var PROTO_UDP   = 17;  // 0x11
var PROTO_VRRP  = 112; // 0x70

var ip_min_payloads = {
   [PROTO_ICMP] = 8,
   [PROTO_UDP]  = 8,
   [PROTO_TCP]  = 20,
   [PROTO_IGMP] = 8,
   [PROTO_IGRP] = 8,
   [PROTO_PIM]  = 4,
   [PROTO_SCTP] = 12,
   [PROTO_VRRP] = 8
};

// ISO protocols

var PROTO_CLNP = 129;        // 0x81
var PROTO_ESIS = 130;        // 0x82
var PROTO_ISIS = 131;        // 0x83

var ETHER_TYPE       = 12;
var ETHER_PAYLOAD    = 14;
var IP_FLAGS         = 6;
var IP_PROTOCOL      = 9;

// Minimum payload checks insert a byte access to the last byte of the
// minimum payload size.  Since the comparison should fold (because it
// will always be >= 0), we will be left with just an eager assertion on
// the minimum packet size, which should help elide future packet size
// assertions.
var function has_proto_min_payload(min_payloads, proto, accessor) {
   var min_payload = assert(min_payloads[proto]);
   return { '<=', 0, { accessor, min_payload - 1, 1 } };
}

// When proto is greater than 1500 (0x5DC) , the frame is treated as an
// Ethernet frame and the Type/Length is interpreted as Type, storing the
// EtherType value.
// Otherwise, the frame is interpreted as an 802.3 frame and the
// Type/Length field is interpreted as Length. The Length cannot be greater
// than 1500. The first byte after the Type/Length field stores the Service
// Access Point of the 802.3 frame. It works as an EtherType at LLC level.
//
// See: https://tools.ietf.org/html/draft-ietf-isis-ext-eth-01

var ETHER_MAX_LEN = 1500;

var function has_ether_protocol(proto) {
   if( proto > ETHER_MAX_LEN ) { 
      return { '=', { '[ether]', ETHER_TYPE, 2 }, proto };
   }
   return { 'and',
            { '<=', {'[ether]', ETHER_TYPE, 2}, ETHER_MAX_LEN },
            { '=', { '[ether]', ETHER_PAYLOAD, 1}, proto } };
}
var function has_ether_protocol_min_payload(proto) {
   return has_proto_min_payload(ether_min_payloads, proto, '[ether*]');
}
var function has_ipv4_protocol(proto) {
   return { '=', { '[ip]', IP_PROTOCOL, 1 }, proto };
}
var function has_ipv4_protocol_min_payload(proto) {
   // Since the [ip*] accessor asserts that is_first_ipv4_fragment(),
   // and we don't want that, we use [ip] and assume the minimum IP
   // header size.
   var min_payload = assert(ip_min_payloads[proto]);
   min_payload = min_payload + assert(ether_min_payloads[PROTO_IPV4]);
   return { '<=', 0, { '[ip]', min_payload - 1, 1 } };
}

var function is_first_ipv4_fragment() {
   return { '=', { '&', { '[ip]', IP_FLAGS, 2 }, 0x1fff }, 0 };
}
var function has_ipv6_protocol(proto) {
   var IPV6_NEXT_HEADER_1 = 6;
   var IPV6_NEXT_HEADER_2 = 40;
   var IPV6_FRAGMENTATION_EXTENSION_HEADER = 44;
   return { 'and', { 'ip6' },
            { 'or',
              { '=', { '[ip6]', IPV6_NEXT_HEADER_1, 1 }, proto },
              { 'and',
                { '=', { '[ip6]', IPV6_NEXT_HEADER_1, 1 },
                  IPV6_FRAGMENTATION_EXTENSION_HEADER },
                { '=', { '[ip6]', IPV6_NEXT_HEADER_2, 1 }, proto } } } };
}
var function has_ipv6_protocol_min_payload(proto) {
   // Assume the minimum ipv6 header size.
   var min_payload = assert(ip_min_payloads[proto]);
   min_payload = min_payload + assert(ether_min_payloads[PROTO_IPV6]);
   return { '<=', 0, { '[ip6]', min_payload - 1, 1 } };
}
var function has_ip_protocol(proto) {
   return { 'if', { 'ip' }, has_ipv4_protocol(proto), has_ipv6_protocol(proto) };
}

// Port operations
//

var SRC_PORT = 0;
var DST_PORT = 2;

var function has_ipv4_src_port(port) {
   return { '=', { '[ip*]', SRC_PORT, 2 }, port };
}
var function has_ipv4_dst_port(port) {
   return { '=', { '[ip*]', DST_PORT, 2 }, port };
}
var function has_ipv4_port(port) {
   return { 'or', has_ipv4_src_port(port), has_ipv4_dst_port(port) };
}
var function has_ipv6_src_port(port) {
   return { '=', { '[ip6*]', SRC_PORT, 2 }, port };
}
var function has_ipv6_dst_port(port) {
   return { '=', { '[ip6*]', DST_PORT, 2 }, port };
}
var function has_ipv6_port(port) {
   return { 'or', has_ipv6_src_port(port), has_ipv6_dst_port(port) };
}
var function expand_dir_port(expr, has_ipv4_port, has_ipv6_port) {
   var port = expr[2];
   return { 'if', { 'ip' },
            { 'and',
              { 'or', has_ipv4_protocol(PROTO_TCP),
                { 'or', has_ipv4_protocol(PROTO_UDP),
                  has_ipv4_protocol(PROTO_SCTP) } },
              has_ipv4_port(port) },
            { 'and',
              { 'or', has_ipv6_protocol(PROTO_TCP),
                { 'or', has_ipv6_protocol(PROTO_UDP),
                  has_ipv6_protocol(PROTO_SCTP) } },
              has_ipv6_port(port) } };
}
var function expand_port(expr) {
   return expand_dir_port(expr, has_ipv4_port, has_ipv6_port);
}
var function expand_src_port(expr) {
   return expand_dir_port(expr, has_ipv4_src_port, has_ipv6_src_port);
}
var function expand_dst_port(expr) {
   return expand_dir_port(expr, has_ipv4_dst_port, has_ipv6_dst_port);
}

var function expand_proto_port(expr, proto) {
   var port = expr[2];
   return { 'if', { 'ip' },
            { 'and',
              has_ipv4_protocol(proto),
              has_ipv4_port(port) },
            { 'and',
              has_ipv6_protocol(proto),
              has_ipv6_port(port) } };
}
var function expand_tcp_port(expr) {
   return expand_proto_port(expr, PROTO_TCP);
}
var function expand_udp_port(expr) {
   return expand_proto_port(expr, PROTO_UDP);
}

var function expand_proto_src_port(expr, proto) {
   var port = expr[2];
   return { 'if', { 'ip' },
            { 'and',
              has_ipv4_protocol(proto),
              has_ipv4_src_port(port) },
            { 'and',
              has_ipv6_protocol(proto),
              has_ipv6_src_port(port) } };
}
var function expand_tcp_src_port(expr) {
   return expand_proto_src_port(expr, PROTO_TCP);
}
var function expand_udp_src_port(expr) {
   return expand_proto_src_port(expr, PROTO_UDP);
}

var function expand_proto_dst_port(expr, proto) {
   var port = expr[2];
   return { 'if', { 'ip' },
            { 'and',
              has_ipv4_protocol(proto),
              has_ipv4_dst_port(port) },
            { 'and',
              has_ipv6_protocol(proto),
              has_ipv6_dst_port(port) } };
}
var function expand_tcp_dst_port(expr) {
   return expand_proto_dst_port(expr, PROTO_TCP);
}
var function expand_udp_dst_port(expr) {
   return expand_proto_dst_port(expr, PROTO_UDP);
}

// Portrange operations
//
var function has_ipv4_src_portrange(lo, hi) {
   return { 'and',
            { '<=', lo, { '[ip*]', SRC_PORT, 2 } },
            { '<=', { '[ip*]', SRC_PORT, 2 }, hi } };
}
var function has_ipv4_dst_portrange(lo, hi) {
   return { 'and',
            { '<=', lo, { '[ip*]', DST_PORT, 2 } },
            { '<=', { '[ip*]', DST_PORT, 2 }, hi } };
}
var function has_ipv4_portrange(lo, hi) {
   return { 'or', has_ipv4_src_portrange(lo, hi), has_ipv4_dst_portrange(lo, hi) };
}
var function has_ipv6_src_portrange(lo, hi) {
   return { 'and',
            { '<=', lo, { '[ip6*]', SRC_PORT, 2 } },
            { '<=', { '[ip6*]', SRC_PORT, 2 }, hi } };
}
var function has_ipv6_dst_portrange(lo, hi) {
   return { 'and',
            { '<=', lo, { '[ip6*]', DST_PORT, 2 } },
            { '<=', { '[ip6*]', DST_PORT, 2 }, hi } };
}
var function has_ipv6_portrange(lo, hi) {
   return { 'or', has_ipv6_src_portrange(lo, hi), has_ipv6_dst_portrange(lo, hi) };
}
var function expand_dir_portrange(expr, has_ipv4_portrange, has_ipv6_portrange) {
   var lo, hi = expr[2][1], expr[2][2];
   return { 'if', { 'ip' },
            { 'and',
              { 'or', has_ipv4_protocol(PROTO_TCP),
                { 'or', has_ipv4_protocol(PROTO_UDP),
                  has_ipv4_protocol(PROTO_SCTP) } },
              has_ipv4_portrange(lo, hi) },
            { 'and',
              { 'or', has_ipv6_protocol(PROTO_TCP),
                { 'or', has_ipv6_protocol(PROTO_UDP),
                  has_ipv6_protocol(PROTO_SCTP) } },
              has_ipv6_portrange(lo, hi) } };
}
var function expand_portrange(expr) {
   return expand_dir_portrange(expr, has_ipv4_portrange, has_ipv6_portrange);
}
var function expand_src_portrange(expr) {
   return expand_dir_portrange(expr, has_ipv4_src_portrange, has_ipv6_src_portrange);
}
var function expand_dst_portrange(expr) {
   return expand_dir_portrange(expr, has_ipv4_dst_portrange, has_ipv6_dst_portrange);
}

var function expand_proto_portrange(expr, proto) {
   var lo, hi = expr[2][1], expr[2][2];
   return { 'if', { 'ip' },
            { 'and',
              has_ipv4_protocol(proto),
              has_ipv4_portrange(lo, hi) },
            { 'and',
              has_ipv6_protocol(proto),
              has_ipv6_portrange(lo, hi) } };
}
var function expand_tcp_portrange(expr) {
   return expand_proto_portrange(expr, PROTO_TCP);
}
var function expand_udp_portrange(expr) {
   return expand_proto_portrange(expr, PROTO_UDP);
}

var function expand_proto_src_portrange(expr, proto) {
   var lo, hi = expr[2][1], expr[2][2];
   return { 'if', { 'ip' },
            { 'and',
              has_ipv4_protocol(proto),
              has_ipv4_src_portrange(lo, hi) },
            { 'and',
              has_ipv6_protocol(proto),
              has_ipv6_src_portrange(lo, hi) } };
}
var function expand_tcp_src_portrange(expr) {
   return expand_proto_src_portrange(expr, PROTO_TCP);
}
var function expand_udp_src_portrange(expr) {
   return expand_proto_src_portrange(expr, PROTO_UDP);
}

var function expand_proto_dst_portrange(expr, proto) {
   var lo, hi = expr[2][1], expr[2][2];
   return { 'if', { 'ip' },
            { 'and',
              has_ipv4_protocol(proto),
              has_ipv4_dst_portrange(lo, hi) },
            { 'and', 
              has_ipv6_protocol(proto),
              has_ipv6_dst_portrange(lo, hi) } };
}
var function expand_tcp_dst_portrange(expr) {
   return expand_proto_dst_portrange(expr, PROTO_TCP);
}
var function expand_udp_dst_portrange(expr) {
   return expand_proto_dst_portrange(expr, PROTO_UDP);
}

// IP protocol

var proto_info = {
   ip   = { id = PROTO_IPV4,  access = "[ip]",    src = 12, dst = 16 },
   arp  = { id = PROTO_ARP,   access = "[arp]",   src = 14, dst = 24 },
   rarp = { id = PROTO_RARP,  access = "[rarp]",  src = 14, dst = 24 },
   ip6  = { id = PROTO_IPV6,  access = "[ip6]",   src =  8, dst = 24 },
};

var function has_proto_dir_host(proto, dir, addr, mask) {
   var host = ipv4_to_int(addr);
   var val = { proto_info[proto].access, proto_info[proto][dir], 4 };
   if( mask ) {
      mask = tonumber(mask) && 2**32 - 2**(32 - mask) || ipv4_to_int(mask);
      val = { '&', val, tonumber(mask) };
   }
   return { 'and', has_ether_protocol(proto_info[proto].id), { '=', val, host } };
}

var function expand_ip_src_host(expr) {
  return has_proto_dir_host("ip", "src", expr[2], expr[3]);
}
var function expand_ip_dst_host(expr) {
   return has_proto_dir_host("ip", "dst", expr[2], expr[3]);
}
var function expand_ip_host(expr) {
   return { 'or', expand_ip_src_host(expr), expand_ip_dst_host(expr) };
}

var function expand_ip_broadcast(expr) {
   error("netmask not known, so 'ip broadcast' not supported");
}
var function expand_ip6_broadcast(expr) {
   error("only link-layer/IP broadcast filters supported");
}
var function expand_ip_multicast(expr) {
   var IPV4_MULTICAST = 224; // 0xe0
   var IPV4_DEST_ADDRESS = 16;
   return { '=', { '[ip]', IPV4_DEST_ADDRESS, 1 }, IPV4_MULTICAST };
}
var function expand_ip6_multicast(expr) {
   var IPV6_MULTICAST = 255; // 0xff
   var IPV6_DEST_ADDRESS_OFFSET = 24; // 14 + 24 = 38 (last two bytes of dest address)
   return { '=', { '[ip6]', IPV6_DEST_ADDRESS_OFFSET, 1 }, IPV6_MULTICAST };
}
var function expand_ip4_protochain(expr) {
   // FIXME: Not implemented yet. BPF code of ip protochain is rather complex.
   return unimplemented(expr);
}
var function expand_ip6_protochain(expr) {
   // FIXME: Not implemented yet. BPF code of ip6 protochain is rather complex.
   return unimplemented(expr);
}
var function expand_ip_protochain(expr) {
   return { 'if', 'ip', expand_ip4_protochain(expr), expand_ip6_protochain(expr) };
}

var ip_protos = {
   icmp  = PROTO_ICMP,
   icmp6 = PROTO_ICMP6,
   igmp  = PROTO_IGMP,
   igrp  = PROTO_IGRP,
   pim   = PROTO_PIM,
   ah    = PROTO_AH,
   esp   = PROTO_ESP,
   vrrp  = PROTO_VRRP,
   udp   = PROTO_UDP,
   tcp   = PROTO_TCP,
   sctp  = PROTO_SCTP,
};

var function expand_ip4_proto(expr) {
   var proto = expr[2];
   if( type(proto) == 'string' ) { proto = ip_protos[proto]; }
   return has_ipv4_protocol(assert(proto, "Invalid IP protocol"));
}

var function expand_ip6_proto(expr) {
   var proto = expr[2];
   if( type(proto) == 'string' ) { proto = ip_protos[proto]; }
   return has_ipv6_protocol(assert(proto, "Invalid IP protocol"));
}

var function expand_ip_proto(expr) {
   return { 'or', expand_ip4_proto(expr), expand_ip6_proto(expr) };
}

// ISO

var iso_protos = {
   clnp = PROTO_CLNP,
   esis = PROTO_ESIS,
   isis = PROTO_ISIS,
};

var function has_iso_protocol(proto) {
  return { 'and',
           { '<=', { '[ether]', ETHER_TYPE, 2 }, ETHER_MAX_LEN },
           { 'and',
             { '=', { '[ether]', ETHER_PAYLOAD, 2 }, PROTO_ISO },
             { '=', { '[ether]', ETHER_PAYLOAD + 3, 1 }, proto } } };
}

var function expand_iso_proto(expr) {
   var proto = expr[2];
   if( type(proto) == 'string' ) { proto = iso_protos[proto]; }
   return has_iso_protocol(assert(proto, "Invalid ISO protocol"));
}

// ARP protocol

var function expand_arp_src_host(expr) {
   return has_proto_dir_host("arp", "src", expr[2], expr[3]);
}
var function expand_arp_dst_host(expr) {
   return has_proto_dir_host("arp", "dst", expr[2], expr[3]);
}
var function expand_arp_host(expr) {
   return { 'or', expand_arp_src_host(expr), expand_arp_dst_host(expr) };
}

// RARP protocol

var function expand_rarp_src_host(expr) {
   return has_proto_dir_host("rarp", "src", expr[2], expr[3]);
}
var function expand_rarp_dst_host(expr) {
   return has_proto_dir_host("rarp", "dst", expr[2], expr[3]);
}
var function expand_rarp_host(expr) {
   return { 'or', expand_rarp_src_host(expr), expand_rarp_dst_host(expr) };
}

// IPv6

var function ipv6_dir_host(proto, dir, addr, mask_len) {
   mask_len = mask_len || 128;
   var offset = proto_info.ip6[dir];
   var ipv6 = ipv6_as_4x32(addr);

   var function match_ipv6_fragment(i) {
      var fragment = ipv6[i];

      // Calculate mask for fragment
      var mask = mask_len >= 32 && 0 || mask_len;
      mask_len = mask_len >= 32 && mask_len - 32 || 0;

      // Retrieve address current offset
      var val = { proto_info.ip6.access, offset, 4 };
      offset +=   4;

      if( mask != 0 ) { val = { '&', val, 2**32 - 2**(32 - mask) }; }
      return { '=', val, fragment };
   }

   // Lowering of an IPv6 address does not require to go iterate through all
   // IPv6 fragments (4x32). Once mask_len becomes 0 is possible to exit.
   var function match_ipv6(i) {
      i = i || 1;
      var expr = match_ipv6_fragment(i);
      if( mask_len == 0 || i > 4 ) { return expr; }
      return { 'and', expr, match_ipv6(i + 1) };
   }

   return { 'and', has_ether_protocol(PROTO_IPV6), match_ipv6() };
}

var function expand_src_ipv6_host(expr) {
   return ipv6_dir_host('ip6', 'src', expr[2], expr[3]);
}
var function expand_dst_ipv6_host(expr) {
   return ipv6_dir_host('ip6', 'dst', expr[2], expr[3]);
}
var function expand_ipv6_host(expr) {
   return { 'or',
            ipv6_dir_host('ip6', 'src', expr[2], expr[3]),
            ipv6_dir_host('ip6', 'dst', expr[2], expr[3]) };
}

// Host


/*
* Format IPv4 expr:
  { 'net', { 'ipv4', 127, 0, 0, 1 } }
  { 'ipv4/len', { 'ipv4', 127, 0, 0, 1 }, 24 }
* Format IPv6 expr:
  { 'net', { 'ipv6', 0, 0, 0, 0, 0, 0, 0, 1 } }
  { 'ipv4/len', { 'ipv6', 0, 0, 0, 0, 0, 0, 0, 1 }, 24 }
*///
var function is_ipv6_addr(expr) {
   return expr[2][1] == 'ipv6';
}

var function expand_src_host(expr) {
   if( is_ipv6_addr(expr) ) { return expand_src_ipv6_host(expr); }
   return { 'if', { 'ip' }, expand_ip_src_host(expr),
            { 'if', { 'arp' }, expand_arp_src_host(expr),
              expand_rarp_src_host(expr) } };
}
var function expand_dst_host(expr) {
   if( is_ipv6_addr(expr) ) { return expand_dst_ipv6_host(expr); }
   return { 'if', { 'ip' }, expand_ip_dst_host(expr),
            { 'if', { 'arp' }, expand_arp_dst_host(expr),
              expand_rarp_dst_host(expr) } };
}
// Format IPv4: { 'ipv4/len', { 'ipv4', 127, 0, 0, 1 }, 8 }
// Format IPv4: { 'ipv4/mask', { 'ipv4', 127, 0, 0, 1 }, { 'ipv4', 255, 0, 0, 0 } }
// Format IPv6: { 'ipv6/len', { 'ipv6', 0, 0, 0, 0, 0, 0, 0, 1 }, 128 }
var function expand_host(expr) {
   if( is_ipv6_addr(expr) ) { return expand_ipv6_host(expr); }
   return { 'if', { 'ip' }, expand_ip_host(expr),
            { 'if', { 'arp' }, expand_arp_host(expr),
              expand_rarp_host(expr) } };
}

// Ether

var MAC_DST = 0;
var MAC_SRC = 6; 

var function ehost_to_int(addr) {
   assert(addr[1] == 'ehost', "Not a valid ehost address");
   return uint16(addr[2], addr[3]), uint32(addr[4], addr[5], addr[6], addr[7]);
}
var function expand_ether_src_host(expr) {
   var hi, lo = ehost_to_int(expr[2]);
   return { 'and',
            { '=', { '[ether]', MAC_SRC, 2 }, hi },
            { '=', { '[ether]', MAC_SRC + 2, 4 }, lo } };
}
var function expand_ether_dst_host(expr) {
   var hi, lo = ehost_to_int(expr[2]);
   return { 'and',
            { '=', { '[ether]', MAC_DST, 2 }, hi },
            { '=', { '[ether]', MAC_DST + 2, 4 }, lo } };
}
var function expand_ether_host(expr) {
   return { 'or', expand_ether_src_host(expr), expand_ether_dst_host(expr) };
}
var function expand_ether_broadcast(expr) {
   var broadcast = { 'ehost', 255, 255, 255, 255, 255, 255 };
   var hi, lo = ehost_to_int(broadcast);
   return { 'and',
            { '=', { '[ether]', MAC_DST, 2 }, hi },
            { '=', { '[ether]', MAC_DST + 2, 4 }, lo } };
}
var function expand_ether_multicast(expr) {
   return { '!=', { '&', { '[ether]', 0, 1 }, 1 }, 0 };
}

// Ether protos

var function expand_ip(expr) {
   return has_ether_protocol(PROTO_IPV4);
}
var function expand_ip6(expr) {
   return has_ether_protocol(PROTO_IPV6);
}
var function expand_arp(expr) {
   return has_ether_protocol(PROTO_ARP);
}
var function expand_rarp(expr) {
   return has_ether_protocol(PROTO_RARP);
}

var function expand_atalk(expr) {
  var ATALK_ID_1 = 491675;     // 0x7809B
  var ATALK_ID_2 = 2863268616; // 0xaaaa0308
  return { 'or',
           has_ether_protocol(PROTO_ATALK),
           { 'if', { '>', { '[ether]', ETHER_TYPE, 2}, ETHER_MAX_LEN },
             { 'false' },
             { 'and',
               { '=', { '[ether]', ETHER_PAYLOAD + 4, 2 }, ATALK_ID_1 },
               { '=', { '[ether]', ETHER_PAYLOAD, 4 }, ATALK_ID_2 } } } };
}
var function expand_aarp(expr) {
  var AARP_ID = 2863268608; // 0xaaaa0300
  return { 'or',
           has_ether_protocol(PROTO_AARP),
           { 'if', { '>', { '[ether]', ETHER_TYPE, 2}, ETHER_MAX_LEN },
             { 'false' },
             { 'and',
               { '=', { '[ether]', ETHER_PAYLOAD + 4, 2 }, PROTO_AARP },
               { '=', { '[ether]', ETHER_PAYLOAD, 4 }, AARP_ID } } } };
}
var function expand_decnet(expr) {
   return has_ether_protocol(PROTO_DECNET);
}
var function expand_sca(expr) {
   return has_ether_protocol(PROTO_SCA);
}
var function expand_lat(expr) {
   return has_ether_protocol(PROTO_LAT);
}
var function expand_mopdl(expr) {
   return has_ether_protocol(PROTO_MOPDL);
}
var function expand_moprc(expr) {
   return has_ether_protocol(PROTO_MOPRC);
}
var function expand_iso(expr) {
   return { 'and',
            { '<=', { '[ether]', ETHER_TYPE, 2 }, ETHER_MAX_LEN },
            { '=', { '[ether]', ETHER_PAYLOAD, 2 }, PROTO_ISO } };
}
var function expand_stp(expr) {
   return { 'and',
            { '<=', { '[ether]', ETHER_TYPE, 2 }, ETHER_MAX_LEN },
            { '=', { '[ether]', ETHER_PAYLOAD, 1 }, PROTO_STP } };
}

var function expand_ipx(expr) {
  var IPX_SAP =      224;        // 0xe0
  var IPX_CHECKSUM = 65535;      // 0xffff
  var AARP_ID =      2863268608; // 0xaaaa0300
  return { 'or',
           has_ether_protocol(PROTO_IPX),
           { 'if', { '>', { '[ether]', ETHER_TYPE, 2}, ETHER_MAX_LEN },
             { 'false' },
             { 'or',
               { 'and',
                 { '=', { '[ether]', ETHER_PAYLOAD + 4, 2 }, PROTO_IPX },
                 { '=', { '[ether]', ETHER_PAYLOAD, 4 }, AARP_ID } },
               { 'or',
                 { '=', { '[ether]', ETHER_PAYLOAD, 1 }, IPX_SAP },
                 { '=', { '[ether]', ETHER_PAYLOAD, 2 }, IPX_CHECKSUM } } } } };
}
var function expand_netbeui(expr) {
   return { 'and',
            { '<=', { '[ether]', ETHER_TYPE, 2 }, ETHER_MAX_LEN },
            { '=', { '[ether]', ETHER_PAYLOAD, 2 }, PROTO_NETBEUI } };
}

var ether_protos = {
   ip      = expand_ip,
   ip6     = expand_ip6,
   arp     = expand_arp,
   rarp    = expand_rarp,
   atalk   = expand_atalk,
   aarp    = expand_aarp,
   decnet  = expand_decnet,
   sca     = expand_sca,
   lat     = expand_lat,
   mopdl   = expand_mopdl,
   moprc   = expand_moprc,
   iso     = expand_iso,
   stp     = expand_stp,
   ipx     = expand_ipx,
   netbeui = expand_netbeui,
};

var function expand_ether_proto(expr) {
   var proto = expr[2];
   if( type(proto) == 'string' ) { return ether_protos[proto](expr); }
   return has_ether_protocol(proto);
}

// Net

var function expand_src_net(expr) {
   var addr = expr;
   var proto = expr[2][1];
   if( proto->match("/len$") || proto->match("/mask$") ) { addr = expr[2]; }
   if( is_ipv6_addr(addr) ) { return expand_src_ipv6_host(addr); }
   return expand_src_host(addr);
}
var function expand_dst_net(expr) {
   var addr = expr;
   var proto = expr[2][1];
   if( proto->match("/len$") || proto->match("/mask$") ) { addr = expr[2]; }
   if( is_ipv6_addr(addr) ) { return expand_dst_ipv6_host(addr); }
   return expand_dst_host(addr);
}

// Format IPv4 expr: { 'net', { 'ipv4/len', { 'ipv4', 127, 0, 0, 0 }, 8 } }
// Format IPV6 expr: { 'net', { 'ipv6/len', { 'ipv6', 0, 0, 0, 0, 0, 0, 0, 1 }, 128 } }
var function expand_net(expr) {
   var addr = expr;
   var proto = expr[2][1];
   if( proto->match("/len$") || proto->match("/mask$") ) { addr = expr[2]; }
   if( is_ipv6_addr(addr) ) { return expand_ipv6_host(addr); }
   return expand_host(addr);
}

// Packet length

var function expand_less(expr) {
   return { '<=', 'len', expr[2] };
}
var function expand_greater(expr) {
   return { '>=', 'len', expr[2] };
}

// DECNET

var function expand_decnet_src(expr) {
   var addr = expr[2];
   var addr_int = uint16(addr[2], addr[3]);
   return { 'if', { '=', { '&', { '[ether]', ETHER_PAYLOAD + 2, 1}, 7 }, 2 },
            { '=', { '[ether]', ETHER_PAYLOAD + 5, 2}, addr_int },
            { 'if', { '=', { '&', { '[ether]', ETHER_PAYLOAD + 2, 2}, 65287 }, 33026 },
              { '=', { '[ether]', ETHER_PAYLOAD + 6, 2}, addr_int },
              { 'if', { '=', { '&', { '[ether]', ETHER_PAYLOAD + 2, 1}, 7 }, 6 },
                { '=', { '[ether]', ETHER_PAYLOAD + 17, 2}, addr_int },
                { 'if', { '=', { '&', { '[ether]', ETHER_PAYLOAD + 2, 2}, 65287 }, 33030 },
                  { '=', { '[ether]', ETHER_PAYLOAD + 18, 2}, addr_int },
                  { 'false' } } } } };
}
var function expand_decnet_dst(expr) {
   var addr = expr[2];
   var addr_int = uint16(addr[2], addr[3]);
   return { 'if', { '=', { '&', { '[ether]', ETHER_PAYLOAD + 2, 1}, 7 }, 2 },
            { '=', { '[ether]', ETHER_PAYLOAD + 3, 2}, addr_int },
            { 'if', { '=', { '&', { '[ether]', ETHER_PAYLOAD + 2, 2}, 65287 }, 33026 },
              { '=', { '[ether]', ETHER_PAYLOAD + 4, 2}, addr_int },
              { 'if', { '=', { '&', { '[ether]', ETHER_PAYLOAD + 2, 1}, 7 }, 6 },
                { '=', { '[ether]', ETHER_PAYLOAD + 9, 2}, addr_int },
                { 'if', { '=', { '&', { '[ether]', ETHER_PAYLOAD + 2, 2}, 65287 }, 33030 },
                  { '=', { '[ether]', ETHER_PAYLOAD + 10, 2}, addr_int },
                  { 'false' } } } } };
}
var function expand_decnet_host(expr) {
   return { 'or', expand_decnet_src(expr), expand_decnet_dst(expr) };
}

// IS-IS

var L1_IIH   = 15;  // 0x0F
var L2_IIH   = 16;  // 0x10
var PTP_IIH  = 17;  // 0x11
var L1_LSP   = 18;  // 0x12
var L2_LSP   = 20;  // 0x14
var L1_CSNP  = 24;  // 0x18
var L2_CSNP  = 25;  // 0x19
var L1_PSNP  = 26;  // 0x1A
var L2_PSNP  = 27;  // 0x1B

var function expand_isis_protocol(...) {
   var function concat(lop, reg, values, i) {
      i = i || 1;
      if( i == #values ) { return { '=', reg, values[i] }; }
      return { lop, { '=', reg, values[i] }, concat(lop, reg, values, i+1) };
   }
   return { 'if', has_iso_protocol(PROTO_ISIS),
            concat('or', { '[ether]', ETHER_PAYLOAD + 7, 1 }, {...} ),
            { 'false' } };
}
var function expand_l1(expr) {
   return expand_isis_protocol(L1_IIH, L1_LSP, L1_CSNP, L1_PSNP, PTP_IIH);
}
var function expand_l2(expr) {
   return expand_isis_protocol(L2_IIH, L2_LSP, L2_CSNP, L2_PSNP, PTP_IIH);
}
var function expand_iih(expr) {
   return expand_isis_protocol(L1_IIH, L2_IIH, PTP_IIH);
}
var function expand_lsp(expr) {
   return expand_isis_protocol(L1_LSP, L2_LSP);
}
var function expand_snp(expr) {
   return expand_isis_protocol(L1_CSNP, L2_CSNP, L1_PSNP, L2_PSNP);
}
var function expand_csnp(expr) {
   return expand_isis_protocol(L1_CSNP, L2_CSNP);
}
var function expand_psnp(expr) {
   return expand_isis_protocol(L1_PSNP, L2_PSNP);
}

var primitive_expanders = {
   dst = expand_dst_host,
   dst_host = expand_dst_host,
   dst_net = expand_dst_net,
   dst_port = expand_dst_port,
   dst_portrange = expand_dst_portrange,
   src = expand_src_host,
   src_host = expand_src_host,
   src_net = expand_src_net,
   src_port = expand_src_port,
   src_portrange = expand_src_portrange,
   host = expand_host,
   ether_src = expand_ether_src_host,
   ether_src_host = expand_ether_src_host,
   ether_dst = expand_ether_dst_host,
   ether_dst_host = expand_ether_dst_host,
   ether_host = expand_ether_host,
   ether_broadcast = expand_ether_broadcast,
   fddi_src = expand_ether_src_host,
   fddi_src_host = expand_ether_src_host,
   fddi_dst = expand_ether_dst_host,
   fddi_dst_host = expand_ether_dst_host,
   fddi_host = expand_ether_host,
   fddi_broadcast = expand_ether_broadcast,
   tr_src = expand_ether_src_host,
   tr_src_host = expand_ether_src_host,
   tr_dst = expand_ether_dst_host,
   tr_dst_host = expand_ether_dst_host,
   tr_host = expand_ether_host,
   tr_broadcast = expand_ether_broadcast,
   wlan_src = expand_ether_src_host,
   wlan_src_host = expand_ether_src_host,
   wlan_dst = expand_ether_dst_host,
   wlan_dst_host = expand_ether_dst_host,
   wlan_host = expand_ether_host,
   wlan_broadcast = expand_ether_broadcast,
   broadcast = expand_ether_broadcast,
   ether_multicast = expand_ether_multicast,
   multicast = expand_ether_multicast,
   ether_proto = expand_ether_proto,
   gateway = unimplemented,
   net = expand_net,
   port = expand_port,
   portrange = expand_portrange,
   less = expand_less,
   greater = expand_greater,
   ip = expand_ip,
   ip_proto = expand_ip4_proto,
   ip_protochain = expand_ip4_protochain,
   ip_host = expand_ip_host,
   ip_src = expand_ip_src_host,
   ip_src_host = expand_ip_src_host,
   ip_dst = expand_ip_dst_host,
   ip_dst_host = expand_ip_dst_host,
   ip_broadcast = expand_ip_broadcast,
   ip_multicast = expand_ip_multicast,
   ip6 = expand_ip6,
   ip6_proto = expand_ip6_proto,
   ip6_protochain = expand_ip6_protochain,
   ip6_broadcast = expand_ip6_broadcast,
   ip6_multicast = expand_ip6_multicast,
   proto = expand_ip_proto,
   tcp = function(expr) { return has_ip_protocol(PROTO_TCP); },
   tcp_port = expand_tcp_port,
   tcp_src_port = expand_tcp_src_port,
   tcp_dst_port = expand_tcp_dst_port,
   tcp_portrange = expand_tcp_portrange,
   tcp_src_portrange = expand_tcp_src_portrange,
   tcp_dst_portrange = expand_tcp_dst_portrange,
   udp = function(expr) { return has_ip_protocol(PROTO_UDP); },
   udp_port = expand_udp_port,
   udp_src_port = expand_udp_src_port,
   udp_dst_port = expand_udp_dst_port,
   udp_portrange = expand_udp_portrange,
   udp_src_portrange = expand_udp_src_portrange,
   udp_dst_portrange = expand_udp_dst_portrange,
   icmp = function(expr) { return has_ip_protocol(PROTO_ICMP); },
   icmp6 = function(expr) { return has_ipv6_protocol(PROTO_ICMP6); },
   igmp = function(expr) { return has_ip_protocol(PROTO_IGMP); },
   igrp = function(expr) { return has_ip_protocol(PROTO_IGRP); },
   pim = function(expr) { return has_ip_protocol(PROTO_PIM); },
   ah = function(expr) { return has_ip_protocol(PROTO_AH); },
   esp = function(expr) { return has_ip_protocol(PROTO_ESP); },
   vrrp = function(expr) { return has_ip_protocol(PROTO_VRRP); },
   sctp = function(expr) { return has_ip_protocol(PROTO_SCTP); },
   protochain = expand_ip_protochain,
   arp = expand_arp,
   arp_host = expand_arp_host,
   arp_src = expand_arp_src_host,
   arp_src_host = expand_arp_src_host,
   arp_dst = expand_arp_dst_host,
   arp_dst_host = expand_arp_dst_host,
   rarp = expand_rarp,
   rarp_host = expand_rarp_host,
   rarp_src = expand_rarp_src_host,
   rarp_src_host = expand_rarp_src_host,
   rarp_dst = expand_rarp_dst_host,
   rarp_dst_host = expand_rarp_dst_host,
   atalk = expand_atalk,
   aarp = expand_aarp,
   decnet = expand_decnet,
   decnet_src = expand_decnet_src,
   decnet_src_host = expand_decnet_src,
   decnet_dst = expand_decnet_dst,
   decnet_dst_host = expand_decnet_dst,
   decnet_host = expand_decnet_host,
   iso = expand_iso,
   stp = expand_stp,
   ipx = expand_ipx,
   netbeui = expand_netbeui,
   sca = expand_sca,
   lat = expand_lat,
   moprc = expand_moprc,
   mopdl = expand_mopdl,
   llc = unimplemented,
   ifname = unimplemented,
   on = unimplemented,
   rnr = unimplemented,
   rulenum = unimplemented,
   reason = unimplemented,
   rset = unimplemented,
   ruleset = unimplemented,
   srnr = unimplemented,
   subrulenum = unimplemented,
   action = unimplemented,
   wlan_ra = unimplemented,
   wlan_ta = unimplemented,
   wlan_addr1 = unimplemented,
   wlan_addr2 = unimplemented,
   wlan_addr3 = unimplemented,
   wlan_addr4 = unimplemented,
   type = unimplemented,
   type_subtype = unimplemented,
   subtype = unimplemented,
   dir = unimplemented,
   vlan = unimplemented,
   mpls = unimplemented,
   pppoed = unimplemented,
   pppoes = unimplemented,
   iso_proto = expand_iso_proto,
   clnp = function(expr) { return has_iso_protocol(PROTO_CLNP); },
   esis = function(expr) { return has_iso_protocol(PROTO_ESIS); },
   isis = function(expr) { return has_iso_protocol(PROTO_ISIS); },
   l1 = expand_l1,
   l2 = expand_l2,
   iih = expand_iih,
   lsp = expand_lsp,
   snp = expand_snp,
   csnp = expand_csnp,
   psnp = expand_psnp,
   vpi = unimplemented,
   vci = unimplemented,
   lane = unimplemented,
   oamf4s = unimplemented,
   oamf4e = unimplemented,
   oamf4 = unimplemented,
   oam = unimplemented,
   metac = unimplemented,
   bcc = unimplemented,
   sc = unimplemented,
   ilmic = unimplemented,
   connectmsg = unimplemented,
   metaconnect = unimplemented
};

var relops = set('<', '<=', '=', '!=', '>=', '>');

var addressables = set(
   'arp', 'rarp', 'wlan', 'ether', 'fddi', 'tr', 'ppp',
   'slip', 'link', 'radio', 'ip', 'ip6', 'tcp', 'udp', 'icmp'
);

var binops = set(
   '+', '-', '*', '*64', '/', '&', '|', '^', '&&', '||', '<<', '>>'
);
var associative_binops = set(
   '+', '*', '*64', '&', '|', '^'
);
var bitops = set('&', '|', '^');
var unops = set('ntohs', 'ntohl', 'uint32');
var leaf_primitives = set(
   'true', 'false', 'fail'
);

var function expand_offset(level, dlt) {
   assert(dlt == "EN10MB", "Encapsulation other than EN10MB unimplemented");
   var function guard_expr(expr) {
      var test, guards = expand_relop(expr, dlt);
      return concat(guards, { { test, { 'false' } } });
   }
   var function guard_ether_protocol(proto) {
      return concat(guard_expr(has_ether_protocol(proto)),
                    guard_expr(has_ether_protocol_min_payload(proto)));
   }
   function guard_ipv4_protocol(proto) {
      return concat(guard_expr(has_ipv4_protocol(proto)),
                    guard_expr(has_ipv4_protocol_min_payload(proto)));
   }
   function guard_ipv6_protocol(proto) {
      return concat(guard_expr(has_ipv6_protocol(proto)),
                    guard_expr(has_ipv6_protocol_min_payload(proto)));
   }
   function guard_first_ipv4_fragment() {
      return guard_expr(is_first_ipv4_fragment());
   }
   function ipv4_payload_offset(proto) {
      var ip_offset, guards = expand_offset('ip', dlt);
      if( proto ) {
         guards = concat(guards, guard_ipv4_protocol(proto));
      }
      guards = concat(guards, guard_first_ipv4_fragment());
      var res = { '+',
                    { '<<', { '&', { '[]', ip_offset, 1 }, 0xf }, 2 },
                    ip_offset };
      return res, guards;
   }
   function ipv6_payload_offset(proto) {
      var ip_offset, guards = expand_offset('ip6', dlt);
      if( proto ) {
         guards = concat(guards, guard_ipv6_protocol(proto));
      }
      return { '+', ip_offset, 40 }, guards;
   }

   // Note that unlike their corresponding predicates which detect
   // either IPv4 or IPv6 traffic, [icmp], [udp], and [tcp] only work
   // for IPv4.
   if( level == 'ether' ) {
      return 0, {};
   } else if( level == 'ether*' ) {
      return ETHER_PAYLOAD, {};
   } else if( level == 'arp' ) {
      return ETHER_PAYLOAD, guard_ether_protocol(PROTO_ARP);
   } else if( level == 'rarp' ) {
      return ETHER_PAYLOAD, guard_ether_protocol(PROTO_RARP);
   } else if( level == 'ip' ) {
      return ETHER_PAYLOAD, guard_ether_protocol(PROTO_IPV4);
   } else if( level == 'ip6' ) {
      return ETHER_PAYLOAD, guard_ether_protocol(PROTO_IPV6);
   } else if( level == 'ip*' ) {
      return ipv4_payload_offset();
   } else if( level == 'ip6*' ) {
      return ipv6_payload_offset();
   } else if( level == 'icmp' ) {
      return ipv4_payload_offset(PROTO_ICMP);
   } else if( level == 'udp' ) {
      return ipv4_payload_offset(PROTO_UDP);
   } else if( level == 'tcp' ) {
      return ipv4_payload_offset(PROTO_TCP);
   } else if( level == 'igmp' ) {
      return ipv4_payload_offset(PROTO_IGMP);
   } else if( level == 'igrp' ) {
      return ipv4_payload_offset(PROTO_IGRP);
   } else if( level == 'pim' ) {
      return ipv4_payload_offset(PROTO_PIM);
   } else if( level == 'sctp' ) {
      return ipv4_payload_offset(PROTO_SCTP);
   } else if( level == 'vrrp' ) {
      return ipv4_payload_offset(PROTO_VRRP);
   }
   error('invalid level '..level);
}

// Returns two values: the expanded arithmetic expression and an ordered
// list of guards.  A guard is a two-element array whose first element
// is a test expression.  If all test expressions of the guards are
// true, then it is valid to evaluate the arithmetic expression.  The
// second element of the guard array is the expression to which the
// relop will evaluate if the guard expression fails: either { 'false' }
// or { 'fail' }.
function expand_arith(expr, dlt) {
   assert(expr);
   if( type(expr) == 'number' || filter_args[expr] ) {
      return expr, {};
   }

   var op = expr[1];
   if( binops[op] ) {
      // Use 64-bit multiplication by default.  The optimizer will
      // reduce this back to Lua's normal float multiplication if it
      // can.
      if( op == '*' ) { op = '*64'; }
      var lhs, lhs_guards = expand_arith(expr[2], dlt);
      var rhs, rhs_guards = expand_arith(expr[3], dlt);
      // Mod 2^32 to preserve uint32 range.
      var ret = { 'uint32', { op, lhs, rhs } };
      var guards = concat(lhs_guards, rhs_guards);
      // RHS of division can't be 0.
      if( op == '/' ) {
         var div_guard = { { '!=', rhs, 0 }, { 'fail' } };
         guards = concat(guards, { div_guard });
      }
      return ret, guards;
   }

   var is_addr = false;
   if( op == 'addr' ) {
      is_addr = true;
      expr = expr[2];
      op = expr[1];
   }
   assert(op != '[]', "expr has already been expanded?");
   var addressable = assert(op->match("^%[(.+)%]$"), "bad addressable");
   var offset, offset_guards = expand_offset(addressable, dlt);
   var lhs, lhs_guards = expand_arith(expr[2], dlt);
   var size = expr[3];
   var len_test = { '<=', { '+', { '+', offset, lhs }, size }, 'len' };
   // ip[100000] will abort the whole matcher.  &ip[100000] will just
   // cause the clause to fail to match.
   var len_guard = { len_test, is_addr && { 'false' } || { 'fail' } };
   var guards = concat(concat(offset_guards, lhs_guards), { len_guard });
   var addr =  { '+', offset, lhs };
   if( is_addr ) { return addr, guards; }
   var ret = { '[]', addr, size };
   if( size == 1 ) { return ret, guards; }
   if( size == 2 ) { return { 'ntohs', ret }, guards; }
   if( size == 4 ) { return { 'uint32', { 'ntohl', ret } }, guards; }
   error('unreachable');
}

function expand_relop(expr, dlt) {
   var lhs, lhs_guards = expand_arith(expr[2], dlt);
   var rhs, rhs_guards = expand_arith(expr[3], dlt);
   return { expr[1], lhs, rhs }, concat(lhs_guards, rhs_guards);
}

function expand_bool(expr, dlt) {
   assert(type(expr) == 'table', 'logical expression must be a table');
   if( expr[1] == 'not' || expr[1] == '!' ) {
      return { 'if', expand_bool(expr[2], dlt), { 'false' }, { 'true' } };
   } else if( expr[1] == 'and' || expr[1] == '&&' ) {
      return { 'if', expand_bool(expr[2], dlt),
               expand_bool(expr[3], dlt),
               { 'false' } };
   } else if( expr[1] == 'or' || expr[1] == '||' ) {
      return { 'if', expand_bool(expr[2], dlt),
               { 'true' },
               expand_bool(expr[3], dlt) };
   } else if( relops[expr[1]] ) {
      // An arithmetic relop.
      var res, guards = expand_relop(expr, dlt);
      // We remove guards in LIFO order, resulting in an expression
      // whose first guard expression is the first one that was added.
      while( #guards != 0 ) {
         var guard = table.remove(guards);
         assert(guard[2]);
         res = { 'if', guard[1], res, guard[2] };
      }
      return res;
   } else if( expr[1] == 'if' ) {
      return { 'if',
               expand_bool(expr[2], dlt),
               expand_bool(expr[3], dlt),
               expand_bool(expr[4], dlt) };
   } else if( leaf_primitives[expr[1]] ) {
      return expr;
   } else {
      // A logical primitive.
      var expander = primitive_expanders[expr[1]];
      assert(expander, "unimplemented primitive: "..expr[1]);
      var expanded = expander(expr, dlt);
      return expand_bool(expanded, dlt);
   }
}

function expand(expr, dlt) {
   dlt = dlt || 'RAW';
   expr = expand_bool(expr, dlt);
   if( verbose ) { pp(expr); }
   return expr;
}

function selftest () {
   print("selftest: pf.expand");
   var parse = require('pf.parse').parse;
   var equals, assert_equals = utils.equals, utils.assert_equals;
   assert_equals({ '=', 1, 2 },
      expand(parse("1 = 2"), 'EN10MB'));
   assert_equals({ '=', 1, "len" },
      expand(parse("1 = len"), 'EN10MB'));
   assert_equals({ 'if',
                   { '!=', 2, 0},
                   { '=', 1, { 'uint32', { '/', 2, 2} } },
                   { 'fail'} },
      expand(parse("1 = 2/2"), 'EN10MB'));
   assert_equals({ 'if',
                   { '<=', { '+', { '+', 0, 0 }, 1 }, 'len'},
                   { '=', { '[]', { '+', 0, 0 }, 1 }, 2 },
                   { 'fail' } },
      expand(parse("ether[0] = 2"), 'EN10MB'));
   assert_equals(expand(parse("src 1::ff11"), 'EN10MB'),
      expand(parse("src host 1::ff11"), 'EN10MB'));
   assert_equals(expand(parse("proto \\sctp"), 'EN10MB'),
      expand(parse("ip proto \\sctp or ip6 proto \\sctp"), 'EN10MB'));
   assert_equals(expand(parse("proto \\tcp"), 'EN10MB'),
      expand(parse("ip proto \\tcp or ip6 proto \\tcp"), 'EN10MB'));
   // Could check this, but it's very large
   expand(parse("tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)"),
          "EN10MB");
   print("OK");
}
