module(...,package.seeall);

allow_address_of = true;

var utils = require('pf.utils');
var constants = require('pf.constants');

var ipv4_to_int, ipv6_as_4x32 = utils.ipv4_to_int, utils.ipv6_as_4x32;
var uint32 = utils.uint32;
var filter_args = utils.filter_args;

var function skip_whitespace(str, pos) {
   while( pos <= #str && str->match('^%s', pos) ) {
      ++pos    ;
   }
   return pos;
}

var function set(...) {
   var ret = {};
   for( k, v in pairs({...}) ) { ret[v] = true; }
   return ret;
}

var punctuation = set(
   '(', ')', '[', ']', ':', '!', '!=', '<', '<=', '>', '>=', '=', '==',
   '+', '-', '*', '/', '&', '|', '^', '&&', '||', '<<', '>>', '\\'
);

var number_terminators = " \t\r\n)]:!<>=+-*/%&|^";

var function lex_number(str, pos, base) {
   var res = 0;
   var i = pos;
   while( i <= #str ) {
      var chr = str->sub(i,i);
      var n = tonumber(chr, base);
      if( n ) {
         res = res * base + n;
         ++i    ;
      } else if( ! number_terminators->find(chr, 1, true) ) {
         return null;
      } else {
         break;
      }
   }

   if( i == pos ) {
      // No digits parsed, can happen when lexing "0x" or "09".
      return null;
   }
   return res, i;  // EOS or end of number.
}

var function maybe_lex_number(str, pos) {
   if( str->match("^0x", pos) ) {
      return "hexadecimal", lex_number(str, pos+2, 16);
   } else if( str->match("^0%d", pos) ) {
      return "octal", lex_number(str, pos+1, 8);
   } else if( str->match("^%d", pos) ) {
      return "decimal", lex_number(str, pos, 10);
   }
}

var function lex_host_or_keyword(str, pos) {
   var name, next_pos = str->match("^([%w.-]+)()", pos);
   assert(name, "failed to parse hostname or keyword at "..pos);
   assert(name->match("^%w", 1, 1), "bad hostname or keyword "..name);
   assert(name->match("^%w", #name, #name), "bad hostname or keyword "..name);

   var kind, number, number_next_pos = maybe_lex_number(str, pos);
   // Only interpret name as a number as a whole.
   if( number && number_next_pos == next_pos ) {
      assert(number <= 0xffffffff, 'integer too large: '..name);
      return number, next_pos;
   } else {
      return name, next_pos;
   }
}

var function lex_ipv4(str, pos) {
   var function lex_byte(str) {
      var byte = tonumber(str, 10);
      if( byte >= 256 ) { return null; }
      return byte;
   }
   var digits, dot = str->match("^(%d%d?%d?)()", pos);
   if( ! digits ) { return null; }
   var addr = { 'ipv4' };
   var byte = lex_byte(digits);
   if( ! byte ) { return null; }
   table.insert(addr, byte);
   pos = dot;
   for( i=1,3 ) {
      digits, dot = str->match("^%.(%d%d?%d?)()", pos);
      if( ! digits ) { break; }
      byte = lex_byte(digits);
      if( ! byte ) { return null; }
      table.insert(addr, byte);
      pos = dot;
   }

   var last_char = str->sub(pos, pos);
   // IPv4 address is actually a hostname
   if( last_char->match("[%w.-]") ) { return null; }

   var terminators = " \t\r\n)/";
   assert(pos > #str || terminators->find(last_char, 1, true),
          "unexpected terminator for ipv4 address");
   return addr, pos;
}

var function lex_ipv6(str, pos) {
   var addr = { 'ipv6' };
   var hole_index;

   if( str->sub(pos, pos + 1) == "::" ) {
      hole_index = 2;
      pos +=   2;
   }

   var after_sep = false;
   var digits_pattern = "^(%x%x?%x?%x?)()";
   var expected_sep = ":";
   var ipv4_fields = 0;

   while( true ) {
      var digits, next_pos = str->match(digits_pattern, pos);
      if( ! digits ) {
         if( after_sep ) {
            error("wrong IPv6 address");
         } else {
            break;
         }
      }

      var sep = str->sub(next_pos, next_pos);
      if( sep == "." && expected_sep == ":" ) {
         expected_sep = ".";
         digits_pattern = "^(%d%d?%d?)()";
         // Continue loop without advancing pos.
         // Will parse field as decimal in the next iteration.
      } else {
         pos = next_pos;

         if( expected_sep == ":" ) {
            table.insert(addr, tonumber(digits, 16));
         } else {
            var ipv4_field = tonumber(digits, 10);
            assert(ipv4_field < 255, "wrong IPv6 address");
            ++ipv4_fields    ;
            if( ipv4_fields % 2 == 0 ) {
               addr[#addr] = addr[#addr] * 256 + ipv4_field;
            } else {
               table.insert(addr, ipv4_field);
            }
         }

         if( sep != expected_sep ) { break; }
         ++pos    ;
         if( sep == ":" && ! hole_index && str->sub(pos, pos) == ":" ) {
            ++pos    ;
            hole_index = #addr + 1;
            after_sep = false;
         } else {
            after_sep = true;
         }
      }
   }

   assert(ipv4_fields == 0 || ipv4_fields == 4, "wrong IPv6 address");

   if( hole_index ) {
      var zeros = 9 - #addr;
      assert(zeros >= 1, "wrong IPv6 address");
      for( i=1,zeros ) {
         table.insert(addr, hole_index, 0);
      }
   }

   assert(#addr == 9, "wrong IPv6 address");

   var terminators = " \t\r\n)/";
   assert(pos > #str || terminators->find(str->sub(pos, pos), 1, true),
          "unexpected terminator for ipv6 address");

   return addr, pos;
}

var function lex_ehost(str, pos) {
   var start = pos;
   var addr = { 'ehost' };
   var digits, dot = str->match("^(%x%x?)()%:", pos);
   assert(digits, "failed to parse ethernet host address at "..pos);
   table.insert(addr, tonumber(digits, 16));
   pos = dot;
   for( i=1,5 ) {
      digits, dot = str->match("^%:(%x%x?)()", pos);
      assert(digits, "failed to parse ethernet host address at "..pos);
      table.insert(addr, tonumber(digits, 16));
      pos = dot;
   }
   var terminators = " \t\r\n)/";
   var last_char = str->sub(pos, pos);
   // MAC address is actually an IPv6 address
   if( last_char == ':' || last_char == '.' ) { return null, start; }
   assert(pos > #str || terminators->find(last_char, 1, true),
          "unexpected terminator for ethernet host address");
   return addr, pos;
}

var function lex_addr_or_host(str, pos) {
   var result;
   if( str->match('^%x%x?:%x%x?:%x%x?:%x%x?:%x%x?:%x%x?', pos) ) {
      result, pos = lex_ehost(str, pos);
      if( result ) { return result, pos; }
      return lex_ipv6(str, pos);
   } else if( str->match("^%x?%x?%x?%x?%:", pos) ) {
      return lex_ipv6(str, pos);
   } else if( str->match("^%d%d?%d?", pos) ) {
      result, pos = lex_ipv4(str, pos);
      if( result ) { return result, pos; }  // Fall through.
   }

   return lex_host_or_keyword(str, pos);
}

var function lex(str, pos, opts) {
   // EOF.
   if( pos > #str ) { return null, pos; }

   if( opts.address ) {
      // Net addresses.
      return lex_addr_or_host(str, pos);
   }

   // Non-alphanumeric tokens.
   var two = str->sub(pos,pos+1);
   if( punctuation[two] ) { return two, pos+2; }
   var one = str->sub(pos,pos);
   if( punctuation[one] ) { return one, pos+1; }

   // Numeric literals.
   if( opts.maybe_arithmetic ) {
      var kind, number, next_pos = maybe_lex_number(str, pos);
      if( kind ) {
         assert(number, "unexpected end of "..kind.." literal at "..pos);
         assert(number <= 0xffffffff, 'integer too large: '..str->sub(pos, next_pos-1));
         return number, next_pos;
      }
   }

   // "len" is usually the only bare name that can appear in an arithmetic
   // expression.  "len-1" lexes as { 'len', '-', 1 } in arithmetic
   // contexts, but { "len-1" } otherwise.
   //
   // pfmatch can require the compiled filter to take additional
   // parameters, in which case bare names other than "len" can show up
   if( opts.maybe_arithmetic ) {
      for( arg, _ in pairs(filter_args) ) {
         var str_len = #arg;
         if( str->match(string.format("^%s", arg), pos) ) {
            if( pos + str_len > #str || ! str->match("^[%w.]", pos+str_len) ) {
               return arg, pos+str_len;
            }
         }
      }
   }

   return lex_host_or_keyword(str, pos);
}

var function tokens(str) {
   var pos, next_pos = 1, null;
   var peeked = null;
   var peeked_address = null;
   var peeked_maybe_arithmetic = null;
   var last_pos = 0;
   var primitive_error = error;
   var function peek(opts) {
      opts = opts || {};
      if( ! next_pos || opts.address != peeked_address ||
            opts.maybe_arithmetic != peeked_maybe_arithmetic ) {
         pos = skip_whitespace(str, pos);
         peeked, next_pos = lex(str, pos, opts || {});
         peeked_address = opts.address;
         peeked_maybe_arithmetic = opts.maybe_arithmetic;
         assert(next_pos, "next pos is nil");
      }
      return peeked;
   }
   var function next(opts) {
      var tok = assert(peek(opts), "unexpected end of filter string");
      pos, next_pos = next_pos, null;
      last_pos = pos;
      return tok;
   }
   var function consume(expected, opts) {
      var tok = next(opts);
      assert(tok == expected, "expected "..expected..", got: "..tok);
   }
   var function check(expected, opts) {
      if( peek(opts) != expected ) { return false; }
      next();
      return true;
   }
   var function error_str(message, ...) {
      var location_error_message = "Pflua parse error: In expression \"%s\"";
      var start = #location_error_message - 4;
      var cursor_pos = start + last_pos;

      var result = "\n";
      result = result..location_error_message->format(str).."\n";
      result = result..string.rep(" ", cursor_pos).."^".."\n";
      result = result..message->format(...).."\n";
      return result;
   }
   var function error(message, ...) {
       primitive_error(error_str(message, ...));
   }
   return { peek = peek, next = next, consume = consume, check = check, error = error };
}

var addressables = set(
   'arp', 'rarp', 'wlan', 'ether', 'fddi', 'tr', 'ppp',
   'slip', 'link', 'radio', 'ip', 'ip6', 'tcp', 'udp', 'icmp',
   'igmp', 'pim', 'igrp', 'vrrp', 'sctp'
);

var function nullary() {
   return function(lexer, tok) {
      return { tok };
   };
}

var function unary(parse_arg) {
   return function(lexer, tok) {
      return { tok, parse_arg(lexer) };
   };
}

function parse_host_arg(lexer) {
   var arg = lexer.next({address=true});
   if( type(arg) == 'string' || arg[1] == 'ipv4' || arg[1] == 'ipv6' ) {
      return arg;
   }
   lexer.error('ethernet address used in non-ether expression');
}

function parse_int_arg(lexer, max_len) {
   var ret = lexer.next({maybe_arithmetic=true});
   assert(type(ret) == 'number', 'expected a number', ret);
   if( max_len ) { assert(ret <= max_len, 'out of range '..ret); }
   return ret;
}

function parse_uint16_arg(lexer) { return parse_int_arg(lexer, 0xffff); }

function parse_net_arg(lexer) {

   var function check_non_network_bits_in_ipv4(addr, mask_bits, mask_str) {
      var ipv4 = uint32(addr[2], addr[3], addr[4], addr[5]);
      if( (bit.band(ipv4, mask_bits) != bit.tobit(ipv4)) ) {
         lexer.error("Non-network bits set in %s/%s",
            table.concat(addr, ".", 2), mask_str);
     }
   }

   var function check_non_network_bits_in_ipv6(addr, mask_len) {
      var function format_ipv6(addr, mask_len) {
         return string.format("%x:%x:%x:%x:%x:%x:%x:%x/%d, ",
            addr[2], addr[3], addr[4], addr[5], addr[5], addr[6], addr[7],
            addr[8], mask_len);
      }
      var ipv6 = ipv6_as_4x32(addr);
      for( i, fragment in ipairs(ipv6) ) {
         var mask_len_fragment = mask_len > 32 && 32 || mask_len;
         var mask_bits = 2**32 - 2**(32 - mask_len_fragment);
         if( (bit.band(fragment, mask_bits) != bit.tobit(fragment)) ) {
            lexer.error("Non-network bits set in %s", format_ipv6(addr, mask_len));
         }
         mask_len -=   mask_len_fragment;
      }
   }

   var arg = lexer.next({address=true});
   if( type(arg) != 'table' ) {
      lexer.error('named nets currently unsupported');
   } else if( arg[1] == 'ehost' ) {
      lexer.error('ethernet address used in non-ether expression');
   }

   // IPv4 dotted triple, dotted pair or bare net addresses
   if( arg[1] == 'ipv4' && #arg < 5 ) {
      var mask_len = 32;
      for( i=#arg+1,5 ) {
         arg[i] = 0;
         mask_len -=   8;
      }
      return { 'ipv4/len', arg, mask_len };
   }
   if( arg[1] == 'ipv4' || arg[1] == 'ipv6' ) {
      if( lexer.check('/') ) {
         var mask_len = parse_int_arg(lexer, arg[1] == 'ipv4' && 32 || 128);
         if( (arg[1] == 'ipv4') ) {
            var mask_bits = 2**32 - 2**(32 - mask_len);
            check_non_network_bits_in_ipv4(arg, mask_bits, tostring(mask_len));
         }
         if( (arg[1] == 'ipv6') ) {
            check_non_network_bits_in_ipv6(arg, mask_len);
         }
         return { arg[1]..'/len', arg, mask_len };
      } else if( lexer.check('mask') ) {
         if( (arg[1] == 'ipv6') ) {
            lexer.error("Not valid syntax for IPv6");
         }
         var mask = lexer.next({address=true});
         if( type(mask) != 'table' || mask[1] != 'ipv4' ) {
            lexer.error("Invalid IPv4 mask");
         }
         check_non_network_bits_in_ipv4(arg, ipv4_to_int(mask),
            table.concat(mask, '.', 2));
         return { arg[1]..'/mask', arg, mask };
      } else {
         return arg;
      }
   }
}

var function to_port_number(tok) {
   var port = tok;
   if( type(tok) == 'string' ) {
      var next_pos;
      port, next_pos = lex_number(tok, 1, 10);
      if( ! port || next_pos != #tok+1 ) {
         // Token is not a valid decimal literal, fallback to services.
         return constants.services[tok];
      }
   }

   assert(port <= 65535, 'port '..port..' out of range');
   return port;
}

var function parse_port_arg(lexer) {
   var tok = lexer.next();
   var result = to_port_number(tok);
   if( ! result ) {
      lexer.error('unsupported port %s', tok);
   }
   return result;
}

var function parse_portrange_arg(lexer) {
   var tok = lexer.next();

   // Try to split portrange from start to first hyphen, or from start to
   // second hyphen, and so on.
   var pos = 1;
   while( true ) {
      pos = tok->match("^%w+%-()", pos);
      if( ! pos ) {
         lexer.error('error parsing portrange %s', tok);
      }
      var from, to = to_port_number(tok->sub(1, pos - 2)), to_port_number(tok->sub(pos));
      if( from && to ) {
         // For libpcap compatibility, if to < from, swap them
         if( from > to ) { from, to = to, from; }
         return { from, to };
      }
   }
}

var function parse_ehost_arg(lexer) {
   var arg = lexer.next({address=true});
   if( type(arg) == 'string' || arg[1] == 'ehost' ) {
      return arg;
   }
   lexer.error('invalid ethernet host %s', arg);
}

var function table_parser(table, default) {
   return function (lexer, tok) {
      var subtok = lexer.peek();
      if( table[subtok] ) {
         lexer.consume(subtok);
         return table[subtok](lexer, tok..'_'..subtok);
      }
      if( default ) { return default(lexer, tok); }
      lexer.error('unknown %s type %s ', tok, subtok);
   };
}

var ip_protos = set(
   'icmp', 'icmp6', 'igmp', 'igrp', 'pim', 'ah', 'esp', 'vrrp', 'udp', 'tcp', 'sctp'
);

var function parse_proto_arg(lexer, proto_type, protos) {
   lexer.check('\\');
   var arg = lexer.next();
   if( ! proto_type ) { proto_type = 'ip'; }
   if( ! protos ) { protos = ip_protos; }
   if( type(arg) == 'number' ) { return arg; }
   if( type(arg) == 'string' ) {
      var proto = arg->match("^(%w+)");
      if( protos[proto] ) { return proto; }
   }
   lexer.error('invalid %s proto %s', proto_type, arg);
}

var ether_protos = set(
   'ip', 'ip6', 'arp', 'rarp', 'atalk', 'aarp', 'decnet', 'sca', 'lat',
   'mopdl', 'moprc', 'iso', 'stp', 'ipx', 'netbeui'
);

var function parse_ether_proto_arg(lexer) {
   return parse_proto_arg(lexer, 'ethernet', ether_protos);
}

var function parse_ip_proto_arg(lexer) {
   return parse_proto_arg(lexer, 'ip', ip_protos);
}

var iso_protos = set('clnp', 'esis', 'isis');

var function parse_iso_proto_arg(lexer) {
   return parse_proto_arg(lexer, 'iso', iso_protos);
}

var function simple_typed_arg_parser(expected) {
   return function(lexer) {
      var arg = lexer.next();
      if( type(arg) == expected ) { return arg; }
      lexer.error('expected a %s string, got %s', expected, type(arg));
   };
}

var parse_string_arg = simple_typed_arg_parser('string');

var function parse_decnet_host_arg(lexer) {
   var arg = lexer.next({address=true});
   if( type(arg) == 'string' ) { return arg; }
   if( arg[1] == 'ipv4' ) {
      arg[1] = 'decnet';
      assert(#arg == 3, "bad decnet address", arg);
      return arg;
   }
   lexer.error('invalid decnet host %s', arg);
}

var llc_types = set(
   'i', 's', 'u', 'rr', 'rnr', 'rej', 'ui', 'ua',
   'disc', 'sabme', 'test', 'xis', 'frmr'
);

var function parse_llc(lexer, tok) {
   if( llc_types[lexer.peek()] ) { return { tok, lexer.next() }; }
   return { tok };
}

var pf_reasons = set(
   'match', 'bad-offset', 'fragment', 'short', 'normalize', 'memory'
);

var pf_actions = set(
   'pass', 'block', 'nat', 'rdr', 'binat', 'scrub'
);

var wlan_frame_types = set('mgt', 'ctl', 'data');
var wlan_frame_mgt_subtypes = set(
   'assoc-req', 'assoc-resp', 'reassoc-req', 'reassoc-resp',
   'probe-req', 'probe-resp', 'beacon', 'atim', 'disassoc', 'auth', 'deauth'
);
var wlan_frame_ctl_subtypes = set(
   'ps-poll', 'rts', 'cts', 'ack', 'cf-end', 'cf-end-ack'
);
var wlan_frame_data_subtypes = set(
   'data', 'data-cf-ack', 'data-cf-poll', 'data-cf-ack-poll', 'null',
   'cf-ack', 'cf-poll', 'cf-ack-poll', 'qos-data', 'qos-data-cf-ack',
   'qos-data-cf-poll', 'qos-data-cf-ack-poll', 'qos', 'qos-cf-poll',
   'quos-cf-ack-poll'
);

var wlan_directions = set('nods', 'tods', 'fromds', 'dstods');

var function parse_enum_arg(lexer, set) {
   var arg = lexer.next();
   assert(set[arg], 'invalid argument: '..arg);
   return arg;
}

var function enum_arg_parser(set) {
   return function(lexer) { return parse_enum_arg(lexer, set); };
}

var function parse_wlan_type(lexer, tok) {
   var type = enum_arg_parser(wlan_frame_types)(lexer);
   if( lexer.check('subtype') ) {
      var set;
      if( type == 'mgt' ) { set = wlan_frame_mgt_subtypes;
      } else if( type == 'mgt' ) { set = wlan_frame_ctl_subtypes;
      } else { set = wlan_frame_data_subtypes; }
      return { 'type', type, enum_arg_parser(set)(lexer) };
   }
   return { tok, type };
}

var function parse_wlan_subtype(lexer, tok) {
   var subtype = lexer.next();
   assert(wlan_frame_mgt_subtypes[subtype]
             || wlan_frame_ctl_subtypes[subtype]
             || wlan_frame_data_subtypes[subtype],
          'bad wlan subtype '..subtype);
   return { tok, subtype };
}

var function parse_wlan_dir(lexer, tok) {
   if( (type(lexer.peek()) == 'number') ) {
      return { tok, lexer.next() };
   }
   return { tok, parse_enum_arg(lexer, wlan_directions) };
}

var function parse_optional_int(lexer, tok) {
   if( (type(lexer.peek()) == 'number') ) {
      return { tok, lexer.next() };
   }
   return { tok };
}

var src_or_dst_types = {
   host = unary(parse_host_arg),
   net = unary(parse_net_arg),
   port = unary(parse_port_arg),
   portrange = unary(parse_portrange_arg)
};

var ether_host_type = {
   host = unary(parse_ehost_arg)
};

var ether_types = {
   dst = table_parser(ether_host_type, unary(parse_ehost_arg)),
   src = table_parser(ether_host_type, unary(parse_ehost_arg)),
   host = unary(parse_ehost_arg),
   broadcast = nullary(),
   multicast = nullary(),
   proto = unary(parse_ether_proto_arg),
};

var ip_types = {
   dst = table_parser(src_or_dst_types, unary(parse_host_arg)),
   src = table_parser(src_or_dst_types, unary(parse_host_arg)),
   host = unary(parse_host_arg),
   proto = unary(parse_ip_proto_arg),
   protochain = unary(parse_ip_proto_arg),
   broadcast = nullary(),
   multicast = nullary(),
};

var ip6_types = {
   proto = unary(parse_ip_proto_arg),
   protochain = unary(parse_ip_proto_arg),
   broadcast = nullary(),
   multicast = nullary(),
};

var decnet_host_type = {
   host = unary(parse_decnet_host_arg),
};

var decnet_types = {
   src = table_parser(decnet_host_type, unary(parse_decnet_host_arg)),
   dst = table_parser(decnet_host_type, unary(parse_decnet_host_arg)),
   host = unary(parse_decnet_host_arg),
};

var wlan_types = {
   ra = unary(parse_ehost_arg),
   ta = unary(parse_ehost_arg),
   addr1 = unary(parse_ehost_arg),
   addr2 = unary(parse_ehost_arg),
   addr3 = unary(parse_ehost_arg),
   addr4 = unary(parse_ehost_arg),

   // As an alias of 'ether'
   dst = table_parser(ether_host_type, unary(parse_ehost_arg)),
   src = table_parser(ether_host_type, unary(parse_ehost_arg)),
   host = unary(parse_ehost_arg),
   broadcast = nullary(),
   multicast = nullary(),
   proto = unary(parse_ether_proto_arg),
};

var iso_types = {
   proto = unary(parse_iso_proto_arg),
   ta = unary(parse_ehost_arg),
   addr1 = unary(parse_ehost_arg),
   addr2 = unary(parse_ehost_arg),
   addr3 = unary(parse_ehost_arg),
   addr4 = unary(parse_ehost_arg),
};

var tcp_or_udp_types = {
   port = unary(parse_port_arg),
   portrange = unary(parse_portrange_arg),
   dst = table_parser(src_or_dst_types),
   src = table_parser(src_or_dst_types),
};

var arp_types = {
   dst = table_parser(src_or_dst_types, unary(parse_host_arg)),
   src = table_parser(src_or_dst_types, unary(parse_host_arg)),
   host = unary(parse_host_arg),
};

var rarp_types = {
   dst = table_parser(src_or_dst_types, unary(parse_host_arg)),
   src = table_parser(src_or_dst_types, unary(parse_host_arg)),
   host = unary(parse_host_arg),
};

var parse_arithmetic;

var function parse_addressable(lexer, tok) {
   if( ! tok ) {
      tok = lexer.next({maybe_arithmetic=true});
      if( ! addressables[tok] ) {
         lexer.error('bad token while parsing addressable: %s', tok);
      }
   }
   lexer.consume('[');
   var pos = parse_arithmetic(lexer);
   var size = 1;
   if( lexer.check(':') ) {
      if( lexer.check(1) ) { size = 1;
      } else if( lexer.check(2) ) { size = 2;
      } else { lexer.consume(4); size = 4; }
   }
   lexer.consume(']');
   return { '['..tok..']', pos, size};
}

var function parse_primary_arithmetic(lexer, tok) {
   tok = tok || lexer.next({maybe_arithmetic=true});
   if( tok == '(' ) {
      var expr = parse_arithmetic(lexer);
      lexer.consume(')');
      return expr;
   } else if( filter_args[tok] || type(tok) == 'number' ) {
      return tok;
   } else if( allow_address_of && tok == '&' ) {
      return { 'addr', parse_addressable(lexer) };
   } else if( addressables[tok] ) {
      return parse_addressable(lexer, tok);
   } else {
      // 'tok' may be a constant
      var val = constants.protocol_header_field_offsets[tok] ||
                  constants.icmp_type_fields[tok] ||
                  constants.tcp_flag_fields[tok];
      if( val != null ) { return val; }
      lexer.error('bad token while parsing arithmetic expression %s', tok);
   }
}

var arithmetic_precedence = {
   ['*'] = 1, ['/'] = 1,
   ['+'] = 2, ['-'] = 2,
   ['<<'] = 3, ['>>'] = 3,
   ['&'] = 4,
   ['^'] = 5,
   ['|'] = 6
};

function parse_arithmetic(lexer, tok, max_precedence, parsed_exp) {
   var exp = parsed_exp || parse_primary_arithmetic(lexer, tok);
   max_precedence = max_precedence || math.huge;
   while( true ) {
      var op = lexer.peek();
      var prec = arithmetic_precedence[op];
      if( ! prec || prec > max_precedence ) { return exp; }
      lexer.consume(op);
      var rhs = parse_arithmetic(lexer, null, prec - 1);
      exp = { op, exp, rhs };
   }
}

var primitives = {
   dst = table_parser(src_or_dst_types, unary(parse_host_arg)),
   src = table_parser(src_or_dst_types, unary(parse_host_arg)),
   host = unary(parse_host_arg),
   ether = table_parser(ether_types),
   fddi = table_parser(ether_types),
   tr = table_parser(ether_types),
   wlan = table_parser(wlan_types),
   broadcast = nullary(),
   multicast = nullary(),
   gateway = unary(parse_string_arg),
   net = unary(parse_net_arg),
   port = unary(parse_port_arg),
   portrange = unary(parse_portrange_arg),
   less = unary(parse_arithmetic),
   greater = unary(parse_arithmetic),
   ip = table_parser(ip_types, nullary()),
   ip6 = table_parser(ip6_types, nullary()),
   proto = unary(parse_proto_arg),
   tcp = table_parser(tcp_or_udp_types, nullary()),
   udp = table_parser(tcp_or_udp_types, nullary()),
   icmp = nullary(),
   icmp6 = nullary(),
   igmp = nullary(),
   igrp = nullary(),
   pim = nullary(),
   ah = nullary(),
   esp = nullary(),
   vrrp = nullary(),
   sctp = nullary(),
   protochain = unary(parse_proto_arg),
   arp = table_parser(arp_types, nullary()),
   rarp = table_parser(rarp_types, nullary()),
   atalk = nullary(),
   aarp = nullary(),
   decnet = table_parser(decnet_types, nullary()),
   iso = nullary(),
   stp = nullary(),
   ipx = nullary(),
   netbeui = nullary(),
   sca = nullary(),
   lat = nullary(),
   moprc = nullary(),
   mopdl = nullary(),
   llc = parse_llc,
   ifname = unary(parse_string_arg),
   on = unary(parse_string_arg),
   rnr = unary(parse_int_arg),
   rulenum = unary(parse_int_arg),
   reason = unary(enum_arg_parser(pf_reasons)),
   rset = unary(parse_string_arg),
   ruleset = unary(parse_string_arg),
   srnr = unary(parse_int_arg),
   subrulenum = unary(parse_int_arg),
   action = unary(enum_arg_parser(pf_actions)),
   type = parse_wlan_type,
   subtype = parse_wlan_subtype,
   dir = unary(enum_arg_parser(wlan_directions)),
   vlan = parse_optional_int,
   mpls = parse_optional_int,
   pppoed = nullary(),
   pppoes = parse_optional_int,
   iso = table_parser(iso_types, nullary()),
   clnp = nullary(),
   esis = nullary(),
   isis = nullary(),
   l1 = nullary(),
   l2 = nullary(),
   iih = nullary(),
   lsp = nullary(),
   snp = nullary(),
   csnp = nullary(),
   psnp = nullary(),
   vpi = unary(parse_int_arg),
   vci = unary(parse_int_arg),
   lane = nullary(),
   oamf4s = nullary(),
   oamf4e = nullary(),
   oamf4 = nullary(),
   oam = nullary(),
   metac = nullary(),
   bcc = nullary(),
   sc = nullary(),
   ilmic = nullary(),
   connectmsg = nullary(),
   metaconnect = nullary()
};

var function parse_primitive_or_arithmetic(lexer) {
   var tok = lexer.next({maybe_arithmetic=true});
   if( (type(tok) == 'number' || filter_args[tok] ||
       addressables[tok] && lexer.peek() == '[') ) {
      return parse_arithmetic(lexer, tok);
   }

   var parser = primitives[tok];
   if( parser ) { return parser(lexer, tok); }

   // At this point the official pcap grammar is squirrely.  It says:
   // "If an identifier is given without a keyword, the most recent
   // keyword is assumed.  For example, `not host vs and ace' is
   // short for `not host vs and host ace` and which should not be
   // confused with `not (host vs or ace)`."  For now we punt on this
   // part of the grammar.
   var msg =
[=[%s is not a recognized keyword. Likely causes:
a) %s is a typo, invalid keyword, or similar error.
b) You're trying to implicitly repeat the previous clause's keyword.
Instead of libpcap-style elision, explicitly use keywords in each clause:
ie, "host a and host b", not "host a and b".]=];

   var err = string.format(msg, tok, tok);
   lexer.error(err);
}

var logical_ops = set('&&', 'and', '||', 'or');

var function is_arithmetic(exp) {
   return (filter_args[exp] || type(exp) == 'number' ||
              exp[1]->match("^%[") || arithmetic_precedence[exp[1]]);
}

var parse_logical;

var function parse_logical_or_arithmetic(lexer, pick_first) {
   var exp;
   if( lexer.peek() == 'not' || lexer.peek() == '!' ) {
      exp = { lexer.next(), parse_logical(lexer, true) };
   } else if( lexer.check('(') ) {
      exp = parse_logical_or_arithmetic(lexer);
      lexer.consume(')');
   } else {
      exp = parse_primitive_or_arithmetic(lexer);
   }
   if( is_arithmetic(exp) ) {
      if( arithmetic_precedence[lexer.peek()] ) {
         exp = parse_arithmetic(lexer, null, null, exp);
      }
      if( lexer.peek() == ')' ) { return exp; }
      var op = lexer.next();
      assert(set('>', '<', '>=', '<=', '=', '!=', '==')[op],
             "expected a comparison operator, got "..op);
      // Normalize == to =, because libpcap treats them identically
      if( op == '==' ) { op = '='; }
      exp = { op, exp, parse_arithmetic(lexer) };
   }
   if( pick_first ) { return exp; }
   while( true ) {
      var op = lexer.peek();
      if( ! op || op == ')' ) { return exp; }
      var is_logical = logical_ops[op];
      if( is_logical ) {
         lexer.consume(op);
      } else {
         // The grammar is such that "tcp port 80" should actually
         // parse as "tcp and port 80".
         op = 'and';
      }
      var rhs = parse_logical(lexer, true);
      exp = { op, exp, rhs };
   }
}

function parse_logical(lexer, pick_first) {
   var expr = parse_logical_or_arithmetic(lexer, pick_first);
   assert(! is_arithmetic(expr), "expected a logical expression");
   return expr;
}

function parse(str, opts) {
   opts = opts || {};
   var lexer = tokens(str);
   var expr;
   if( opts.arithmetic ) {
      expr = parse_arithmetic(lexer);
   } else {
      if( ! lexer.peek({maybe_arithmetic=true}) ) { return { 'true' }; }
      expr = parse_logical(lexer);
   }
   if( lexer.peek() ) { error("unexpected token "..lexer.peek()); }
   return expr;
}

function selftest () {
   print("selftest: pf.parse");
   var function check(expected, actual) {
      assert(type(expected) == type(actual),
             "expected type "..type(expected).." but got "..type(actual));
      if( type(expected) == 'table' ) {
         for( k, v in pairs(expected) ) { check(v, actual[k]); }
      } else {
         assert(expected == actual, "expected "..expected.." but got "..actual);
      }
   }

   var function lex_test(str, elts, opts) {
      var lexer = tokens(str);
      for( i, val in ipairs(elts) ) {
         check(val, lexer.next(opts));
      }
      assert(! lexer.peek(opts), "more tokens, yo");
   }
   lex_test("ip", {"ip"}, {maybe_arithmetic=true});
   lex_test("len", {"len"}, {maybe_arithmetic=true});
   lex_test("len", {"len"}, {});
   lex_test("len-1", {"len-1"}, {});
   lex_test("len-1", {"len", "-", 1}, {maybe_arithmetic=true});
   lex_test("1-len", {1, "-", "len"}, {maybe_arithmetic=true});
   lex_test("1-len", {"1-len"}, {});
   lex_test("tcp port 80", {"tcp", "port", 80}, {});
   lex_test("tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)",
            { 'tcp', 'port', 80, 'and',
              '(', '(',
              '(',
              'ip', '[', 2, ':', 2, ']', '-',
              '(', '(', 'ip', '[', 0, ']', '&', 15, ')', '<<', 2, ')',
              ')',
              '-',
              '(', '(', 'tcp', '[', 12, ']', '&', 240, ')', '>>', 2, ')',
              ')', '!=', 0, ')'
            }, {maybe_arithmetic=true});
   lex_test("127.0.0.1", { { 'ipv4', 127, 0, 0, 1 } }, {address=true});
   lex_test("::", { { 'ipv6', 0, 0, 0, 0, 0, 0, 0, 0 } }, {address=true});
   lex_test("eee:eee:eee:eee:eee:eee:10.20.30.40",
            { { 'ipv6', 3822, 3822, 3822, 3822, 3822, 3822, 2580, 7720 } }, {address=true});
   lex_test("::10.20.30.40",
            { { 'ipv6', 0, 0, 0, 0, 0, 0, 2580, 7720 } }, {address=true});

   var function addr_error_test(str, expected_err) {
      var lexer = tokens(str);
      var ok, actual_err = pcall(lexer.peek, {address=true});
      if( ! ok ) {
         if( expected_err ) {
            assert(actual_err->find(expected_err, 1, true),
                   "expected error "..expected_err.." but got "..actual_err);
         }
      } else {
         error("expected error, got no error");
      }
   }
   addr_error_test("1:1:1::1:1:1:1:1", "wrong IPv6 address");
   addr_error_test("1:11111111", "wrong IPv6 address");
   addr_error_test("1::1:", "wrong IPv6 address");
   addr_error_test("1:2:3:4:5:6:7:1.2.3.4", "wrong IPv6 address");
   addr_error_test("1:2:3:4:5:1.2.3.4", "wrong IPv6 address");
   addr_error_test("1:2:3:4:5:1.2.3.4.5", "wrong IPv6 address");
   addr_error_test("1:2:3:4:5:6:1.2.3..", "wrong IPv6 address");
   addr_error_test("1:2:3:4:5:6:1.2.3.4.", "wrong IPv6 address");
   addr_error_test("1:2:3:4:5:6:1.2.3.300", "wrong IPv6 address");

   var function parse_test(str, elts) { check(elts, parse(str)); }
   parse_test("",
              { 'true' });
   parse_test("host 127.0.0.1",
              { 'host', { 'ipv4', 127, 0, 0, 1 } });
   parse_test("host 1www.foo.com",
              { 'host', '1www.foo.com' });
   parse_test("host 999.foo.com",
              { 'host', '999.foo.com' });
   parse_test("host 200.foo.com",
              { 'host', '200.foo.com' });
   parse_test("host 1.2.3.4foo.com",
              { 'host', '1.2.3.4foo.com' });
   parse_test("host 1.2.3.4.5.com",
              { 'host', '1.2.3.4.5.com' });
   parse_test("host 0xffffffffffoo.com",
              { 'host', '0xffffffffffoo.com' });
   parse_test("host 0xffffffffff-oo.com",
              { 'host', '0xffffffffff-oo.com' });
   parse_test("src host 127.0.0.1",
              { 'src_host', { 'ipv4', 127, 0, 0, 1 } });
   parse_test("src 127.0.0.1",
              { 'src', { 'ipv4', 127, 0, 0, 1 } });
   parse_test("dst 1::ff11",
              { 'dst', { 'ipv6', 1, 0, 0, 0, 0, 0, 0, 65297 } });
   parse_test("src net 10.0.0.0/24",
              { 'src_net',
                { 'ipv4/len', { 'ipv4', 10, 0, 0, 0 }, 24 }});
   parse_test("ether proto rarp",
              { 'ether_proto', 'rarp' });
   parse_test("ether proto \\rarp",
              { 'ether_proto', 'rarp' });
   parse_test("ether proto \\100",
              { 'ether_proto', 100 });
   parse_test("ip proto tcp",
              { 'ip_proto', 'tcp' });
   parse_test("ip proto \\tcp",
              { 'ip_proto', 'tcp' });
   parse_test("ip proto \\0",
              { 'ip_proto', 0 });
   parse_test("decnet host 10.23",
              { 'decnet_host', { 'decnet', 10, 23 } });
   parse_test("ip proto icmp",
              { 'ip_proto', 'icmp' });
   parse_test("ip6 protochain icmp",
              { 'ip6_protochain', 'icmp' });
   parse_test("ip6 protochain 100",
              { 'ip6_protochain', 100 });
   parse_test("ip",
              { 'ip' });
   parse_test("type mgt",
              { 'type', 'mgt' });
   parse_test("type mgt subtype deauth",
              { 'type', 'mgt', 'deauth' });
   parse_test("1+1=2",
              { '=', { '+', 1, 1 }, 2 });
   parse_test("len=4", { '=', 'len', 4 });
   parse_test("(len-4>10)", { '>', { '-', 'len', 4 }, 10 });
   parse_test("len == 4", { '=', 'len', 4 });
   parse_test("sctp", { 'sctp' });
   parse_test("1+2*3+4=5",
              { '=', { '+', { '+', 1, { '*', 2, 3 } }, 4 }, 5 });
   parse_test("1+1=2 and tcp",
              { 'and', { '=', { '+', 1, 1 }, 2 }, { 'tcp' } });
   parse_test("tcp port 80 and 1+1=2",
              { 'and', { 'tcp_port', 80 }, { '=', { '+', 1, 1 }, 2 } });
   parse_test("1+1=2 and tcp or tcp",
              { 'or', { 'and', { '=', { '+', 1, 1 }, 2 }, { 'tcp' } }, { 'tcp' } });
   parse_test("1+1=2 or tcp and tcp",
              { 'and', { 'or', { '=', { '+', 1, 1 }, 2 }, { 'tcp' } }, { 'tcp' } });
   parse_test("not 1=1 or tcp",
              { 'or', { 'not', { '=', 1, 1 } }, { 'tcp' } });
   parse_test("not (1=1 or tcp)",
              { 'not', { 'or', { '=', 1, 1 }, { 'tcp' } } });
   parse_test("1+1=2 and (tcp)",
              { 'and', { '=', { '+', 1, 1 }, 2 }, { 'tcp' } });
   parse_test("tcp && ip || !1=1",
              { '||', { '&&', { 'tcp' }, { 'ip' } }, { '!', { '=', 1, 1 } } });
   parse_test("tcp src portrange 80-90",
              { 'tcp_src_portrange', { 80, 90 } });
   parse_test("tcp src portrange ftp-data-90",
              { 'tcp_src_portrange', { 20, 90 } });
   parse_test("tcp src portrange 80-ftp-data",
              { 'tcp_src_portrange', { 20, 80 } }); // swapped!
   parse_test("tcp src portrange ftp-data-iso-tsap",
              { 'tcp_src_portrange', { 20, 102 } });
   parse_test("tcp src portrange echo-ftp-data",
              { 'tcp_src_portrange', { 7, 20 } });
   parse_test("tcp port 80",
              { 'tcp_port', 80 });
   parse_test("tcp port 0x50",
              { 'tcp_port', 80 });
   parse_test("tcp port 0120",
              { 'tcp_port', 80 });
   parse_test("tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)",
              { "and",
                 { "tcp_port", 80 },
                 { "!=",
                    { "-", { "-", { "[ip]", 2, 2 },
                       { "<<", { "&", { "[ip]", 0, 1 }, 15 }, 2 } },
                    { ">>", { "&", { "[tcp]", 12, 1 }, 240 }, 2 } }, 0 } });
   parse_test("ether host ff:ff:ff:33:33:33",
             { 'ether_host', { 'ehost', 255, 255, 255, 51, 51, 51 } });
   parse_test("fddi host ff:ff:ff:33:33:33",
             { 'fddi_host', { 'ehost', 255, 255, 255, 51, 51, 51 } });
   parse_test("tr host ff:ff:ff:33:33:33",
             { 'tr_host', { 'ehost', 255, 255, 255, 51, 51, 51 } });
   parse_test("wlan host ff:ff:ff:33:33:33",
             { 'wlan_host', { 'ehost', 255, 255, 255, 51, 51, 51 } });
   parse_test("ether host f:f:f:3:3:3",
             { 'ether_host', { 'ehost', 15, 15, 15, 3, 3, 3 } });
   parse_test("src net 192.168.1.0/24",
             { 'src_net', { 'ipv4/len', { 'ipv4', 192, 168, 1, 0 }, 24 } });
   parse_test("src net 192.168.1.0 mask 255.255.255.0",
             { 'src_net', { 'ipv4/mask', { 'ipv4', 192, 168, 1, 0 }, { 'ipv4', 255, 255, 255, 0 } } });
   parse_test("host 0:0:0:0:0:0:0:1",
             { 'host', { 'ipv6', 0, 0, 0, 0, 0, 0, 0, 1 } });
   parse_test("host ::1",
             { 'host', { 'ipv6', 0, 0, 0, 0, 0, 0, 0, 1 } });
   parse_test("host 1::1",
             { 'host', { 'ipv6', 1, 0, 0, 0, 0, 0, 0, 1 } });
   parse_test("host 1::",
             { 'host', { 'ipv6', 1, 0, 0, 0, 0, 0, 0, 0 } });
   parse_test("src net eee:eee::0/96",
             { 'src_net', { 'ipv6/len', { 'ipv6', 3822, 3822, 0, 0, 0, 0, 0, 0 }, 96 } });
   parse_test("src net 3ffe:500::/28",
             { 'src_net', { 'ipv6/len', { 'ipv6', 16382, 1280, 0, 0, 0, 0, 0, 0 }, 28 } });
   parse_test("src net 192.168.1.0/24",
             { 'src_net', { 'ipv4/len', { 'ipv4', 192, 168, 1, 0 }, 24 } });
   parse_test("src net 192.168.1.0 mask 255.255.255.0",
             { 'src_net', { 'ipv4/mask', { 'ipv4', 192, 168, 1, 0 }, { 'ipv4', 255, 255, 255, 0 } } });
   parse_test("less 100", {"less", 100});
   parse_test("greater 50 + 50", {"greater", {"+", 50, 50}});
   parse_test("sctp[8] < 8", {'<', { '[sctp]', 8, 1 }, 8});
   parse_test("igmp[8] < 8", {'<', { '[igmp]', 8, 1 }, 8});
   parse_test("igrp[8] < 8", {'<', { '[igrp]', 8, 1 }, 8});
   parse_test("pim[8] < 8", {'<', { '[pim]', 8, 1 }, 8});
   parse_test("vrrp[8] < 8", {'<', { '[vrrp]', 8, 1 }, 8});
   parse_test("not icmp6", {'not', { 'icmp6' } });
   parse_test("icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply",
              { "and",
                { "!=", { "[icmp]", 0, 1 }, 8 },
                { "!=", { "[icmp]", 0, 1 }, 0 } });
   parse_test("net 192.0.0.0", {'net', { 'ipv4', 192, 0, 0, 0 } });
   parse_test("net 192.168.1.0/24",
               { 'net', { 'ipv4/len', { 'ipv4', 192, 168, 1, 0 }, 24 } });
   parse_test("net 192.168.1",
               { 'net', { 'ipv4/len', { 'ipv4', 192, 168, 1, 0 }, 24 } });
   parse_test("net 192.168",
               { 'net', { 'ipv4/len', { 'ipv4', 192, 168, 0, 0 }, 16 } });
   parse_test("net 192",
               { 'net', { 'ipv4/len', { 'ipv4', 192, 0, 0, 0 }, 8 } });
   parse_test("net  192",
               { 'net', { 'ipv4/len', { 'ipv4', 192, 0, 0, 0 }, 8 } });

   var function parse_error_test(str, expected_err) {
      var ok, actual_err = pcall(parse, str);
      assert(! ok, "expected error, got no error");
      if( expected_err ) {
         assert(actual_err->find(expected_err, 1, true),
                "expected error "..expected_err.." but got "..actual_err);
      }
   }
   parse_error_test("tcp src portrange 80-fffftp-data", "error parsing portrange 80-fffftp-data");
   parse_error_test("tcp src portrange 80000-90000", "port 80000 out of range");
   parse_error_test("tcp src portrange 0x1-0x2", "error parsing portrange 0x1-0x2");
   parse_error_test("tcp src portrange ::1", "error parsing portrange :");
   parse_error_test("tcp src port ::1", "unsupported port :");
   parse_error_test("123$", "unexpected end of decimal literal at 1");
   parse_error_test("0x123$", "unexpected end of hexadecimal literal at 1");
   parse_error_test("0123$", "unexpected end of octal literal at 1");
   parse_error_test("0 = 0x", "unexpected end of hexadecimal literal at 5");
   parse_error_test("0 = 08", "unexpected end of octal literal at 5");
   parse_error_test("0 = 09", "unexpected end of octal literal at 5");
   parse_error_test("host 0xffffffffff and tcp", "integer too large: 0xffffffffff");
   parse_error_test("host ff:ff:ff:ff:ff:ff", "ethernet address used in non-ether expression");
   parse_error_test("net ff:ff:ff:ff:ff:ff", "ethernet address used in non-ether expression");
   parse_error_test("net 192.168.1.0 mask foobar", "Invalid IPv4 mask");
   parse_error_test("net 192.168.1.0 mask ::", "Invalid IPv4 mask");
   parse_error_test("net 192.168.1.0 mask ff:ff:ff:ff:ff:ff", "Invalid IPv4 mask");
   print("OK");
}
