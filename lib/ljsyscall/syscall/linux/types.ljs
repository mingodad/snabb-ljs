// Linux kernel types

var require, error, assert, tonumber, tostring,
setmetatable, pairs, ipairs, unpack, rawget, rawset,
pcall, type, table, string = 
require, error, assert, tonumber, tostring,
setmetatable, pairs, ipairs, unpack, rawget, rawset,
pcall, type, table, string;

// TODO add __len to metatables of more

var function init(types) {

var abi = require ("syscall.abi");

var t, pt, s, ctypes = types.t, types.pt, types.s, types.ctypes;

var ffi = require ("ffi");
var bit = require ("syscall.bit");

var h = require ("syscall.helpers");

var addtype, addtype_var, addtype_fn, addraw2 = h.addtype, h.addtype_var, h.addtype_fn, h.addraw2;
var ptt, reviter, mktype, istype, lenfn, lenmt, getfd, newfn
  = h.ptt, h.reviter, h.mktype, h.istype, h.lenfn, h.lenmt, h.getfd, h.newfn;
var ntohl, ntohs, htons = h.ntohl, h.ntohs, h.htons;
var split, trim = h.split, h.trim;

var c = require ("syscall.linux.constants");

var mt = {}; // metatables

// TODO cleanup this (what should provide this?)
var signal_reasons_gen = {};
var signal_reasons = {};

for( k, v in pairs(c.SI) ) {
  signal_reasons_gen[v] = k;
}

signal_reasons[c.SIG.ILL] = {};
for( k, v in pairs(c.SIGILL) ) {
  signal_reasons[c.SIG.ILL][v] = k;
}

signal_reasons[c.SIG.FPE] = {};
for( k, v in pairs(c.SIGFPE ) ) {
  signal_reasons[c.SIG.FPE][v] = k;
}

signal_reasons[c.SIG.SEGV] = {};
for( k, v in pairs(c.SIGSEGV) ) {
  signal_reasons[c.SIG.SEGV][v] = k;
}

signal_reasons[c.SIG.BUS] = {};
for( k, v in pairs(c.SIGBUS) ) {
  signal_reasons[c.SIG.BUS][v] = k;
}

signal_reasons[c.SIG.TRAP] = {};
for( k, v in pairs(c.SIGTRAP) ) {
  signal_reasons[c.SIG.TRAP][v] = k;
}

signal_reasons[c.SIG.CHLD] = {};
for( k, v in pairs(c.SIGCLD) ) {
  signal_reasons[c.SIG.CHLD][v] = k;
}

signal_reasons[c.SIG.POLL] = {};
for( k, v in pairs(c.SIGPOLL || {}) ) {
  signal_reasons[c.SIG.POLL][v] = k;
}

var addtypes = {
  fdset = "fd_set",
  clockid = "clockid_t",
  sighandler = "sighandler_t",
  aio_context = "aio_context_t",
  clockid = "clockid_t",
};

var addstructs = {
  ucred = "struct ucred",
  sysinfo = "struct sysinfo",
  nlmsghdr = "struct nlmsghdr",
  rtgenmsg = "struct rtgenmsg",
  ifinfomsg = "struct ifinfomsg",
  ifaddrmsg = "struct ifaddrmsg",
  rtattr = "struct rtattr",
  rta_cacheinfo = "struct rta_cacheinfo",
  nlmsgerr = "struct nlmsgerr",
  nda_cacheinfo = "struct nda_cacheinfo",
  ndt_stats = "struct ndt_stats",
  ndtmsg = "struct ndtmsg",
  ndt_config = "struct ndt_config",
  utsname = "struct utsname",
  fdb_entry = "struct fdb_entry",
  seccomp_data = "struct seccomp_data",
  rtnl_link_stats = "struct rtnl_link_stats",
  statfs = "struct statfs64",
  ifa_cacheinfo = "struct ifa_cacheinfo",
  input_event = "struct input_event",
  input_id = "struct input_id",
  input_absinfo = "struct input_absinfo",
  input_keymap_entry = "struct input_keymap_entry",
  ff_replay = "struct ff_replay",
  ff_trigger = "struct ff_trigger",
  ff_envelope = "struct ff_envelope",
  ff_constant_effect = "struct ff_constant_effect",
  ff_ramp_effect = "struct ff_ramp_effect",
  ff_condition_effect = "struct ff_condition_effect",
  ff_periodic_effect = "struct ff_periodic_effect",
  ff_rumble_effect = "struct ff_rumble_effect",
  ff_effect = "struct ff_effect",
  sock_fprog = "struct sock_fprog",
  user_cap_header = "struct user_cap_header",
  user_cap_data = "struct user_cap_data",
  xt_get_revision = "struct xt_get_revision",
  vfs_cap_data = "struct vfs_cap_data",
  ucontext = "ucontext_t",
  mcontext = "mcontext_t",
  tun_pi = "struct tun_pi",
  tun_filter = "struct tun_filter",
  vhost_vring_state = "struct vhost_vring_state",
  vhost_vring_file = "struct vhost_vring_file",
  vhost_vring_addr = "struct vhost_vring_addr",
  vhost_memory_region = "struct vhost_memory_region",
  vhost_memory = "struct vhost_memory",
};

for( k, v in pairs(addtypes) ) { addtype(types, k, v); }
for( k, v in pairs(addstructs) ) { addtype(types, k, v, lenmt); }

// these ones not in table as not helpful with vararg or arrays TODO add more addtype variants
t.inotify_event = ffi.typeof("struct inotify_event");
pt.inotify_event = ptt("struct inotify_event"); // still need pointer to this

t.aio_context1 = ffi.typeof("aio_context_t[1]");
t.sock_fprog1 = ffi.typeof("struct sock_fprog[1]");

t.user_cap_data2 = ffi.typeof("struct user_cap_data[2]");

// luaffi gets confused if call ffi.typeof("...[?]") it calls __new so redefine as functions
var iocbs = ffi.typeof("struct iocb[?]");
t.iocbs = function(n, ...) { return ffi.new(iocbs, n, ...); };
var sock_filters = ffi.typeof("struct sock_filter[?]");
t.sock_filters = function(n, ...) { return ffi.new(sock_filters, n, ...); };
var iocb_ptrs = ffi.typeof("struct iocb *[?]");
t.iocb_ptrs = function(n, ...) { return ffi.new(iocb_ptrs, n, ...); };

// types with metatypes

// Note 32 bit dev_t; glibc has 64 bit dev_t but we use syscall API which does not
var function makedev(major, minor) {
  if( type(major) == "table" ) { major, minor = major[1], major[2]; }
  var dev = major || 0;
  if( minor ) { dev = bit.bor(bit.lshift(bit.band(minor, 0xffffff00), 12), bit.band(minor, 0xff), bit.lshift(major, 8)); }
  return dev;
}

mt.device = {
  index = {
    major = function(dev) {
      var d = dev.dev;
      return bit.band(bit.rshift(d, 8), 0x00000fff);
    },
    minor = function(dev) {
      var d = dev.dev;
      return bit.bor(bit.band(d, 0x000000ff), bit.band(bit.rshift(d, 12), 0x000000ff));
    },
    device = function(dev) { return tonumber(dev.dev); },
  },
  newindex = {
    device = function(dev, major, minor) { dev.dev = makedev(major, minor); },
  },
  __new = function(tp, major, minor) {
    return ffi.new(tp, makedev(major, minor));
  },
};

addtype(types, "device", "struct {dev_t dev;}", mt.device);

mt.sockaddr = {
  index = {
    family = function(sa) { return sa.sa_family; },
  },
};

addtype(types, "sockaddr", "struct sockaddr", mt.sockaddr);

// cast socket address to actual type based on family, defined later
var samap_pt = {};

mt.sockaddr_storage = {
  index = {
    family = function(sa) { return sa.ss_family; },
  },
  newindex = {
    family = function(sa, v) { sa.ss_family = c.AF[v]; },
  },
  __index = function(sa, k) {
    if( mt.sockaddr_storage.index[k] ) { return mt.sockaddr_storage.index[k](sa); }
    var st = samap_pt[sa.ss_family];
    if( st ) {
      var cs = st(sa);
      return cs[k];
    }
    error("invalid index " .. k);
  },
  __newindex = function(sa, k, v) {
    if( mt.sockaddr_storage.newindex[k] ) {
      mt.sockaddr_storage.newindex[k](sa, v);
      return;
    }
    var st = samap_pt[sa.ss_family];
    if( st ) {
      var cs = st(sa);
      cs[k] = v;
      return;
    }
    error("invalid index " .. k);
  },
  __new = function(tp, init) {
    var ss = ffi.new(tp);
    var family;
    if( init && init.family ) { family = c.AF[init.family]; }
    var st;
    if( family ) {
      st = samap_pt[family];
      ss.ss_family = family;
      init.family = null;
    }
    if( st ) {
      var cs = st(ss);
      for( k, v in pairs(init) ) {
        cs[k] = v;
      }
    }
    return ss;
  },
  // netbsd likes to see the correct size when it gets a sockaddr; Linux was ok with a longer one
  __len = function(sa) {
    if( samap_pt[sa.family] ) {
      var cs = samap_pt[sa.family](sa);
      return #cs;
    } else {
      return s.sockaddr_storage;
    }
  },
};

// experiment, see if we can use this as generic type, to avoid allocations.
addtype(types, "sockaddr_storage", "struct sockaddr_storage", mt.sockaddr_storage);

mt.sockaddr_in = {
  index = {
    family = function(sa) { return sa.sin_family; },
    port = function(sa) { return ntohs(sa.sin_port); },
    addr = function(sa) { return sa.sin_addr; },
  },
  newindex = {
    family = function(sa, v) { sa.sin_family = v; },
    port = function(sa, v) { sa.sin_port = htons(v); },
    addr = function(sa, v) { sa.sin_addr = mktype(t.in_addr, v); },
  },
  __new = function(tp, port, addr) {
    if( type(port) == "table" ) { return newfn(tp, port); }
    return newfn(tp, {family = c.AF.INET, port = port, addr = addr});
  },
  __len = function(tp) { return s.sockaddr_in; },
};

addtype(types, "sockaddr_in", "struct sockaddr_in", mt.sockaddr_in);

mt.sockaddr_in6 = {
  index = {
    family = function(sa) { return sa.sin6_family; },
    port = function(sa) { return ntohs(sa.sin6_port); },
    addr = function(sa) { return sa.sin6_addr; },
  },
  newindex = {
    family = function(sa, v) { sa.sin6_family = v; },
    port = function(sa, v) { sa.sin6_port = htons(v); },
    addr = function(sa, v) { sa.sin6_addr = mktype(t.in6_addr, v); },
    flowinfo = function(sa, v) { sa.sin6_flowinfo = v; },
    scope_id = function(sa, v) { sa.sin6_scope_id = v; },
  },
  __new = function(tp, port, addr, flowinfo, scope_id) { // reordered initialisers.
    if( type(port) == "table" ) { return newfn(tp, port); }
    return newfn(tp, {family = c.AF.INET6, port = port, addr = addr, flowinfo = flowinfo, scope_id = scope_id});
  },
  __len = function(tp) { return s.sockaddr_in6; },
};

addtype(types, "sockaddr_in6", "struct sockaddr_in6", mt.sockaddr_in6);

// we do provide this directly for compatibility, only use for standard names
mt.sockaddr_un = {
  index = {
    family = function(sa) { return sa.sun_family; },
    path = function(sa) { return ffi.string(sa.sun_path); }, // only valid for proper names
  },
  newindex = {
    family = function(sa, v) { sa.sun_family = v; },
    path = function(sa, v) { ffi.copy(sa.sun_path, v); },
  },
  __new = function(tp, path) { return newfn(tp, {family = c.AF.UNIX, path = path}); }, // TODO accept table initialiser
  __len = function(tp) { return s.sockaddr_un; }, // TODO lenfn (default) instead
};

addtype(types, "sockaddr_un", "struct sockaddr_un", mt.sockaddr_un);

// this is a bit odd, but we actually use Lua metatables for sockaddr_un, and use t.sa to multiplex
// basically the lINUX unix socket structure is not possible to interpret without size, but does not have size in struct
// nasty, but have not thought of a better way yet; could make an ffi type
var lua_sockaddr_un_mt = {
  __index = function(un, k) {
    var sa = un.addr;
    if( k == 'family' ) { return sa.family; }
    var namelen = un.addrlen - s.sun_family;
    if( namelen > 0 ) {
      if( sa.sun_path[0] == 0 ) {
        if( k == 'abstract' ) { return true; }
        if( k == 'name' ) { return ffi.string(sa.sun_path, namelen); } // should we also remove leading \0?
      } else {
        if( k == 'name' ) { return ffi.string(sa.sun_path); }
      }
    } else {
      if( k == 'unnamed' ) { return true; }
    }
  },
  __len = function(un) { return un.addrlen; },
};

function t.sa(addr, addrlen) {
  var family = addr.family;
  if( family == c.AF.UNIX ) { // we return Lua metatable not metatype, as need length to decode
    var sa = t.sockaddr_un();
    ffi.copy(sa, addr, addrlen);
    return setmetatable({addr = sa, addrlen = addrlen}, lua_sockaddr_un_mt);
  }
  return addr;
}

var nlgroupmap = { // map from netlink socket type to group names. Note there are two forms of name though, bits and shifts.
  [c.NETLINK.ROUTE] = c.RTMGRP, // or RTNLGRP_ and shift not mask TODO make shiftflags function
  // add rest of these
//  [c.NETLINK.SELINUX] = c.SELNLGRP,
};

mt.sockaddr_nl = {
  index = {
    family = function(sa) { return sa.nl_family; },
    pid = function(sa) { return sa.nl_pid; },
    groups = function(sa) { return sa.nl_groups; },
  },
  newindex = {
    pid = function(sa, v) { sa.nl_pid = v; },
    groups = function(sa, v) { sa.nl_groups = v; },
  },
  __new = function(tp, pid, groups, nltype) {
    if( type(pid) == "table" ) {
      var tb = pid;
      pid, groups, nltype = tb.nl_pid || tb.pid, tb.nl_groups || tb.groups, tb.type;
    }
    if( nltype && nlgroupmap[nltype] ) { groups = nlgroupmap[nltype][groups]; } // see note about shiftflags
    return ffi.new(tp, {nl_family = c.AF.NETLINK, nl_pid = pid, nl_groups = groups});
  },
  __len = function(tp) { return s.sockaddr_nl; },
};

addtype(types, "sockaddr_nl", "struct sockaddr_nl", mt.sockaddr_nl);

mt.sockaddr_ll = {
  index = {
    family = function(sa) { return sa.sll_family; },
    protocol = function(sa) { return ntohs(sa.sll_protocol); },
    ifindex = function(sa) { return sa.sll_ifindex; },
    hatype = function(sa) { return sa.sll_hatype; },
    pkttype = function(sa) { return sa.sll_pkttype; },
    halen = function(sa) { return sa.sll_halen; },
    addr = function(sa) {
      if( sa.sll_halen == 6 ) { return pt.macaddr(sa.sll_addr); } else { return ffi.string(sa.sll_addr, sa.sll_halen); }
    },
  },
  newindex = {
    protocol = function(sa, v) { sa.sll_protocol = htons(c.ETH_P[v]); },
    ifindex = function(sa, v) { sa.sll_ifindex = v; },
    hatype = function(sa, v) { sa.sll_hatype = v; },
    pkttype = function(sa, v) { sa.sll_pkttype = v; },
    halen = function(sa, v) { sa.sll_halen = v; },
    addr = function(sa, v) {
      if( ffi.istype(t.macaddr, v) ) {
        sa.sll_halen = 6;
        ffi.copy(sa.sll_addr, v, 6);
      } else { sa.sll_addr = v; }
    },
  },
  __new = function(tp, tb) {
    var sa = ffi.new(tp, {sll_family = c.AF.PACKET});
    for( k, v in pairs(tb || {}) ) { sa[k] = v; }
    return sa;
  },
  __len = function(tp) { return s.sockaddr_ll; },
};

addtype(types, "sockaddr_ll", "struct sockaddr_ll", mt.sockaddr_ll);

mt.stat = {
  index = {
    dev = function(st) { return t.device(st.st_dev); },
    ino = function(st) { return tonumber(st.st_ino); },
    mode = function(st) { return st.st_mode; },
    nlink = function(st) { return tonumber(st.st_nlink); },
    uid = function(st) { return st.st_uid; },
    gid = function(st) { return st.st_gid; },
    size = function(st) { return tonumber(st.st_size); },
    blksize = function(st) { return tonumber(st.st_blksize); },
    blocks = function(st) { return tonumber(st.st_blocks); },
    atime = function(st) { return tonumber(st.st_atime); },
    ctime = function(st) { return tonumber(st.st_ctime); },
    mtime = function(st) { return tonumber(st.st_mtime); },
    rdev = function(st) { return t.device(st.st_rdev); },

    type = function(st) { return bit.band(st.st_mode, c.S_I.FMT); },
    todt = function(st) { return bit.rshift(st.type, 12); },
    isreg = function(st) { return st.type == c.S_I.FREG; },
    isdir = function(st) { return st.type == c.S_I.FDIR; },
    ischr = function(st) { return st.type == c.S_I.FCHR; },
    isblk = function(st) { return st.type == c.S_I.FBLK; },
    isfifo = function(st) { return st.type == c.S_I.FIFO; },
    islnk = function(st) { return st.type == c.S_I.FLNK; },
    issock = function(st) { return st.type == c.S_I.FSOCK; },
  },
};

// add some friendlier names to stat, also for luafilesystem compatibility
mt.stat.index.access = mt.stat.index.atime;
mt.stat.index.modification = mt.stat.index.mtime;
mt.stat.index.change = mt.stat.index.ctime;

var namemap = {
  file             = mt.stat.index.isreg,
  directory        = mt.stat.index.isdir,
  link             = mt.stat.index.islnk,
  socket           = mt.stat.index.issock,
  ["char device"]  = mt.stat.index.ischr,
  ["block device"] = mt.stat.index.isblk,
  ["named pipe"]   = mt.stat.index.isfifo,
};

mt.stat.index.typename = function(st) {
  for( k, v in pairs(namemap) ) { if( v(st) ) { return k; } }
  return "other";
};

addtype(types, "stat", "struct stat", mt.stat);

var signames = {};
var duplicates = {IOT = true, CLD = true, POLL = true};
for( k, v in pairs(c.SIG) ) {
  if( ! duplicates[k] ) { signames[v] = k; }
}

// TODO this is broken, need to use fields from the correct union technically
// ie check which of the unions we should be using and get all fields from that
// (note as per Musl list the standard kernel,glibc definitions are wrong too...)
mt.siginfo = {
  index = {
    signo   = function(s) { return s.si_signo; },
    errno   = function(s) { return s.si_errno; },
    code    = function(s) { return s.si_code; },
    pid     = function(s) { return s._sifields.kill.si_pid; },
    uid     = function(s) { return s._sifields.kill.si_uid; },
    timerid = function(s) { return s._sifields.timer.si_tid; },
    overrun = function(s) { return s._sifields.timer.si_overrun; },
    status  = function(s) { return s._sifields.sigchld.si_status; },
    utime   = function(s) { return s._sifields.sigchld.si_utime; },
    stime   = function(s) { return s._sifields.sigchld.si_stime; },
    value   = function(s) { return s._sifields.rt.si_sigval; },
    int     = function(s) { return s._sifields.rt.si_sigval.sival_int; },
    ptr     = function(s) { return s._sifields.rt.si_sigval.sival_ptr; },
    addr    = function(s) { return s._sifields.sigfault.si_addr; },
    band    = function(s) { return s._sifields.sigpoll.si_band; },
    fd      = function(s) { return s._sifields.sigpoll.si_fd; },
    signame = function(s) { return signames[s.signo]; },
  },
  newindex = {
    signo   = function(s, v) { s.si_signo = v; },
    errno   = function(s, v) { s.si_errno = v; },
    code    = function(s, v) { s.si_code = v; },
    pid     = function(s, v) { s._sifields.kill.si_pid = v; },
    uid     = function(s, v) { s._sifields.kill.si_uid = v; },
    timerid = function(s, v) { s._sifields.timer.si_tid = v; },
    overrun = function(s, v) { s._sifields.timer.si_overrun = v; },
    status  = function(s, v) { s._sifields.sigchld.si_status = v; },
    utime   = function(s, v) { s._sifields.sigchld.si_utime = v; },
    stime   = function(s, v) { s._sifields.sigchld.si_stime = v; },
    value   = function(s, v) { s._sifields.rt.si_sigval = v; },
    int     = function(s, v) { s._sifields.rt.si_sigval.sival_int = v; },
    ptr     = function(s, v) { s._sifields.rt.si_sigval.sival_ptr = v; },
    addr    = function(s, v) { s._sifields.sigfault.si_addr = v; },
    band    = function(s, v) { s._sifields.sigpoll.si_band = v; },
    fd      = function(s, v) { s._sifields.sigpoll.si_fd = v; },
  },
};

addtype(types, "siginfo", "struct siginfo", mt.siginfo);

// Linux internally uses non standard sigaction type k_sigaction
var sa_handler_type = ffi.typeof("void (*)(int)");
var to_handler = function(v) { return ffi.cast(sa_handler_type, t.uintptr(v)); }; // luaffi needs uintptr, and full cast
mt.sigaction = {
  index = {
    handler = function(sa) { return sa.sa_handler; },
    sigaction = function(sa) { return sa.sa_handler; },
    mask = function(sa) { return sa.sa_mask; }, // TODO would rather return type of sigset_t
    flags = function(sa) { return tonumber(sa.sa_flags); },
  },
  newindex = {
    handler = function(sa, v) {
      if( type(v) == "string" ) { v = to_handler(c.SIGACT[v]); }
      if( type(v) == "number" ) { v = to_handler(v); }
      sa.sa_handler = v;
    },
    sigaction = function(sa, v) {
      if( type(v) == "string" ) { v = to_handler(c.SIGACT[v]); }
      if( type(v) == "number" ) { v = to_handler(v); }
      sa.sa_handler.sa_sigaction = v;
    },
    mask = function(sa, v) {
      if( ! ffi.istype(t.sigset, v) ) { v = t.sigset(v); }
      ffi.copy(sa.sa_mask, v, ffi.sizeof(sa.sa_mask));
    },
    flags = function(sa, v) { sa.sa_flags = c.SA[v]; },
  },
  __new = function(tp, tab) {
    var sa = ffi.new(tp);
    if( tab ) { for( k, v in pairs(tab) ) { sa[k] = v; } }
    if( tab && tab.sigaction ) { sa.sa_flags = bit.bor(sa.flags, c.SA.SIGINFO); } // this flag must be set if sigaction set
    return sa;
  },
};

addtype(types, "sigaction", "struct k_sigaction", mt.sigaction);

mt.rlimit = {
  index = {
    cur = function(r) { if( r.rlim_cur == c.RLIM.INFINITY ) { return -1; } else { return tonumber(r.rlim_cur); } },
    max = function(r) { if( r.rlim_max == c.RLIM.INFINITY ) { return -1; } else { return tonumber(r.rlim_max); } },
  },
  newindex = {
    cur = function(r, v) {
      if( v == -1 ) { v = c.RLIM.INFINITY; }
      r.rlim_cur = c.RLIM[v]; // allows use of "infinity"
    },
    max = function(r, v) {
      if( v == -1 ) { v = c.RLIM.INFINITY; }
      r.rlim_max = c.RLIM[v]; // allows use of "infinity"
    },
  },
  __new = newfn,
};

// TODO some fields still missing
mt.sigevent = {
  index = {
    notify = function(this) { return this.sigev_notify; },
    signo = function(this) { return this.sigev_signo; },
    value = function(this) { return this.sigev_value; },
  },
  newindex = {
    notify = function(this, v) { this.sigev_notify = c.SIGEV[v]; },
    signo = function(this, v) { this.sigev_signo = c.SIG[v]; },
    value = function(this, v) { this.sigev_value = t.sigval(v); }, // auto assigns based on type
  },
  __new = newfn,
};

addtype(types, "sigevent", "struct sigevent", mt.sigevent);

addtype(types, "rlimit", "struct rlimit64", mt.rlimit);

mt.signalfd = {
  index = {
    signo = function(ss) { return tonumber(ss.ssi_signo); },
    code = function(ss) { return tonumber(ss.ssi_code); },
    pid = function(ss) { return tonumber(ss.ssi_pid); },
    uid = function(ss) { return tonumber(ss.ssi_uid); },
    fd = function(ss) { return tonumber(ss.ssi_fd); },
    tid = function(ss) { return tonumber(ss.ssi_tid); },
    band = function(ss) { return tonumber(ss.ssi_band); },
    overrun = function(ss) { return tonumber(ss.ssi_overrun); },
    trapno = function(ss) { return tonumber(ss.ssi_trapno); },
    status = function(ss) { return tonumber(ss.ssi_status); },
    int = function(ss) { return tonumber(ss.ssi_int); },
    ptr = function(ss) { return ss.ssi_ptr; },
    utime = function(ss) { return tonumber(ss.ssi_utime); },
    stime = function(ss) { return tonumber(ss.ssi_stime); },
    addr = function(ss) { return ss.ssi_addr; },
  },
  __index = function(ss, k) { // TODO simplify this
    var sig = c.SIG[k];
    if( sig ) { return tonumber(ss.ssi_signo) == sig; }
    var rname = signal_reasons_gen[ss.ssi_code];
    if( ! rname && signal_reasons[ss.ssi_signo] ) { rname = signal_reasons[ss.ssi_signo][ss.ssi_code]; }
    if( rname == k ) { return true; }
    if( rname == k->upper() ) { return true; } // TODO use some metatable to hide this?
    if( mt.signalfd.index[k] ) { return mt.signalfd.index[k](ss); }
    error("invalid index " .. k);
  },
};

addtype(types, "signalfd_siginfo", "struct signalfd_siginfo", mt.signalfd);

mt.siginfos = {
  __index = function(ss, k) {
    return ss.sfd[k - 1];
  },
  __len = function(p) { return p.count; },
  __new = function(tp, ss) {
    return ffi.new(tp, ss, ss, ss * s.signalfd_siginfo);
  },
};

addtype_var(types, "siginfos", "struct {int count, bytes; struct signalfd_siginfo sfd[?];}", mt.siginfos);

// TODO convert to use constants? note missing some macros eg WCOREDUMP(). Allow lower case. Also do not create table dynamically.
mt.wait = {
  __index = function(w, k) {
    var WTERMSIG = bit.band(w.status, 0x7f);
    var EXITSTATUS = bit.rshift(bit.band(w.status, 0xff00), 8);
    var WIFEXITED = (WTERMSIG == 0);
    var tab = {
      WIFEXITED = WIFEXITED,
      WIFSTOPPED = bit.band(w.status, 0xff) == 0x7f,
      WIFSIGNALED = ! WIFEXITED && bit.band(w.status, 0x7f) != 0x7f // I think this is right????? TODO recheck, cleanup
    };
    if( tab.WIFEXITED ) { tab.EXITSTATUS = EXITSTATUS; }
    if( tab.WIFSTOPPED ) { tab.WSTOPSIG = EXITSTATUS; }
    if( tab.WIFSIGNALED ) { tab.WTERMSIG = WTERMSIG; }
    if( tab[k] ) { return tab[k]; }
    var uc = 'W' .. k->upper();
    if( tab[uc] ) { return tab[uc]; }
  }
};

// cannot use metatype as just an integer
function t.waitstatus(status) {
  return setmetatable({status = status}, mt.wait);
}

// termios

var bits_to_speed = {};
for( k, v in pairs(c.B) ) {
  bits_to_speed[v] = tonumber(k);
}

mt.termios = {
  makeraw = function(termios) {
    termios.c_iflag = bit.band(termios.c_iflag, bit.bnot(c.IFLAG["IGNBRK,BRKINT,PARMRK,ISTRIP,INLCR,IGNCR,ICRNL,IXON"]));
    termios.c_oflag = bit.band(termios.c_oflag, bit.bnot(c.OFLAG["OPOST"]));
    termios.c_lflag = bit.band(termios.c_lflag, bit.bnot(c.LFLAG["ECHO,ECHONL,ICANON,ISIG,IEXTEN"]));
    termios.c_cflag = bit.bor(bit.band(termios.c_cflag, bit.bnot(c.CFLAG["CSIZE,PARENB"])), c.CFLAG.CS8);
    termios.c_cc[c.CC.VMIN] = 1;
    termios.c_cc[c.CC.VTIME] = 0;
    return true;
  },
  index = {
    iflag = function(termios) { return termios.c_iflag; },
    oflag = function(termios) { return termios.c_oflag; },
    cflag = function(termios) { return termios.c_cflag; },
    lflag = function(termios) { return termios.c_lflag; },
    makeraw = function(termios) { return mt.termios.makeraw; },
    speed = function(termios) {
      var bits = bit.band(termios.c_cflag, c.CBAUD);
      return bits_to_speed[bits];
    },
  },
  newindex = {
    iflag = function(termios, v) { termios.c_iflag = c.IFLAG(v); },
    oflag = function(termios, v) { termios.c_oflag = c.OFLAG(v); },
    cflag = function(termios, v) { termios.c_cflag = c.CFLAG(v); },
    lflag = function(termios, v) { termios.c_lflag = c.LFLAG(v); },
    speed = function(termios, speed) {
      speed = c.B[speed];
      termios.c_cflag = bit.bor(bit.band(termios.c_cflag, bit.bnot(c.CBAUD)), speed);
    },
  },
};

mt.termios.index.ospeed = mt.termios.index.speed;
mt.termios.index.ispeed = mt.termios.index.speed;
mt.termios.newindex.ospeed = mt.termios.newindex.speed;
mt.termios.newindex.ispeed = mt.termios.newindex.speed;

for( k, i in pairs(c.CC) ) {
  mt.termios.index[k] = function(termios) { return termios.c_cc[i]; };
  mt.termios.newindex[k] = function(termios, v) { termios.c_cc[i] = v; };
}

addtype(types, "termios", "struct termios", mt.termios);
addtype(types, "termios2", "struct termios2", mt.termios);

mt.iocb = {
  index = {
    opcode = function(iocb) { return iocb.aio_lio_opcode; },
    data = function(iocb) { return tonumber(iocb.aio_data); },
    reqprio = function(iocb) { return iocb.aio_reqprio; },
    fildes = function(iocb) { return iocb.aio_fildes; }, // do not convert to fd as will already be open, don't want to gc
    buf = function(iocb) { return iocb.aio_buf; },
    nbytes = function(iocb) { return tonumber(iocb.aio_nbytes); },
    offset = function(iocb) { return tonumber(iocb.aio_offset); },
    resfd = function(iocb) { return iocb.aio_resfd; },
    flags = function(iocb) { return iocb.aio_flags; },
  },
  newindex = {
    opcode = function(iocb, v) { iocb.aio_lio_opcode = c.IOCB_CMD[v]; },
    data = function(iocb, v) { iocb.aio_data = v; },
    reqprio = function(iocb, v) { iocb.aio_reqprio = v; },
    fildes = function(iocb, v) { iocb.aio_fildes = getfd(v); },
    buf = function(iocb, v) { iocb.aio_buf = ffi.cast(t.int64, pt.void(v)); },
    nbytes = function(iocb, v) { iocb.aio_nbytes = v; },
    offset = function(iocb, v) { iocb.aio_offset = v; },
    flags = function(iocb, v) { iocb.aio_flags = c.IOCB_FLAG[v]; },
    resfd = function(iocb, v) {
      iocb.aio_flags = bit.bor(iocb.aio_flags, c.IOCB_FLAG.RESFD);
      iocb.aio_resfd = getfd(v);
    },
  },
  __new = newfn,
};

addtype(types, "iocb", "struct iocb", mt.iocb);

// aio operations want an array of pointers to struct iocb. To make sure no gc, we provide a table with array and pointers
// easiest to do as Lua table not ffi type. 
// expects Lua table of either tables or iocb as input. can provide ptr table too
// TODO check maybe the implementation actually copies these? only the posix aio says you need to keep.

t.iocb_array = function(tab, ptrs) {
  var nr = #tab;
  var a = {nr = nr, iocbs = {}, ptrs = ptrs || t.iocb_ptrs(nr)};
  for( i = 1, nr ) {
    var iocb = tab[i];
    a.iocbs[i] = istype(t.iocb, iocb) || t.iocb(iocb);
    a.ptrs[i - 1] = a.iocbs[i];
  }
  return a;
};

mt.sock_filter = {
  __new = function(tp, code, k, jt, jf) {
    return ffi.new(tp, c.BPF[code], jt || 0, jf || 0, k || 0);
  }
};

addtype(types, "sock_filter", "struct sock_filter", mt.sock_filter);

// capabilities data is an array so cannot put metatable on it. Also depends on version, so combine into one structure.

// TODO maybe add caching
var function capflags(val, str) {
  if( ! str ) { return val; }
  if( #str == 0 ) { return val; }
  var a = h.split(",", str);
  for( i, v in ipairs(a) ) {
    var s = h.trim(v)->upper();
    if( ! c.CAP[s] ) { error("invalid capability " .. s); }
    val[s] = true;
  }
  return val;
}

mt.cap = {
  __index = function(cap, k) {
    var ci = c.CAP[k];
    if( ! ci ) { error("invalid capability " .. k); }
    var i, shift = h.divmod(ci, 32);
    var mask = bit.lshift(1, shift);
    return bit.band(cap.cap[i], mask) != 0;
  },
  __newindex = function(cap, k, v) {
    if( v == true ) { v = 1; } else if( v == false ) { v = 0; }
    var ci = c.CAP[k];
    if( ! ci ) { error("invalid capability " .. k); }
    var i, shift = h.divmod(ci, 32);
    var mask = bit.bnot(bit.lshift(1, shift));
    var set = bit.lshift(v, shift);
    cap.cap[i] = bit.bor(bit.band(cap.cap[i], mask), set);
  },
  __tostring = function(cap) {
    var tab = {};
    for( k, _ in pairs(c.CAP) ) {
      if( cap[k] ) { tab[#tab + 1] = k; }
    }
    return table.concat(tab, ",");
  },
  __new = function(tp, str) {
    var cap = ffi.new(tp);
    if( str ) { capflags(cap, str); }
    return cap;
  },
};

addtype(types, "cap", "struct cap", mt.cap);

mt.capabilities = {
    hdrdata = function(cap) {
      var hdr, data = t.user_cap_header(cap.version, cap.pid), t.user_cap_data2();
      data[0].effective, data[1].effective = cap.effective.cap[0], cap.effective.cap[1];
      data[0].permitted, data[1].permitted = cap.permitted.cap[0], cap.permitted.cap[1];
      data[0].inheritable, data[1].inheritable = cap.inheritable.cap[0], cap.inheritable.cap[1];
      return hdr, data;
    },
    index = {
      hdrdata = function(cap) { return mt.capabilities.hdrdata; },
    },
  __new = function(tp, hdr, data) {
    var cap = ffi.new(tp, c.LINUX_CAPABILITY_VERSION[3], 0);
    if( type(hdr) == "table" ) {
      if( hdr.permitted ) { cap.permitted = t.cap(hdr.permitted); }
      if( hdr.effective ) { cap.effective = t.cap(hdr.effective); }
      if( hdr.inheritable ) { cap.inheritable = t.cap(hdr.inheritable); }
      cap.pid = hdr.pid || 0;
      if( hdr.version ) { cap.version = c.LINUX_CAPABILITY_VERSION[hdr.version]; }
      return cap;
    }
    // not passed a table
    if( hdr ) { cap.version, cap.pid = hdr.version, hdr.pid; }
    if( data ) {
      cap.effective.cap[0], cap.effective.cap[1] = data[0].effective, data[1].effective;
      cap.permitted.cap[0], cap.permitted.cap[1] = data[0].permitted, data[1].permitted;
      cap.inheritable.cap[0], cap.inheritable.cap[1] = data[0].inheritable, data[1].inheritable;
    }
    return cap;
  },
  __tostring = function(cap) {
    var str = "";
    for( nm, capt in pairs({permitted = cap.permitted, inheritable = cap.inheritable, effective = cap.effective}) ) {
      str = str .. nm .. ": ";
      str = str .. tostring(capt) .. "\n";
    }
    return str;
  },
};

addtype(types, "capabilities", "struct capabilities", mt.capabilities);

// difficult to sanely use an ffi metatype for inotify events, so use Lua table
mt.inotify_events = {
  __index = function(tab, k) {
    if( c.IN[k] ) { return bit.band(tab.mask, c.IN[k]) != 0; }
    error("invalid index " .. k);
  }
};

t.inotify_events = function(buffer, len) {
  var off, ee = 0, {};
  while( off < len ) {
    var ev = pt.inotify_event(buffer + off);
    var le = setmetatable({wd = ev.wd, mask = ev.mask, cookie = ev.cookie}, mt.inotify_events);
    if( ev.len > 0 ) { le.name = ffi.string(ev.name); }
    ee[#ee + 1] = le;
    off = off + ffi.sizeof(t.inotify_event(ev.len));
  }
  return ee;
};

// TODO for input should be able to set modes automatically from which fields are set.
mt.timex = {
  __new = function(tp, a) {
    if( type(a) == 'table' ) {
      if( a.modes ) { a.modes = c.ADJ[a.modes]; }
      if( a.status ) { a.status = c.STA[a.status]; }
      return ffi.new(tp, a);
    }
    return ffi.new(tp);
  },
};

addtype(types, "timex", "struct timex", mt.timex);

// not sane to convert to ffi metatype, only used as adjtimex needs to return ret and a struct
mt.adjtimex = {
  __index = function(timex, k) {
    if( c.TIME[k] ) { return timex.state == c.TIME[k]; }
    return null;
  }
};

t.adjtimex = function(ret, timex) {
  return setmetatable({state = ret, timex = timex}, mt.adjtimex);
};

mt.epoll_event = {
  index = {
    fd = function(e) { return tonumber(e.data.fd); },
    u64 = function(e) { return e.data.u64; },
    u32 = function(e) { return e.data.u32; },
    ptr = function(e) { return e.data.ptr; },
  },
  newindex = {
    fd = function(e, v) { e.data.fd = v; },
    u64 = function(e, v) { e.data.u64 = v; },
    u32 = function(e, v) { e.data.u32 = v; },
    ptr = function(e, v) { e.data.ptr = v; },
  },
  __new = function(tp, a) {
    var e = ffi.new(tp);
    if( a ) {
      if( type(a) == "string" ) { a.events = c.EPOLL[a];
      } else { 
        if( a.events ) { a.events = c.EPOLL[a.events]; }
        for( k, v in pairs(a) ) { e[k] = v; }
      }
    }
    return e;
  },
};

for( k, v in pairs(c.EPOLL) ) {
  mt.epoll_event.index[k] = function(e) { return bit.band(e.events, v) != 0; };
}

addtype(types, "epoll_event", "struct epoll_event", mt.epoll_event);

mt.epoll_events = {
  __len = function(ep) { return ep.count; },
  __new = function(tp, n) { return ffi.new(tp, n, n); },
  __ipairs = function(ep) { return reviter, ep.ep, ep.count; }
};

addtype_var(types, "epoll_events", "struct {int count; struct epoll_event ep[?];}", mt.epoll_events);

mt.io_event = {
  index = {
    error = function(ev) { if( (ev.res < 0) ) { return t.error(-ev.res); } },
  }
};

addtype(types, "io_event", "struct io_event", mt.io_event);

mt.io_events = {
  __len = function(evs) { return evs.count; },
  __new = function(tp, n) { return ffi.new(tp, n, n); },
  __ipairs = function(evs) { return reviter, evs.ev, evs.count; }
};

addtype_var(types, "io_events", "struct {int count; struct io_event ev[?];}", mt.io_events);

mt.cpu_set = {
  index = {
    zero = function(set) { ffi.fill(set, s.cpu_set); },
    set = function(set, cpu) {
      if( type(cpu) == "table" ) { // table is an array of CPU numbers eg {1, 2, 4}
        for( i = 1, #cpu ) { set->set(cpu[i]); }
        return set;
      }
      var d = bit.rshift(cpu, 5); // 5 is 32 bits
      set.val[d] = bit.bor(set.val[d], bit.lshift(1, cpu % 32));
      return set;
    },
    clear = function(set, cpu) {
      if( type(cpu) == "table" ) { // table is an array of CPU numbers eg {1, 2, 4}
        for( i = 1, #cpu ) { set->clear(cpu[i]); }
        return set;
      }
      var d = bit.rshift(cpu, 5); // 5 is 32 bits
      set.val[d] = bit.band(set.val[d], bit.bnot(bit.lshift(1, cpu % 32)));
      return set;
    },
    get = function(set, cpu) {
      var d = bit.rshift(cpu, 5); // 5 is 32 bits
      return bit.band(set.val[d], bit.lshift(1, cpu % 32)) != 0;
    },
    // TODO add rest of interface from man(3) CPU_SET
  },
  __index = function(set, k) {
    if( mt.cpu_set.index[k] ) { return mt.cpu_set.index[k]; }
    if( type(k) == "number" ) { return set->get(k); }
    error("invalid index " .. k);
  },
  __newindex = function(set, k, v) {
    if( type(k) != "number" ) { error("invalid index " .. k); }
    if( v ) { set->set(k); } else { set->clear(k); }
  },
  __new = function(tp, tab) {
    var set = ffi.new(tp);
    if( tab ) { set->set(tab); }
    return set;
  },
  __tostring = function(set) {
    var tab = {};
    for( i = 0, s.cpu_set * 8 - 1 ) { if( set->get(i) ) { tab[#tab + 1] = i; } }
    return "{" .. table.concat(tab, ",") .. "}";
  },
};

addtype(types, "cpu_set", "struct cpu_set_t", mt.cpu_set);

var ulong_bit_count = ffi.sizeof('unsigned long') * 8;
var function ulong_index_and_bit(n) {
  var i = math.floor(n / ulong_bit_count);
  var b = bit.lshift(1ULL, n - i * ulong_bit_count);
  return i, b;
}

mt.bitmask = {
  index = {
    zero = function(mask) { ffi.fill(mask, s.bitmask); },
    set = function(mask, node) {
      if( type(node) == "table" ) { // table is an array of node numbers eg {1, 2, 4}
        for( i = 1, #node ) { mask->set(node[i]); }
        return mask;
      }
      if( node >= mask.size ) { error("numa node too large " .. node); }
      var i, b = ulong_index_and_bit(node);
      mask.mask[i] = bit.bor(mask.mask[i], b);
      return mask;
    },
    clear = function(mask, node) {
      if( type(node) == "table" ) { // table is an array of node numbers eg {1, 2, 4}
        for( i = 1, #node ) { mask->clear(node[i]); }
        return mask;
      }
      if( node < mask.size ) {
         var i, b = ulong_index_and_bit(node);
         mask.mask[i] = bit.band(mask.mask[i], bit.bnot(b));
      }
      return mask;
    },
    get = function(mask, node) {
      var i, b = ulong_index_and_bit(node);
      if( node >= mask.size ) { return false; }
      return bit.band(mask.mask[i], b) != 0;
    },
  },
  __index = function(mask, k) {
    if( mt.bitmask.index[k] ) { return mt.bitmask.index[k]; }
    if( type(k) == "number" ) { return mask->get(k); }
    error("invalid index " .. k);
  },
  __newindex = function(mask, k, v) {
    if( type(k) != "number" ) { error("invalid index " .. k); }
    if( v ) { mask->set(k); } else { mask->clear(k); }
  },
  __new = function(tp, tab, size) {
    // Round size to multiple of ulong bit count.
    if( size ) {
      size = bit.band(size + ulong_bit_count - 1, bit.bnot(ulong_bit_count - 1));
    } else {
      size = ulong_bit_count;
    }
    var mask = ffi.new(tp, size / ulong_bit_count, size);
    if( tab ) { mask->set(tab); }
    return mask;
  },
  __tostring = function(mask) {
    var tab = {};
    for( i = 0, tonumber(mask.size - 1) ) {
       if( mask->get(i) ) { tab[#tab + 1] = i; }
    }
    return "{" .. table.concat(tab, ",") .. "}";
  },
};

addtype_var(types, "bitmask", "struct {unsigned long size; unsigned long mask[?];}", mt.bitmask);

mt.mq_attr = {
  index = {
    flags = function(mqa) { return tonumber(mqa.mq_flags); },
    maxmsg = function(mqa) { return tonumber(mqa.mq_maxmsg); },
    msgsize = function(mqa) { return tonumber(mqa.mq_msgsize); },
    curmsgs = function(mqa) { return tonumber(mqa.mq_curmsgs); },
  },
  newindex = {
    flags = function(mqa, v) { mqa.mq_flags = c.OMQATTR[v]; }, // only allows O.NONBLOCK
    maxmsg = function(mqa, v) { mqa.mq_maxmsg = v; },
    msgsize = function(mqa, v) { mqa.mq_msgsize = v; },
    // no sense in writing curmsgs
  },
  __new = newfn,
};

addtype(types, "mq_attr", "struct mq_attr", mt.mq_attr);

mt.ifreq = {
  index = {
    name = function(ifr) { return ffi.string(ifr.ifr_ifrn.ifrn_name); },
    addr = function(ifr) { return ifr.ifr_ifru.ifru_addr; },
    dstaddr = function(ifr) { return ifr.ifr_ifru.ifru_dstaddr; },
    broadaddr = function(ifr) { return ifr.ifr_ifru.ifru_broadaddr; },
    netmask = function(ifr) { return ifr.ifr_ifru.ifru_netmask; },
    hwaddr = function(ifr) { return ifr.ifr_ifru.ifru_hwaddr; },
    flags = function(ifr) { return ifr.ifr_ifru.ifru_flags; },
    ivalue = function(ifr) { return ifr.ifr_ifru.ifru_ivalue; },
    // TODO rest of fields
  },
  newindex = {
    name = function(ifr, v) {
      assert(#v <= c.IFNAMSIZ, "name too long");
      ifr.ifr_ifrn.ifrn_name = v;
    },
    flags = function(ifr, v) { ifr.ifr_ifru.ifru_flags = c.IFREQ[v]; },
    ivalue = function(ifr, v) { ifr.ifr_ifru.ifru_ivalue = v; },
    // TODO rest of fields
  },
  __new = newfn,
};

addtype(types, "ifreq", "struct ifreq", mt.ifreq);

// note t.dirents iterator is defined in common types
var d_name_offset = ffi.offsetof("struct linux_dirent64", "d_name"); // d_name is at end of struct
mt.dirent = {
  index = {
    ino = function(this) { return tonumber(this.d_ino); },
    off = function(this) { return this.d_off; },
    reclen = function(this) { return this.d_reclen; },
    name = function(this) { return ffi.string(pt.char(this) + d_name_offset); },
    type = function(this) { return this.d_type; },
    toif = function(this) { return bit.lshift(this.d_type, 12); }, // convert to stat types
  },
  __len = function(this) { return this.d_reclen; },
};

// TODO previously this allowed lower case values, but this static version does not
// could add mt.dirent.index[tolower(k)] = mt.dirent.index[k] but need to do consistently elsewhere
for( k, v in pairs(c.DT) ) {
  mt.dirent.index[k] = function(this) { return this.type == v; };
}

addtype(types, "dirent", "struct linux_dirent64", mt.dirent);

mt.rtmsg = {
  index = {
    family = function(this) { return tonumber(this.rtm_family); },
  },
  newindex = {
    family = function(this, v) { this.rtm_family = c.AF[v]; },
    protocol = function(this, v) { this.rtm_protocol = c.RTPROT[v]; },
    type = function(this, v) { this.rtm_type = c.RTN[v]; },
    scope = function(this, v) { this.rtm_scope = c.RT_SCOPE[v]; },
    flags = function(this, v) { this.rtm_flags = c.RTM_F[v]; },
    table = function(this, v) { this.rtm_table = c.RT_TABLE[v]; },
    dst_len = function(this, v) { this.rtm_dst_len = v; },
    src_len = function(this, v) { this.rtm_src_len = v; },
    tos = function(this, v) { this.rtm_tos = v; },
  },
  __new = newfn,
};

addtype(types, "rtmsg", "struct rtmsg", mt.rtmsg);

mt.ndmsg = {
  index = {
    family = function(this) { return tonumber(this.ndm_family); },
  },
  newindex = {
    family = function(this, v) { this.ndm_family = c.AF[v]; },
    state = function(this, v) { this.ndm_state = c.NUD[v]; },
    flags = function(this, v) { this.ndm_flags = c.NTF[v]; },
    type = function(this, v) { this.ndm_type = v; }, // which lookup?
    ifindex = function(this, v) { this.ndm_ifindex = v; },
  },
  __new = newfn,
};

addtype(types, "ndmsg", "struct ndmsg", mt.ndmsg);

mt.sched_param = {
  __new = function(tp, v) { // allow positional parameters as only first is ever used
    var obj = ffi.new(tp);
    obj.sched_priority = v || 0;
    return obj;
  },
};

addtype(types, "sched_param", "struct sched_param", mt.sched_param);

mt.flock = {
  index = {
    type = function(this) { return this.l_type; },
    whence = function(this) { return this.l_whence; },
    start = function(this) { return this.l_start; },
    len = function(this) { return this.l_len; },
    pid = function(this) { return this.l_pid; },
  },
  newindex = {
    type = function(this, v) { this.l_type = c.FCNTL_LOCK[v]; },
    whence = function(this, v) { this.l_whence = c.SEEK[v]; },
    start = function(this, v) { this.l_start = v; },
    len = function(this, v) { this.l_len = v; },
    pid = function(this, v) { this.l_pid = v; },
  },
  __new = newfn,
};

addtype(types, "flock", "struct flock64", mt.flock);

mt.mmsghdr = {
  index = {
    hdr = function(this) { return this.msg_hdr; },
    len = function(this) { return this.msg_len; },
  },
  newindex = {
    hdr = function(this, v) { this.hdr = v; },
  },
  __new = newfn,
};

addtype(types, "mmsghdr", "struct mmsghdr", mt.mmsghdr);

mt.mmsghdrs = {
  __len = function(p) { return p.count; },
  __new = function(tp, ps) {
    if( type(ps) == 'number' ) { return ffi.new(tp, ps, ps); }
    var count = #ps;
    var mms = ffi.new(tp, count, count);
    for( n = 1, count ) {
      mms.msg[n - 1].msg_hdr = mktype(t.msghdr, ps[n]);
    }
    return mms;
  },
  __ipairs = function(p) { return reviter, p.msg, p.count; } // TODO want forward iterator really...
};

addtype_var(types, "mmsghdrs", "struct {int count; struct mmsghdr msg[?];}", mt.mmsghdrs);

// this is declared above
samap_pt = {
  [c.AF.UNIX] = pt.sockaddr_un,
  [c.AF.INET] = pt.sockaddr_in,
  [c.AF.INET6] = pt.sockaddr_in6,
  [c.AF.NETLINK] = pt.sockaddr_nl,
  [c.AF.PACKET] = pt.sockaddr_ll,
};

return types;

}

return {init = init};

