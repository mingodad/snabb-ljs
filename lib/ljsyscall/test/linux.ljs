// Linux specific tests

var function init(S) {

var helpers = require ("syscall.helpers");
var abi = S.abi;
var types = S.types;
var c = S.c;
var util = S.util;

var bit = require ("syscall.bit");
var ffi = require ("ffi");

var nr = require ("syscall.linux.nr");

var jit;
if( pcall(require, "jit") ) { jit = require ("jit"); }

var t, pt, s = types.t, types.pt, types.s;

var nl = S.nl;

var assert = helpers.assert;

var function fork_assert(cond, err, ...) { // if we have forked we need to fail in main thread not fork
  if( ! cond ) {
    print(tostring(err));
    print(debug.traceback());
    S.exit("failure");
  }
  if( cond == true ) { return ...; }
  return cond, ...;
}

var function assert_equal(...) {
  collectgarbage("collect"); // force gc, to test for bugs
  return assert_equals(...);
}

var teststring = "this is a test string";
var size = 512;
var buf = t.buffer(size);
var tmpfile = "XXXXYYYYZZZ4521" .. S.getpid();
var tmpfile2 = "./666666DDDDDFFFF" .. S.getpid();
var tmpfile3 = "MMMMMTTTTGGG" .. S.getpid();
var longfile = "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" .. S.getpid();
var efile = "./tmpexXXYYY" .. S.getpid() .. ".sh";
var largeval = math.pow(2, 33); // larger than 2^32 for testing
var mqname = "ljsyscallXXYYZZ" .. S.getpid();

var clean = function() {
  S.rmdir(tmpfile);
  S.unlink(tmpfile);
  S.unlink(tmpfile2);
  S.unlink(tmpfile3);
  S.unlink(longfile);
  S.unlink(efile);
};

var test = {};

// TODO some issues with NetBSD so moved back here until fixed
test.signals = {
  test_signal_ignore = function() {
    assert(S.signal("pipe", "ign"));
    assert(S.kill(S.getpid(), "pipe")); // should be ignored
    assert(S.signal("pipe", "dfl"));
  },
  test_sigaction_ignore = function() {
    assert(S.sigaction("pipe", "ign"));
    assert(S.kill(S.getpid(), "pipe")); // should be ignored
    assert(S.sigaction("pipe", "dfl"));
  },
  test_sigpipe = function() { // TODO BSDs have NOSIGPIPE flag that should do this too
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    assert(sv1->shutdown("rd"));
    assert(S.signal("pipe", "ign"));
    assert(sv2->close());
    var n, err = sv1->write("will get sigpipe");
    assert(err.PIPE, "should get sigpipe");
    assert(sv1->close());
  },
};

test.file_operations_linux = {
  teardown = clean,
  test_mknodat_fifo = function() { // this does not work on NetBSD, you need to use mkfifo
    var fd = assert(S.open("."));
    assert(fd->mknodat(tmpfile, "fifo,rwxu"));
    var stat = assert(S.stat(tmpfile));
    assert(stat.isfifo, "expect to be a fifo");
    assert(fd->close());
    assert(S.unlink(tmpfile));
  },
  test_fadvise_etc = function() { // could split
    var fd = assert(S.open(tmpfile, "creat, rdwr", "RWXU"));
    assert(S.unlink(tmpfile));
    assert(S.fadvise(fd, "random"));
    var ok, err = S.fallocate(fd, "keep_size", 1024, 4096);
    assert(ok || err.OPNOTSUPP || err.NOSYS, "expect fallocate to succeed if supported");
    ok, err = S.posix_fallocate(fd, 0, 8192);
    assert(ok || err.OPNOTSUPP || err.NOSYS, "expect posix_fallocate to succeed if supported");
    // disabled as will often give ENOSPC! TODO better test
    //local ok, err = S.fallocate(fd, "keep_size", largeval, largeval + 1) -- test 64 bit ops 8589934592, 8589934593
    //assert(ok or err.OPNOTSUPP or err.NOSYS, "expect fallocate to succeed if supported, got " .. tostring(err))
    assert(fd->close());
  },
  test_readahead = function() {
    var fd = assert(S.open(tmpfile, "creat, rdwr", "RWXU"));
    assert(S.unlink(tmpfile));
    var pagesize = S.getpagesize();
    // Travis fails these, sometimes, for no discernable reason, so removed asserts for now
    fd->readahead(0, pagesize);
    fd->readahead(largeval, pagesize);
    assert(fd->close());
  },
  test_sync_file_range = function() {
    var fd = assert(S.creat(tmpfile, "0666"));
    assert(S.unlink(tmpfile));
    var ok, err = fd->sync_file_range(0, 0, 0); // nop
    if( ! ok && err.NOSYS ) { error ("skipped"); }
    assert(ok, err);
    assert(fd->sync_file_range(0, 4096, 0)); // nop
    assert(fd->sync_file_range(0, 4096, "wait_before, write, wait_after"));
    assert(fd->sync_file_range(4096, 0, "wait_before, write, wait_after"));
    assert(fd->sync_file_range(1, 2, "wait_before, write, wait_after"));
    assert(fd->close());
  },
};

test.inotify = {
  teardown = clean,
  test_inotify = function() {
    assert(S.mkdir(tmpfile, "RWXU")); // do in directory so ok to run in parallel
    var fd = assert(S.inotify_init("cloexec, nonblock"));
    var wd = assert(fd->inotify_add_watch(tmpfile, "create, delete"));
    assert(S.chdir(tmpfile));
    var n, err = fd->inotify_read();
    assert(err.again, "no inotify events yet");
    assert(util.writefile(tmpfile, "test", "RWXU"));
    assert(S.unlink(tmpfile));
    n = assert(fd->inotify_read());
    assert_equal(#n, 2, "expect 2 events now");
    assert(n[1].create, "file created");
    assert_equal(n[1].name, tmpfile, "created file should have same name");
    assert(n[2].delete, "file deleted");
    assert_equal(n[2].name, tmpfile, "created file should have same name");
    assert(fd->inotify_rm_watch(wd));
    assert(fd->close());
    assert(S.chdir(".."));
    assert(S.rmdir(tmpfile));
  },
};

test.tee_splice = {
  teardown = clean,
  test_tee_splice = function() {
    var pr, pw = assert(S.pipe());
    var ppr, ppw = assert(S.pipe());
    var s1, s2 = assert(S.socketpair("unix", "stream, nonblock"));
    var fd = assert(S.open(tmpfile, "rdwr, creat", "RWXU"));
    assert(S.unlink(tmpfile));
    var str = teststring;
    var n = assert(fd->write(str));
    assert_equal(n, #str);
    var err;
    n, err = S.splice(fd, 0, pw, null, #str, "nonblock"); // splice file at offset 0 into pipe
    if( ! n && err.NOSYS ) { error ("skipped"); }
    assert(n == #str);
    n, err = S.tee(pr, ppw, #str, "nonblock"); // clone our pipe
    if( ! n && err.NOSYS ) { error ("skipped"); }
    assert(n);
    assert_equal(n, #str);
    n = assert(S.splice(pr, null, s1, null, #str, "nonblock")); // splice to socket
    assert(n == #str);
    n = assert(s2->read());
    assert(#n == #str);
    n = assert(S.splice(ppr, null, s1, null, #str, "nonblock")); // splice the tee'd pipe into our socket
    assert_equal(n, #str);
    n = assert(s2->read());
    assert(#n == #str);
    var buf2 = t.buffer(#str);
    ffi.copy(buf2, str, #str);
    n = assert(S.vmsplice(pw, {{buf2, #str}}, "nonblock")); // write our memory into pipe
    assert_equal(n, #str);
    n = assert(S.splice(pr, null, s1, null, #str, "nonblock")); // splice out to socket
    assert_equal(n, #str);
    n = assert(s2->read());
    assert(#n == #str);
    assert(fd->close());
    assert(pr->close());
    assert(pw->close());
    assert(ppr->close());
    assert(ppw->close());
    assert(s1->close());
    assert(s2->close());
  },
};

test.timers_linux = {
  test_timerfd = function() {
    var fd = assert(S.timerfd_create("monotonic", "nonblock, cloexec"));
    var n = assert(util.timerfd_read(fd));
    assert_equal(n, 0);
    assert(fd->block());
    var o = assert(fd->timerfd_settime(null, {0, 0.000001}));
    assert(o.interval.time == 0 && o.value.time == 0, "old timer values zero");
    n = assert(util.timerfd_read(fd));
    assert_equal(n, 1);
    o = assert(fd->timerfd_gettime());
    assert_equal(o.interval.time, 0, "expect 0 from gettime as expired");
    assert_equal(o.value.time, 0, "expect 0 from gettime as expired");
    assert(fd->close());
  },
  test_time = function() { // this interface is not a syscall for other OSs, probably won't make compat interface
    var tt = S.time();
  },
};

test.misc_linux = {
  test_sysinfo = function() {
    var i = assert(S.sysinfo()); // TODO test values returned for some sanity
  },
  test_syslog = function() {
    var syslog, err = S.syslog(10);
    if( ! syslog && err.PERM ) { return; } // Android gives EPERM here
    assert(syslog > 1, "syslog buffer should have positive size");
  },
  test_rlimit = function() {
    var r, err = S.getrlimit("nofile");
    if( err && err.NOSYS ) { error ("skipped"); }
    assert(! err, "expect no error, got " .. tostring(err));
    assert(S.setrlimit("nofile", {cur = 0, max = r.rlim_max}));
    var fd;
    fd, err = S.open("/dev/zero", "rdonly");
    assert(err.MFILE, "should be over rlimit");
    assert(S.setrlimit("nofile", r)); // reset
    fd = assert(S.open("/dev/zero", "rdonly"));
    assert(fd->close());
  },
  test_prlimit = function() {
    var r, err = S.prlimit(0, "nofile");
    if( err && err.NOSYS ) { error ("skipped"); }
    assert(! err, "expect no error");
    var r2 = assert(S.prlimit(0, "nofile", {cur = 512, max = r.max}));
    assert_equal(r2.cur, r.cur, "old value same");
    assert_equal(r2.max, r.max, "old value same");
    var r3 = assert(S.prlimit(0, "nofile"));
    assert_equal(r3.cur, 512, "new value 512");
    assert_equal(r3.max, r.max, "max unchanged");
    assert(S.prlimit(0, "nofile", r));
    var r4 = assert(S.prlimit(0, "nofile"));
    assert_equal(r4.cur, r.cur, "reset to original");
    assert_equal(r4.max, r.max, "reset to original");
  },
/* -- TODO fix this test not working, then breaks all others
  test_prlimit_root = function()
    local r = assert(S.prlimit(0, "nofile"))
    local r2 = assert(S.prlimit(0, "nofile", {cur = 512, max = 640}))
    assert_equal(r2.cur, r.cur, "old value same")
    assert_equal(r2.max, r.max, "old value same")
    local r3 = assert(S.prlimit(0, "nofile"))
    assert_equal(r3.cur, 512, "new value 512")
    assert_equal(r3.max, 640, "max unchanged")
    local ok, err = S.prlimit(0, "nofile", {"infinity", "infinity"})
    assert(not ok and err.PERM, "should not be allowed to unlimit completely")
    assert(S.prlimit(0, "nofile", r))
    local r4 = assert(S.prlimit(0, "nofile"))
    assert_equal(r4.cur, r.cur, "reset to original")
    assert_equal(r4.max, r.max, "reset to original")
  end,
*/
  test_adjtimex = function() {
    var tt = assert(S.adjtimex());
  },
  test_prctl = function() {
    var n;
    n = assert(S.prctl("capbset_read", "mknod"));
    assert(n == 0 || n == 1, "capability may or may not be set");
    var nn = assert(S.prctl("get_dumpable"));
    if( nn == 2 ) { nn = 1; } // can return 2 but you cannot set this
    assert(S.prctl("set_dumpable", 0));
    n = assert(S.prctl("get_dumpable"));
    assert(n == 0, "process not dumpable after change");
    assert(S.prctl("set_dumpable", nn));
    n = assert(S.prctl("get_keepcaps"));
    assert(n == 0, "process keepcaps defaults to 0");
    n = assert(S.prctl("get_pdeathsig"));
    assert(n == 0, "process pdeathsig defaults to 0");
    assert(S.prctl("set_pdeathsig", "winch"));
    n = assert(S.prctl("get_pdeathsig"));
    assert(n == c.SIG.WINCH, "process pdeathsig should now be set to winch");
    assert(S.prctl("set_pdeathsig")); // reset
    n = assert(S.prctl("get_name"));
    assert(S.prctl("set_name", "test"));
    n = assert(S.prctl("get_name"));
    assert(n == "test", "name should be as set");
    // failing in travis CI now, as file does not exist
    //n = assert(util.readfile("/proc/self/comm"))
    //assert(n == "test\n", "comm should be as set")
  },
  test_uname = function() {
    var u = assert(S.uname());
    assert_string(u.nodename);
    assert_string(u.sysname);
    assert_string(u.release);
    assert_string(u.version);
    assert_string(u.machine);
    assert_string(u.domainname);
  },
  test_gethostname = function() {
    var h = assert(S.gethostname());
    var u = assert(S.uname());
    assert_equal(h, u.nodename, "gethostname did not return nodename");
  },
  test_getdomainname = function() {
    var d = assert(S.getdomainname());
    var u = assert(S.uname());
    assert_equal(d, u.domainname, "getdomainname did not return domainname");
  },
  test_sethostname_root = function() {
    assert(S.sethostname("hostnametest"));
    assert_equal(S.gethostname(), "hostnametest");
  },
  test_setdomainname_root = function() {
    assert(S.setdomainname("domainnametest"));
    assert_equal(S.getdomainname(), "domainnametest");
  },
  test_sendcred = function() {
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    assert(sv2->setsockopt("socket", "passcred", true)); // enable receive creds
    assert(sv1->setsockopt("socket", "passcred", true)); // enable receive creds
    var so = assert(sv2->getsockopt("socket", "passcred"));
    assert(so == 1, "getsockopt should have updated value");
    assert(util.sendcred(sv2));
    var r, err = assert(util.recvcmsg(sv1));
    assert_equal(r.pid, S.getpid());
    assert(sv1->close());
    assert(sv2->close());
  },
  test_getrandom = function() {
    if( ! S.getrandom ) { error ("skipped"); }
    var buf = t.buffer(64);
    var count, err = S.getrandom(buf, 64, "nonblock");
    if( ! count ) { if( err.NOSYS || err.AGAIN ) { error ("skipped"); } }
    assert(count, err);
    assert_equal(count, 64);
  },
  test_memfd = function() {
    if( ! S.memfd_create ) { error ("skipped"); }
    var fd, err = S.memfd_create("", "cloexec");
    if( ! fd && err.NOSYS ) { error ("skipped"); }
    assert(fd, err);
    assert(fd->close());
  },
};

test.sendfile = {
  teardown = clean,
  test_sendfile = function() {
    var f1 = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    var f2 = assert(S.open(tmpfile2, "rdwr,creat", "rwxu"));
    assert(S.unlink(tmpfile));
    assert(S.unlink(tmpfile2));
    assert(f2->truncate(30));
    var n = assert(f1->sendfile(f2, null, 16));
    assert(n == 16, "sendfile should send 16 bytes, is " .. n);
    assert(f1->close());
    assert(f2->close());
  },
  test_sendfile_offset = function() {
    var f1 = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    var f2 = assert(S.open(tmpfile2, "rdwr,creat", "rwxu"));
    assert(S.unlink(tmpfile));
    assert(S.unlink(tmpfile2));
    assert(f2->truncate(32));
    var off = t.off1(8);
    var n = assert(f1->sendfile(f2, off, 16));
    assert(n == 16, "sendfile should send 16 bytes, is " .. n);
    var noff = tonumber(off[0]);
    assert(noff == 24, "sendfile offset should be 24, is " .. noff);
    assert(f1->close());
    assert(f2->close());
  },
  test_sendfile_largefile = function() {
    if( S.__rump ) { error ("skipped"); } // runs out of space
    var f1 = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    var f2 = assert(S.open(tmpfile2, "rdwr,creat", "rwxu"));
    assert(S.unlink(tmpfile));
    assert(S.unlink(tmpfile2));
    assert(f2->seek(largeval, "set"));
    assert(f2->write("00001111222233334444555566667777"));
    assert(f2->seek(0));
    var off = t.off1(largeval);
    var n = assert(f1->sendfile(f2, off, 16));
    assert(n == 16, "sendfile should send 16 bytes, is " .. n);
    var noff = tonumber(off[0]);
    assert(noff == largeval + 16, "sendfile offset should be " .. largeval + 16 .. ", is " .. noff);
    assert(f1->close());
    assert(f2->close());
  },
};

test.ppoll = {
  test_ppoll = function() {
    var a, b = assert(S.socketpair("unix", "stream"));
    var pev = t.pollfds({{fd = a, events = c.POLL.IN}});
    var p = assert(S.ppoll(pev, 0, null));
    assert_equal(p, 0); // no events yet
    for( k, v in ipairs(pev) ) {
      assert_equal(v.fd, a->getfd());
      assert_equal(v.revents, 0);
    }
    assert(b->write(teststring));
    p = assert(S.ppoll(pev, null, "alrm"));
    assert_equal(p, 1); // 1 event
    for( k, v in ipairs(pev) ) {
      assert_equal(v.fd, a->getfd());
      assert(v.IN, "IN event now");
    }
    assert(a->read());
    assert(b->close());
    assert(a->close());
  },
};

if( ! S.__rump ) { // uses clone() so cannot test with rump
test.netlink = {
  test_netlink_socket = function() {
    var sock, err = S.socket("netlink", "raw", "route");
    assert(sock, "Cannot open netlink socket: " .. tostring(err));
    sock->close();
  },
  test_getlink = function() {
    var i = assert(nl.getlink());
    var st, err = S.stat("/sys/class/net"); // just in case sysfs not mounted
    if( ! st ) { error ("skipped"); }
    var df = assert(util.dirtable("/sys/class/net", true));
    assert_equal(#df, #i, "expect same number of interfaces as /sys/class/net");
    assert(i.lo, "expect a loopback interface");
    var lo = i.lo;
    assert(lo.flags.up, "loopback interface should be up");
    assert(lo.flags.loopback, "loopback interface should be marked as loopback");
    assert(lo.flags.running, "loopback interface should be running");
    assert(! lo.flags.broadcast, "loopback interface should not be broadcast");
    assert(! lo.flags.multicast, "loopback interface should not be multicast");
    assert_equal(tostring(lo.macaddr), "00:00:00:00:00:00", "null hardware address on loopback");
    assert(lo.loopback, "loopback interface type should be loopback"); // TODO add getflag
    assert(lo.mtu >= 16436, "expect lo MTU at least 16436");
    var eth = i.eth0 || i.eth1; // may not exist
    if( eth ) {
      assert(eth.flags.broadcast, "ethernet interface should be broadcast");
      assert(eth.flags.multicast, "ethernet interface should be multicast");
      assert(eth.ether, "ethernet interface type should be ether");
      assert_equal(eth.addrlen, 6, "ethernet hardware address length is 6");
      var mac = assert(util.readfile("/sys/class/net/" .. eth.name .. "/address"), "expect eth to have address file in /sys");
      assert_equal(tostring(eth.macaddr) .. '\n', mac, "mac address hsould match that from /sys");
      assert_equal(tostring(eth.broadcast), 'ff:ff:ff:ff:ff:ff', "ethernet broadcast mac");
      var mtu = assert(util.readfile("/sys/class/net/" .. eth.name .. "/mtu"), "expect eth to have mtu in /sys");
      assert_equal(eth.mtu, tonumber(mtu), "expect ethernet MTU to match /sys");
    }
    var wlan = i.wlan0;
    if( wlan ) {
      assert(wlan.ether, "wlan interface type should be ether");
      assert_equal(wlan.addrlen, 6, "wireless hardware address length is 6");
      var mac = assert(util.readfile("/sys/class/net/" .. wlan.name .. "/address"), "expect wlan to have address file in /sys");
      assert_equal(tostring(wlan.macaddr) .. '\n', mac, "mac address should match that from /sys");
    }
  },
  test_get_addresses_in = function() {
    var as = assert(nl.getaddr("inet"));
    var lo = assert(nl.getlink()).lo.index;
    for( i = 1, #as ) {
      if( as[i].index == lo ) {
        assert_equal(tostring(as[i].addr), "127.0.0.1", "loopback ipv4 on lo");
      }
    }
  },
  test_get_addresses_in6 = function() {
    var as = assert(nl.getaddr("inet6"));
    var lo = assert(nl.getlink()).lo.index;
    for( i = 1, #as ) {
      if( as[i].index == lo ) {
        assert_equal(tostring(as[i].addr), "::1", "loopback ipv6 on lo"); // allow fail if no ipv6
      }
    }
  },
  test_interfaces = function() {
    var i = assert(nl.interfaces());
    assert_equal(tostring(i.lo.inet[1].addr), "127.0.0.1", "loopback ipv4 on lo");
    assert_equal(tostring(i.lo.inet6[1].addr), "::1", "loopback ipv6 on lo");
  },
  test_newlink_flags_root = function() {
    var p = assert(S.clone());
     if( p == 0 ) {
      fork_assert(S.unshare("newnet"));
      var i = fork_assert(nl.interfaces());
      fork_assert(i.lo && ! i.lo.flags.up, "expect new network ns has down lo interface");
      fork_assert(nl.newlink(i.lo.index, 0, "up", "up"));
      var lo = fork_assert(i.lo->refresh());
      fork_assert(lo.flags.up, "expect lo up now");
      S.exit();
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert(status.EXITSTATUS == 0, "expect normal exit in clone");
    }
  },
  test_interface_up_down_root = function() {
    var i = assert(nl.interfaces());
    assert(i.lo->down());
    assert(! i.lo.flags.up, "expect lo down");
    assert(i.lo->up());
    assert(i.lo.flags.up, "expect lo up now");
  },
  test_interface_setflags_root = function() {
    var p = assert(S.clone());
     if( p == 0 ) {
      fork_assert(S.unshare("newnet"));
      var i = fork_assert(nl.interfaces());
      fork_assert(i.lo, "expect new network ns has lo interface");
      fork_assert(! i.lo.flags.up, "expect new network lo is down");
      fork_assert(i.lo->setflags("up"));
      fork_assert(i.lo.flags.up, "expect lo up now");
      S.exit();
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert(status.EXITSTATUS == 0, "expect normal exit in clone");
    }
  },
  test_interface_set_mtu_root = function() {
    var i = assert(nl.interfaces());
    var lo = assert(i.lo, "expect lo interface");
    assert(lo->up());
    assert(lo.flags.up, "expect lo up now");
    var mtu = lo.mtu;
    assert(lo->setmtu(16000));
    assert_equal(lo.mtu, 16000, "expect MTU now 16000");
    assert(lo->setmtu(mtu));
  },
  test_interface_set_mtu_byname_root = function() {
    var i = assert(nl.interfaces());
    var lo = assert(i.lo, "expect lo interface");
    var mtu = lo.mtu;
    assert(lo->up());
    assert(nl.newlink(0, 0, "up", "up", "ifname", "lo", "mtu", 16000));
    assert(lo->refresh());
    assert_equal(lo.mtu, 16000, "expect MTU now 16000");
    assert(lo.flags.up, "expect lo up now");
    assert(lo->setmtu(mtu));
  },
  test_interface_rename_root = function() {
    var ok, err = nl.create_interface({name = "dummy0", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var i = assert(nl.interfaces());
    assert(i.dummy0);
    assert(i.dummy0->rename("newname"));
    assert(i->refresh());
    assert(i.newname && ! i.dummy0, "interface should be renamed");
    assert(i.newname->delete());
  },
  test_interface_set_macaddr_root = function() {
    var ok, err = nl.create_interface({name = "dummy0", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var i = assert(nl.interfaces());
    assert(i.dummy0);
    assert(i.dummy0->setmac("46:9d:c9:06:dd:dd"));
    assert_equal(tostring(i.dummy0.macaddr), "46:9d:c9:06:dd:dd", "interface should have new mac address");
    assert(i.dummy0->down());
    assert(i.dummy0->delete());
  },
  test_interface_set_macaddr_fail = function() {
    var i = assert(nl.interfaces());
    assert(i.lo, "expect to find lo");
    var ok, err = nl.newlink(i.lo.index, 0, 0, 0, "address", "46:9d:c9:06:dd:dd");
    assert(! ok && err && (err.PERM || err.OPNOTSUPP), "should not be able to change macaddr on lo");
  },
  test_newlink_error_root = function() {
    var ok, err = nl.newlink(-1, 0, "up", "up");
    assert(! ok, "expect bogus newlink to fail");
    assert(err.NODEV, "expect no such device error");
  },
  test_newlink_newif_dummy_root = function() {
    var ok, err = nl.create_interface({name = "dummy0", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var i = assert(nl.interfaces());
    assert(i.dummy0, "expect dummy interface");
    assert(i.dummy0->delete());
  },
  test_newlink_newif_bridge_root = function() {
    assert(nl.create_interface({name = "br0", type = "bridge"}));
    var i = assert(nl.interfaces());
    assert(i.br0, "expect bridge interface");
    var b = assert(util.bridge_list());
    assert(b.br0, "expect to find new bridge");
    assert(i.br0->delete());
  },
  test_dellink_by_name_root = function() {
    var ok, err = nl.create_interface({name = "dummy0", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var i = assert(nl.interfaces());
    assert(i.dummy0, "expect dummy interface");
    assert(nl.dellink(0, "ifname", "dummy0"));
    i = assert(nl.interfaces());
    assert(! i.dummy0, "expect dummy interface gone");
  },
  test_newaddr6_root = function() {
    var lo = assert(nl.interface("lo"));
    assert(nl.newaddr(lo, "inet6", 128, "permanent", "local", "::2"));
    assert(lo->refresh());
    assert_equal(#lo.inet6, 2, "expect two inet6 addresses on lo now");
    if( tostring(lo.inet6[1].addr) == "::1"
      ) { assert_equal(tostring(lo.inet6[2].addr), "::2");
      } else { assert_equal(tostring(lo.inet6[1].addr), "::2");
    }
    assert_equal(lo.inet6[2].prefixlen, 128, "expect /128");
    assert_equal(lo.inet6[1].prefixlen, 128, "expect /128");
    assert(nl.deladdr(lo.index, "inet6", 128, "address", "::2"));
    assert(lo->refresh());
    assert_equal(#lo.inet6, 1, "expect one inet6 addresses on lo now");
    assert_equal(tostring(lo.inet6[1].addr), "::1", "expect only ::1 now");
    // TODO this leaves a route to ::2 which we should delete
  },
  test_newaddr_root = function() {
    var ok, err = nl.create_interface({name = "dummy0", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var i = assert(nl.interfaces());
    assert(i.dummy0->up());
    var af, netmask, address, bcast = c.AF.INET, 24, t.in_addr("10.10.10.1"), t.in_addr("10.10.10.255");
    assert(nl.newaddr(i.dummy0.index, af, netmask, "permanent", "local", address, "broadcast", bcast));
    assert(i->refresh());
    assert_equal(#i.dummy0.inet, 1, "expect one address now");
    assert_equal(tostring(i.dummy0.inet[1].addr), "10.10.10.1");
    assert_equal(tostring(i.dummy0.inet[1].broadcast), "10.10.10.255");
    assert(i.dummy0->delete());
  },
  test_newaddr_helper_root = function() {
    var ok, err = nl.create_interface({name = "dummy0", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var i = assert(nl.interfaces());
    assert(i.dummy0->up());
    assert(i.dummy0->address("10.10.10.1/24"));
    assert(i.dummy0->refresh());
    assert_equal(#i.dummy0.inet, 1, "expect one address now");
    assert_equal(tostring(i.dummy0.inet[1].addr), "10.10.10.1");
    assert_equal(tostring(i.dummy0.inet[1].broadcast), "10.10.10.255");
    assert(i.dummy0->delete());
  },
  test_newaddr6_helper_root = function() {
    var lo = assert(nl.interface("lo"));
    assert(lo->address("::2/128"));
    assert(lo->refresh());
    assert_equal(#lo.inet6, 2, "expect two inet6 addresses on lo now");
    if( tostring(lo.inet6[1].addr) == "::1"
      ) { assert_equal(tostring(lo.inet6[2].addr), "::2");
      } else { assert_equal(tostring(lo.inet6[1].addr), "::2");
    }
    assert_equal(lo.inet6[2].prefixlen, 128, "expect /128");
    assert_equal(lo.inet6[1].prefixlen, 128, "expect /128");
    assert(lo->deladdress("::2"));
    assert_equal(#lo.inet6, 1, "expect one inet6 addresses on lo now");
    assert_equal(tostring(lo.inet6[1].addr), "::1", "expect only ::1 now");
    // TODO this leaves a route to ::2 which we should delete
  },
  test_getroute_inet = function() {
    var r = assert(nl.routes("inet", "unspec"));
    var nr = r->match("127.0.0.0/32");
    assert_equal(#nr, 1, "expect 1 route");
    var lor = nr[1];
    assert_equal(tostring(lor.source), "0.0.0.0", "expect empty source route");
    assert_equal(lor.output, "lo", "expect to be on lo");
  },
  test_getroute_inet6 = function() {
    var r = assert(nl.routes("inet6", "unspec"));
    var nr = r->match("::1/128");
    assert(#nr >= 1, "expect at least one matched route"); // one of my machines has two
    var lor = nr[1];
    assert_equal(tostring(lor.source), "::", "expect empty source route");
    assert_equal(lor.output, "lo", "expect to be on lo");
  },
  test_newroute_inet6_root = function() {
    var r = assert(nl.routes("inet6", "unspec"));
    var lo = assert(nl.interface("lo"));
    assert(nl.newroute("create", {family = "inet6", dst_len = 128, type = "unicast", protocol = "static"}, "dst", "::3", "oif", lo.index));
    r->refresh();
    var nr = r->match("::3/128");
    assert_equal(#nr, 1, "expect to find new route");
    nr = nr[1];
    assert_equal(nr.oif, lo.index, "expect route on lo");
    assert_equal(nr.output, "lo", "expect route on lo");
    assert_equal(nr.dst_len, 128, "expect /128");
    assert(nl.delroute({family = "inet6", dst_len = 128}, "dst", "::3", "oif", lo.index));
    r->refresh();
    nr = r->match("::3/128");
    assert_equal(#nr, 0, "expect route deleted");
  },
  test_netlink_events_root = function() {
    var sock = assert(nl.socket("route", {groups = "link"}));
    var ok, err = nl.create_interface({name = "dummy1", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var m = assert(nl.read(sock));
    assert(m.dummy1, "should find dummy 1 in returned info");
    assert_equal(m.dummy1.op, "newlink", "new interface");
    assert(m.dummy1.newlink, "new interface");
    assert(m.dummy1->setmac("46:9d:c9:06:dd:dd"));
    assert(m.dummy1->delete());
    m = assert(nl.read(sock));
    assert(m.dummy1, "should get info about deleted interface");
    assert_equal(tostring(m.dummy1.macaddr), "46:9d:c9:06:dd:dd", "should get address that was set");
    assert(sock->close());
  },
  test_move_interface_ns_root = function() {
    var ok, err = nl.create_interface({name = "dummy0", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var i = assert(nl.interfaces());
    assert(i.dummy0, "expect dummy0 interface");
    var p = assert(S.clone("newnet"));
    if( p == 0 ) {
      var sock = assert(nl.socket("route", {groups = "link"}));
      i = fork_assert(nl.interfaces());
      if( ! i.dummy0 ) {
        var m = assert(nl.read(sock));
        fork_assert(m.dummy0, "expect dummy0 appeared");
      }
      fork_assert(sock->close());
      i = fork_assert(nl.interfaces());
      fork_assert(i.dummy0, "expect dummy0 interface in child");
      fork_assert(i.dummy0->delete());
      fork_assert(i->refresh());
      fork_assert(! i.dummy0, "expect no dummy if");
      S.exit();
    } else {
      assert(i.dummy0->move_ns(p));
      assert(i->refresh());
      assert(! i.dummy0, "expect dummy0 vanished");
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert(status.EXITSTATUS == 0, "expect normal exit in clone");
    }
  },
  test_netlink_veth_root = function() {
    assert(nl.newlink(0, "create", 0, 0, "linkinfo", {"kind", "veth", "data", {"peer", {t.ifinfomsg, {}, "ifname", "veth1"}}}, "ifname", "veth0"));
    var i = assert(nl.interfaces());
    assert(i.veth0, "expect veth0");
    assert(i.veth1, "expect veth1");
    assert(nl.dellink(0, "ifname", "veth0"));
    assert(i->refresh());
    assert(! i.veth0, "expect no veth0");
    assert(! i.veth1, "expect no veth1");
  },
  test_create_veth_root = function() {
    // TODO create_interface version
    assert(nl.create_interface({name = "veth0", type = "veth", peer = {name = "veth1"}}));
    var i = assert(nl.interfaces());
    assert(i.veth0, "expect veth0");
    assert(i.veth1, "expect veth1");
    assert(nl.dellink(0, "ifname", "veth0"));
    assert(i->refresh());
    assert(! i.veth0, "expect no veth0");
    assert(! i.veth1, "expect no veth1");
  },
  test_newneigh_root = function() {
    var ok, err = nl.create_interface({name = "dummy0", type = "dummy"});
    if( ! ok && err.OPNOTSUPP ) { error ("skipped"); }
    var i = assert(nl.interfaces());
    assert(i.dummy0->up());
    assert(i.dummy0->address("10.0.0.1/32"));
    assert(nl.newneigh(i.dummy0, {family = "inet", state = "permanent"}, "dst", "10.0.0.2", "lladdr", "46:9d:c9:06:dd:dd"));
    var n = assert(nl.getneigh(i.dummy0, {family = "inet"}, "dst", "10.0.0.2", "lladdr", "46:9d:c9:06:dd:dd"));
    assert_equal(#n, 1);
    assert_equal(tostring(n[1].lladdr), "46:9d:c9:06:dd:dd");
    assert_equal(tostring(n[1].dst), "10.0.0.2");
    assert(nl.delneigh(i.dummy0, {family = "inet"}, "dst", "10.0.0.2", "lladdr", "46:9d:c9:06:dd:dd"));
    assert(i.dummy0->delete());
  },
};
}

test.events_epoll = {
  test_eventfd = function() {
    var fd = assert(S.eventfd(0, "nonblock"));
    var n = assert(util.eventfd_read(fd));
    assert_equal(n, 0, "eventfd should return 0 initially");
    assert(util.eventfd_write(fd, 3));
    assert(util.eventfd_write(fd, 6));
    assert(util.eventfd_write(fd, 1));
    n = assert(util.eventfd_read(fd));
    assert_equal(n, 10, "eventfd should return 10");
    n = assert(util.eventfd_read(fd));
    assert(n, 0, "eventfd should return 0 again");
    assert(fd->close());
  },
  test_epoll_events_iter = function() {
    var ev = t.epoll_events(8);
    var count = 0;
    for( k, v in ipairs(ev) ) { ++count    ; }
    assert_equal(count, 8);
  },
  test_epoll_wait = function() {
    var a, b = assert(S.socketpair("unix", "stream"));
    var ep = assert(S.epoll_create("cloexec"));
    assert(ep->epoll_ctl("add", a, "in"));
    var ev = t.epoll_events(1);
    var _, _, r = assert(ep->epoll_wait(ev, 0));
    assert(r == 0, "no events yet");
    assert(b->write(teststring));
    var count = 0;
    for( k, v in assert(ep->epoll_wait(ev, 0)) ) {
      ++count    ;
      assert(v.IN, "read event");
      assert(v.fd == a->getfd(), "expect to get fd of ready file back"); // by default our epoll_ctl sets this
    }
    assert(count == 1, "one event now");
    assert(ep->close());
    assert(a->read()); // clear event
    assert(b->close());
    assert(a->close());
  },
  test_epoll_pwait = function() {
    var a, b = assert(S.socketpair("unix", "stream"));
    var ep = assert(S.epoll_create("cloexec"));
    assert(ep->epoll_ctl("add", a, "in"));
    var ev = t.epoll_events(1);
    var _, _, r = assert(ep->epoll_pwait(ev, 0, "alrm"));
    assert(r == 0, "no events yet");
    assert(b->write(teststring));
    var count = 0;
    for( k, v in assert(ep->epoll_pwait(ev, 0, "alrm")) ) {
      ++count    ;
      assert(v.IN, "read event");
      assert(v.fd == a->getfd(), "expect to get fd of ready file back"); // by default our epoll_ctl sets this
    }
    assert(count == 1, "one event now");
    assert(ep->close());
    assert(a->read()); // clear event
    assert(b->close());
    assert(a->close());
  },
};

test.aio = {
  teardown = clean,
  test_aio_setup = function() {
    var ctx, err = S.io_setup(8);
    if( ! ctx && err.NOSYS ) { error ("skipped"); }
    assert(ctx, err);
    assert(S.io_destroy(ctx));
  },
/* -- temporarily disabled gc and methods on aio
  test_aio_ctx_gc = function()
    local ctx = assert(S.io_setup(8))
    local ctx2 = t.aio_context()
    ffi.copy(ctx2, ctx, s.aio_context)
    ctx = nil
    collectgarbage("collect")
    local ok, err = S.io_destroy(ctx2)
    assert(not ok, "should have closed aio ctx")
  end,
*/
  test_aio = function() {
    var ctx, err = S.io_setup(8);
    if( ! ctx && err.NOSYS ) { error ("skipped"); }
    assert(ctx, err);
    var abuf = assert(S.mmap(null, 4096, "read, write", "private, anonymous", -1, 0));
    ffi.copy(abuf, teststring);
    var fd = S.open(tmpfile, "creat, direct, rdwr", "RWXU"); // use O_DIRECT or aio may not work
    assert(S.unlink(tmpfile));
    assert(fd->pwrite(abuf, 4096, 0));
    ffi.fill(abuf, 4096);
    var a = t.iocb_array({{opcode = "pread", data = 42, fildes = fd, buf = abuf, nbytes = 4096, offset = 0}});
    var ret = assert(S.io_submit(ctx, a));
    assert_equal(ret, 1);
    var ev = t.io_events(1);
    var count = 0;
    for( k, v in assert(S.io_getevents(ctx, 1, ev)) ) {
      assert_equal(tonumber(v.data), 42);
      assert_equal(tonumber(v.res), 4096);
      ++count    ;
    }
    assert_equal(count, 1);
    assert(fd->close());
    assert(S.munmap(abuf, 4096));
    assert(S.io_destroy(ctx));
  },
  test_aio_error = function() {
    var ctx, err = S.io_setup(8);
    if( ! ctx && err.NOSYS ) { error ("skipped"); }
    assert(ctx, err);
    var abuf = assert(S.mmap(null, 4096, "read, write", "private, anonymous", -1, 0));
    ffi.copy(abuf, teststring);
    var fd = S.open(tmpfile, "creat, direct, rdwr", "RWXU"); // use O_DIRECT or aio may not work
    assert(S.unlink(tmpfile));
    assert(fd->pwrite(abuf, 4096, 0));
    ffi.fill(abuf, 4096);
    var a = t.iocb_array({{opcode = "pread", data = 42, fildes = fd, buf = null, nbytes = 4096, offset = 0}});
    var ret = assert(S.io_submit(ctx, a));
    assert_equal(ret, 1);
    var ev = t.io_events(1);
    var count = 0;
    for( k, v in assert(S.io_getevents(ctx, 1, ev)) ) {
      assert_equal(tonumber(v.data), 42);
      assert(tonumber(v.res) < 0); // there is an error
      assert(v.error.FAULT); // EFAULT as bad address
      ++count    ;
    }
    assert_equal(count, 1);
    assert(fd->close());
    assert(S.munmap(abuf, 4096));
    assert(S.io_destroy(ctx));
  },
/* -- no Linux fs supports this it seems...
  test_aio_fdsync = function()
    local ctx, err = S.io_setup(8)
    if not ctx and err.NOSYS then error "skipped" end
    assert(ctx, err)
    local fd = S.open(tmpfile, "creat, direct, rdwr", "RWXU") -- use O_DIRECT or aio may not work
    local a = t.iocb_array{{opcode = "fdsync", data = 42, fildes = fd, buf = nil, nbytes = 0, offset = 0}}
    local ret = assert(S.io_submit(ctx, a))
    assert_equal(ret, 1, "expect one event submitted")
    local ev = t.io_events(1)
    local count = 0
    for k, v in assert(S.io_getevents(ctx, 1, ev)) do
      assert_equal(tonumber(v.data), 42)
      assert_equal(tonumber(v.res), 0)
      count = count + 1
    end
    assert_equal(count, 1)
    assert(fd:close())
    assert(S.io_destroy(ctx))
  end,
*/
  test_aio_cancel = function() {
    var ctx, err = S.io_setup(8);
    if( ! ctx && err.NOSYS ) { error ("skipped"); }
    assert(ctx, err);
    var abuf = assert(S.mmap(null, 4096, "read, write", "private, anonymous", -1, 0));
    ffi.copy(abuf, teststring);
    var fd = S.open(tmpfile, "creat, direct, rdwr", "RWXU");
    assert(S.unlink(tmpfile));
    assert(fd->pwrite(abuf, 4096, 0));
    ffi.fill(abuf, 4096);
    var a = t.iocb_array({{opcode = "pread", data = 42, fildes = fd, buf = abuf, nbytes = 4096, offset = 0}});
    var count = 0;
    assert(S.io_submit(ctx, a));
    // erroring, giving EINVAL which is odd, man page says means ctx invalid TODO fix
    //local ok = assert(S.io_cancel(ctx, a.iocbs[1]))

    //assert_equal(count, 1)
    //local ev = t.io_events(1)
    //r = assert(S.io_getevents(ctx, 1, ev))
    //assert_equal(r, 0, "expect no aio events")
    assert(S.io_destroy(ctx));
    assert(fd->close());
    assert(S.munmap(abuf, 4096));
  },
  test_aio_eventfd = function() {
    var ctx, err = S.io_setup(8);
    if( ! ctx && err.NOSYS ) { error ("skipped"); }
    assert(ctx, err);
    var abuf = assert(S.mmap(null, 4096, "read, write", "private, anonymous", -1, 0));
    ffi.copy(abuf, teststring);
    var fd = S.open(tmpfile, "creat, direct, rdwr", "RWXU"); // need to use O_DIRECT for aio to work
    assert(S.unlink(tmpfile));
    assert(fd->pwrite(abuf, 4096, 0));
    ffi.fill(abuf, 4096);
    var efd = assert(S.eventfd());
    var ep = assert(S.epoll_create());
    assert(ep->epoll_ctl("add", efd, "in"));
    var a = t.iocb_array({{opcode = "pread", data = 42, fildes = fd, buf = abuf, nbytes = 4096, offset = 0, resfd = efd}});
    var ret = assert(S.io_submit(ctx, a));
    assert_equal(ret, 1, "expect one event submitted");
    var ev = t.epoll_events(1);
    var count = 0;
    for( k, v in assert(ep->epoll_wait(ev)) ) {
      ++count    ;
      assert(v.IN, "read event");
      assert(v.fd == efd->getfd(), "expect to get fd of eventfd file back");
    }
    assert_equal(count, 1, "one event now");
    var e = util.eventfd_read(efd);
    assert_equal(e, 1, "expect to be told one aio event ready");
    ev = t.io_events(1);
    count = 0;
    for( k, v in assert(S.io_getevents(ctx, 1, ev)) ) {
      assert_equal(tonumber(v.data), 42, "expect to get our data back"); // luaffi needs tonumber() annoying that fields not namespaced
      assert_equal(tonumber(v.res), 4096, "expect to get full read");
      ++count    ;
    }
    assert_equal(count, 1);
    assert(efd->close());
    assert(ep->close());
    assert(S.io_destroy(ctx));
    assert(fd->close());
    assert(S.munmap(abuf, 4096));
  },
};

test.ids_linux = {
  test_setreuid = function() {
    assert(S.setreuid(S.geteuid(), S.getuid()));
  },
  test_setregid = function() {
    assert(S.setregid(S.getegid(), S.getgid()));
  },
  test_getresuid = function() {
    var ruid, euid, suid = assert(S.getresuid());
    assert_equal(ruid, S.getuid(), "real uid same");
    assert_equal(euid, S.geteuid(), "effective uid same");
  },
  test_setresuid = function() {
    var ruid, euid, suid = assert(S.getresuid());
    assert(S.setresuid(ruid, euid, suid));
  },
  test_resuid_root = function() {
    var ruid, euid, suid = assert(S.getresuid());
    assert(S.setresuid(0, 33, 44));
    var ruid2, euid2, suid2 = assert(S.getresuid());
    assert_equal(ruid2, 0, "real uid as set");
    assert_equal(euid2, 33, "effective uid as set");
    assert_equal(suid2, 44, "saved uid as set");
    assert(S.setresuid(ruid, euid, suid));
  },
  test_getresgid = function() {
    var rgid, egid, sgid = assert(S.getresgid());
    assert_equal(rgid, S.getgid(), "real gid same");
    assert_equal(egid, S.getegid(), "effective gid same");
  },
  test_setresgid = function() {
    var rgid, egid, sgid = assert(S.getresgid());
    assert(S.setresgid(rgid, egid, sgid));
  },
  test_resgid_root = function() {
    var rgid, egid, sgid = assert(S.getresgid());
    assert(S.setresgid(0, 33, 44));
    var rgid2, egid2, sgid2 = assert(S.getresgid());
    assert_equal(rgid2, 0, "real gid as set");
    assert_equal(egid2, 33, "effective gid as set");
    assert_equal(sgid2, 44, "saved gid as set");
    assert(S.setresgid(rgid, egid, sgid));
  },
};

if( ! S.__rump ) { // rump cannot do clone so cannot run test
test.namespaces_root = {
  test_netns = function() {
    var p = assert(S.clone("newnet"));
    if( p == 0 ) {
      var i = fork_assert(nl.interfaces());
      fork_assert(i.lo && ! i.lo.flags.up, "expect new network ns only has down lo interface");
      S.exit();
    } else {
      assert(S.waitpid(-1, "clone"));
    }
  },
  test_netns_unshare = function() {
    var p = assert(S.clone());
    if( p == 0 ) {
      var ok = fork_assert(S.unshare("newnet"));
      var i = fork_assert(nl.interfaces());
      fork_assert(i.lo && ! i.lo.flags.up, "expect new network ns only has down lo interface");
      S.exit();
    } else {
      assert(S.waitpid(-1, "clone"));
    }
  },
  test_pidns = function() {
    var p = assert(S.clone("newpid"));
    if( p == 0 ) {
      fork_assert(S.getpid() == 1, "expec our pid to be 1 new new process namespace");
      S.exit();
    } else {
      assert(S.waitpid(-1, "clone"));
    }
  },
  test_setns = function() {
    var fd = assert(S.open("/proc/self/ns/net"));
    assert(fd->setns("newnet"));
    assert(fd->close());
  },
  test_setns_fail = function() {
    var fd = assert(S.open("/proc/self/ns/net"));
    assert(! fd->setns("newipc"));
    assert(fd->close());
  },
};
}

test.filesystem_linux = {
  teardown = clean,
  test_statfs = function() {
    var st = assert(S.statfs("."));
    assert(st.f_bfree <= st.f_blocks, "expect fewer free blocks than total blocks");
  },
  test_fstatfs = function() {
    var fd = assert(S.open(".", "rdonly"));
    var st = assert(S.fstatfs(fd));
    assert(st.f_bfree <= st.f_blocks, "expect fewer free blocks than total blocks");
    assert(fd->close());
  },
  test_utimensat = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    var dfd = assert(S.open("."));
    assert(S.utimensat(null, tmpfile));
    var st1 = fd->stat();
    assert(S.utimensat(dfd, tmpfile, {"omit", "omit"}));
    var st2 = fd->stat();
    assert(st1.atime == st2.atime && st1.mtime == st2.mtime, "atime and mtime unchanged");
    assert(S.unlink(tmpfile));
    assert(fd->close());
    assert(dfd->close());
  },
};

test.mount_linux_root = {
  teardown = clean,
  test_mount = function() {
    assert(S.mkdir(tmpfile));
    assert(S.mount("none", tmpfile, "tmpfs", "rdonly, noatime"));
    assert(S.umount(tmpfile));
    assert(S.rmdir(tmpfile));
  },
  test_util_mount = function() {
    assert(S.mkdir(tmpfile));
    assert(util.mount({source = "none", target = tmpfile, type = "tmpfs", flags = "rdonly, noatime"}));
    assert(S.umount(tmpfile));
    assert(S.rmdir(tmpfile));
  },
};

test.misc_linux_root = {
  teardown = clean,
  test_acct = function() {
    S.acct(); // may not be configured
  },
  test_sethostname = function() {
    var h = S.gethostname();
    var hh = "testhostname";
    assert(S.sethostname(hh));
    assert_equal(hh, assert(S.gethostname()));
    assert(S.sethostname(h));
    assert_equal(h, assert(S.gethostname()));
  },
/* -- this is rebooting one machine, and umount, not working TODO debug
  test_pivot_root = function()
    assert(S.mkdir(tmpfile3))
    local p = assert(S.clone("newns"))
    if p == 0 then
      fork_assert(S.mount(tmpfile3, tmpfile3, "none", "bind")) -- to make sure on different mount point
      fork_assert(S.mount(tmpfile3, tmpfile3, nil, "private"))
      fork_assert(S.chdir(tmpfile3))
      fork_assert(S.mkdir("old"))
      fork_assert(S.pivot_root(".", "old"))
      fork_assert(S.chdir("/"))
      local d = fork_assert(S.dirfile("/"))
      fork_assert(d["old"])
      --fork_assert(S.umount("old")) -- returning busy, TODO need to sort out why.
      S.exit()
    else
      local rpid, status = assert(S.waitpid(-1, "clone"))
      assert(status.EXITSTATUS == 0, "expect normal exit in clone")
    end
    assert(S.rmdir(tmpfile3 .. "/old")) -- until we can unmount above
    assert(S.rmdir(tmpfile3))
  end,
*/
  test_reboot = function() {
    error ("skipped"); // rebooting machine so not helpful
    var p = assert(S.clone("newpid"));
    if( p == 0 ) {
      fork_assert(S.reboot("restart")); // will send SIGHUP to us as in pid namespace NB older kernels may reboot!
      S.pause();
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert(status.IFSIGNALED, "expect signal killed process");
    }
  },
};

test.bridge_linux = {
  test_bridge = function() {
    var ok, err = util.bridge_add("br0");
    assert(ok || err.NOPKG || err.PERM, err); // ok not to to have bridge in kernel, may not be root
    if( ok ) {
      var i = assert(nl.interfaces());
      assert(i.br0);
      var b = assert(util.bridge_list());
      assert(b.br0, "expect to find bridge in list");
      assert(b.br0.bridge.root_id, "expect to find root id");
      assert(util.bridge_del("br0"));
      i = assert(nl.interfaces());
      assert(! i.br0, "bridge should be gone");
    }
  },
  test_bridge_delete_fail = function() {
    var ok, err = util.bridge_del("nosuchbridge99");
    assert(! ok && (err.NOPKG || err.PERM || err.NXIO), err);
  },
};

// also works on NetBSD but poor filesystem support
test.xattr_linux = {
  teardown = clean,
  test_xattr_empty_fd = function() {
    if( ! S.fgetxattr ) { error ("skipped"); }
    var fd = assert(S.creat(tmpfile, "rwxu"));
    assert(S.unlink(tmpfile));
    var n, err = fd->fgetxattr("user.myattr");
    assert(! n, "expect failure");
    assert(! n && (err.NOATTR || err.NOSYS || err.NOTSUP));
    assert(! n, err);
    assert(fd->close());
  },
  test_xattr = function() {
    if( ! S.listxattr ) { error ("skipped"); }
    assert(S.creat(tmpfile, "0666"));
    var l, err = S.listxattr(tmpfile);
    if( ! l && (err.NOSYS || err.NOTSUP) ) { error ("skipped"); }
    assert(l, err);
    var fd = assert(S.open(tmpfile, "rdwr"));
    assert(#l == 0 || (#l == 1 && l[1] == "security.selinux"), "expect no xattr on new file");
    l = assert(S.llistxattr(tmpfile));
    assert(#l == 0 || (#l == 1 && l[1] == "security.selinux"), "expect no xattr on new file");
    l = assert(fd->flistxattr());
    assert(#l == 0 || (#l == 1 && l[1] == "security.selinux"), "expect no xattr on new file");
    var nn = #l;
    var ok;
    ok, err = S.setxattr(tmpfile, "user.test", "42", "create");
    if( ! ok && err.NOTSUP ) { error ("skipped"); }
    l = assert(S.listxattr(tmpfile));
    assert(#l == nn + 1, "expect another attribute set");
    assert(S.lsetxattr(tmpfile, "user.test", "44", "replace"));
    assert(fd->fsetxattr("user.test2", "42"));
    l = assert(S.listxattr(tmpfile));
    assert(#l == nn + 2, "expect another attribute set");
    var s = assert(S.getxattr(tmpfile, "user.test"));
    assert(s == "44", "expect to read set value of xattr");
    s = assert(S.lgetxattr(tmpfile, "user.test"));
    assert(s == "44", "expect to read set value of xattr");
    s = assert(fd->fgetxattr("user.test2"));
    assert(s == "42", "expect to read set value of xattr");
    s, err = fd->fgetxattr("user.test3");
    assert(err && err.nodata, "expect to get NODATA (=NOATTR) from non existent xattr");
    s = assert(S.removexattr(tmpfile, "user.test"));
    s = assert(S.lremovexattr(tmpfile, "user.test2"));
    l = assert(S.listxattr(tmpfile));
    assert(#l == nn, "expect no xattr now");
    s, err = fd->fremovexattr("user.test3");
    assert(err && err.nodata, "expect to get NODATA (=NOATTR) from remove non existent xattr");
    // table helpers
    var tt = assert(S.xattr(tmpfile));
    var n = 0;
    for( k, v in pairs(tt) ) { ++n    ; }
    assert(n == nn, "expect no xattr now");
    tt = {};
    for( k, v in pairs({test = "42", test2 = "44"}) ) { tt["user." .. k] = v; }
    assert(S.xattr(tmpfile, tt));
    tt = assert(S.lxattr(tmpfile));
    assert(tt["user.test2"] == "44" && tt["user.test"] == "42", "expect to return values set");
    n = 0;
    for( k, v in pairs(tt) ) { ++n    ; }
    assert(n == nn + 2, "expect 2 xattr now");
    tt = {};
    for( k, v in pairs({test = "42", test2 = "44", test3="hello"}) ) { tt["user." .. k] = v; }
    assert(fd->fxattr(tt));
    tt = assert(fd->fxattr());
    assert(tt["user.test2"] == "44" && tt["user.test"] == "42" && tt["user.test3"] == "hello", "expect to return values set");
    n = 0;
    for( k, v in pairs(tt) ) { ++n    ; }
    assert(n == nn + 3, "expect 3 xattr now");
    assert(fd->close());
    assert(S.unlink(tmpfile));
  },
  test_xattr_long = function() {
    if( ! S.setxattr ) { error ("skipped"); }
    assert(S.creat(tmpfile, "RWXU", "0666"));
    var l = string.rep("test", 500);
    var ok, err = S.setxattr(tmpfile, "user.test", l, "create");
    if( ! ok && (err.NOTSUP || err.NOSYS || err.OPNOTSUPP || err.NOSPC) ) { error ("skipped"); }
    var tt = assert(S.getxattr(tmpfile, "user.test"));
    assert_equal(tt, l, "should match string");
    assert(S.unlink(tmpfile));
  },
};

test.mounts = {
  teardown = clean,
  test_mounts_root = function() { // rump has no /proc which alas means no /proc/mounts
    var cwd = assert(S.getcwd());
    var dir = cwd .. "/" .. tmpfile;
    assert(S.mkdir(dir));
    assert(S.mount("none", dir, "tmpfs", "rdonly, noatime"));
    var m = assert(util.mounts());
    assert(#m > 0, "expect at least one mount point");
    var b = m[#m];
    assert_equal(b.source, "none", "expect source match");
    assert_equal(b.target, dir, "expect target match");
    assert_equal(b.type, "tmpfs", "expect type match");
    assert_equal(c.MS[b.flags], c.MS["rdonly, noatime"], "expect flags match");
    assert_equal(b.freq, "0");
    assert_equal(b.passno, "0");
    assert(S.umount(dir));
    assert(S.rmdir(dir));
  },
};

test.bpf = {
  test_bpf_struct_stmt = function() {
    var bpf = t.sock_filter("LD,H,ABS", 12);
    assert_equal(bpf.code, c.BPF.LD + c.BPF.H + c.BPF.ABS);
    assert_equal(bpf.jt, 0);
    assert_equal(bpf.jf, 0);
    assert_equal(bpf.k, 12);
  },
  test_bpf_struct_jump = function() {
    var bpf = t.sock_filter("JMP,JEQ,K", c.ETHERTYPE.REVARP, 0, 3);
    assert_equal(bpf.code, c.BPF.JMP + c.BPF.JEQ + c.BPF.K);
    assert_equal(bpf.jt, 0);
    assert_equal(bpf.jf, 3);
    assert_equal(bpf.k, c.ETHERTYPE.REVARP);
  },
};

// TODO remove arch tests. Unclear if my ppc/arm does not support or a bug, retest later with newer kernel
// still ppc issues with 3.12.6 ppc, need to debug more, and mips issues
if( ! (abi.arch == "ppc64le" || abi.arch == "ppc" || abi.arch == "arm" || abi.arch == "mips" || S.__rump) ) { // cannot test on rump as uses clone()
test.seccomp = {
  test_no_new_privs = function() { // this must be done for non root to call type 2 seccomp
    var p = assert(S.clone());
     if( p == 0 ) {
      var ok, err = S.prctl("set_no_new_privs", true);
      if( err && err.INVAL ) { S.exit(); } // may not be supported
      var nnp = fork_assert(S.prctl("get_no_new_privs"));
      fork_assert(nnp == 1);
      S._exit();
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert_equal(status.EXITSTATUS, 0);
    }
  },
  test_seccomp_allow = function() {
    var p = assert(S.clone());
     if( p == 0 ) {
      var ok, err = S.prctl("set_no_new_privs", true);
      if( err && err.INVAL ) { S.exit(); } // may not be supported
      var nnp = fork_assert(S.prctl("get_no_new_privs"));
      fork_assert(nnp == 1);
      var program = {
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
      };
      var pp = t.sock_filters(#program, program);
      p = t.sock_fprog1({{#program, pp}});
      ok, err = S.prctl("set_seccomp", "filter", p);
      if( err && err.INVAL ) { S.exit(); } // may not be supported
      fork_assert(ok);
      var pid = S.getpid();
      S._exit();
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert_equal(status.EXITSTATUS, 0);
    }
  },
  test_seccomp = function() {
    var p = assert(S.clone());
     if( p == 0 ) {
      var ok, err = S.prctl("set_no_new_privs", true);
      if( err && err.INVAL ) { S.exit(); } // may not be supported
      var nnp = fork_assert(S.prctl("get_no_new_privs"));
      fork_assert(nnp == 1);
      var program = {
        // test architecture correct
        t.sock_filter("LD,W,ABS", ffi.offsetof(t.seccomp_data, "arch")),
        t.sock_filter("JMP,JEQ,K", util.auditarch(), 1, 0),
        t.sock_filter("RET,K", c.SECCOMP_RET.KILL),
        // get syscall number
        t.sock_filter("LD,W,ABS", ffi.offsetof(t.seccomp_data, "nr")),
        // allow syscall getpid
        t.sock_filter("JMP,JEQ,K", nr.SYS.getpid, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall exit_group
        t.sock_filter("JMP,JEQ,K", nr.SYS.exit_group, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall mprotect in case luajit allocates memory for jitting
        t.sock_filter("JMP,JEQ,K", nr.SYS.mprotect, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall mmap/mmap2 in case luajit allocates memory
        t.sock_filter("JMP,JEQ,K", nr.SYS.mmap2 || nr.SYS.mmap, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall brk in case luajit allocates memory
        t.sock_filter("JMP,JEQ,K", nr.SYS.brk, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // else kill
        t.sock_filter("RET,K", c.SECCOMP_RET.KILL),
      };
      var pp = t.sock_filters(#program, program);
      p = t.sock_fprog1({{#program, pp}});
      ok, err = S.prctl("set_seccomp", "filter", p);
      if( err && err.INVAL ) { S.exit(); } // may not be supported
      fork_assert(ok);
      var pid = S.getpid();
      S._exit(); // use _exit as normal exit might call syscalls
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      if( status.EXITSTATUS != 0 ) { // failed, get debug info
        assert_equal(status.code, nr.SYS.seccomp);
      }
      assert_equal(status.EXITSTATUS, 0);
    }
  },
  test_seccomp_fail = function() {
    var p = assert(S.clone());
     if( p == 0 ) {
      var ok, err = S.prctl("set_no_new_privs", true);
      if( err && err.INVAL ) { S.exit(42); } // may not be supported
      var nnp = fork_assert(S.prctl("get_no_new_privs"));
      fork_assert(nnp == 1);
      var program = {
        // test architecture correct
        t.sock_filter("LD,W,ABS", ffi.offsetof(t.seccomp_data, "arch")),
        t.sock_filter("JMP,JEQ,K", util.auditarch(), 1, 0),
        t.sock_filter("RET,K", c.SECCOMP_RET.KILL),
        // get syscall number
        t.sock_filter("LD,W,ABS", ffi.offsetof(t.seccomp_data, "nr")),
        // allow syscall getpid
        t.sock_filter("JMP,JEQ,K", nr.SYS.getpid, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall exit_group
        t.sock_filter("JMP,JEQ,K", nr.SYS.exit_group, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // else kill
        t.sock_filter("RET,K", c.SECCOMP_RET.KILL),
      };
      var pp = t.sock_filters(#program, program);
      p = t.sock_fprog1({{#program, pp}});
      ok, err = S.prctl("set_seccomp", "filter", p);
      if( err && err.INVAL ) { S.exit(); } // may not be supported
      fork_assert(ok);
      var pid = S.getpid();
      var fd = fork_assert(S.open("/dev/null", "rdonly")); // not allowed
      S._exit();
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert(status.EXITSTATUS == 0 || status.EXITSTATUS == 42 || status.TERMSIG == c.SIG.SYS, "expect SIGSYS from failed seccomp (or not implemented)");
    }
  },
  test_seccomp_fail_errno = function() {
    var p = assert(S.clone());
     if( p == 0 ) {
      var ok, err = S.prctl("set_no_new_privs", true);
      if( err && err.INVAL ) { S.exit(42); } // may not be supported TODO change to feature test
      var nnp = fork_assert(S.prctl("get_no_new_privs"));
      fork_assert(nnp == 1);
      var program = {
        // test architecture correct
        t.sock_filter("LD,W,ABS", ffi.offsetof(t.seccomp_data, "arch")),
        t.sock_filter("JMP,JEQ,K", util.auditarch(), 1, 0),
        t.sock_filter("RET,K", c.SECCOMP_RET.KILL),
        // get syscall number
        t.sock_filter("LD,W,ABS", ffi.offsetof(t.seccomp_data, "nr")),
        // allow syscall getpid
        t.sock_filter("JMP,JEQ,K", nr.SYS.getpid, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall write
        t.sock_filter("JMP,JEQ,K", nr.SYS.write, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall exit_group
        t.sock_filter("JMP,JEQ,K", nr.SYS.exit_group, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall mprotect in case luajit allocates memory for jitting
        t.sock_filter("JMP,JEQ,K", nr.SYS.mprotect, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall mmap/mmap2 in case luajit allocates memory
        t.sock_filter("JMP,JEQ,K", nr.SYS.mmap2 || nr.SYS.mmap, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // allow syscall brk in case luajit allocates memory
        t.sock_filter("JMP,JEQ,K", nr.SYS.brk, 0, 1),
        t.sock_filter("RET,K", c.SECCOMP_RET.ALLOW),
        // else error exit, also return syscall number
        t.sock_filter("ALU,OR,K", c.SECCOMP_RET.ERRNO),
        t.sock_filter("RET,A"),
      };
      var pp = t.sock_filters(#program, program);
      p = t.sock_fprog1({{#program, pp}});
      ok, err = S.prctl("set_seccomp", "filter", p);
      if( err && err.INVAL ) { S.exit(); } // may not be supported
      fork_assert(ok);
      var pid = S.getpid();
      var ofd;
      ofd, err = S.open("/dev/null", "rdonly"); // not allowed
      fork_assert(! ofd, "should not run open");
      fork_assert(err.errno == nr.SYS.open, "syscall that did not work should be open");
      pid = S.getpid();
      S._exit();
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert(status.EXITSTATUS == 0 || status.EXITSTATUS == 42, "expect normal exit if supported");
    }
  },
};
}

/* -- TODO fix, ioctl set to want an int not an ifreq, probably needs tweaking to get right number
test.tuntap_root = {
  test_tuntap_root = function()
    local clonedev = "/dev/net/tun"
    local fd = assert(S.open(clonedev, "rdwr"))
    local ifr = t.ifreq()
    ifr.flags = "tun"
    assert(fd:ioctl("TUNSETIFF", ifr))
    assert_equal(ifr.name, "tun0")
    assert(fd:close())
    local i = assert(nl.interfaces())
    assert(not i.tun0, "interface should not persist")
  end,
}
*/

test.capabilities = {
  teardown = clean,
  test_cap_tostring = function() {
    var cap = t.cap();
    cap.SYSLOG = true;
    assert_equal(tostring(cap), "SYSLOG");
    cap.SYS_ADMIN = true;
    assert(tostring(cap) == "SYSLOG,SYS_ADMIN" || tostring(cap) == "SYS_ADMIN,SYSLOG");
  },
  test_cap_types = function() {
    var cap = t.capabilities();
    assert_equal(cap.version, c.LINUX_CAPABILITY_VERSION[3], "expect defaults to version 3");
    for( k, _ in pairs(c.CAP) ) {
      assert(! cap.effective[k]);
    }
    for( k, _ in pairs(c.CAP) ) {
      cap.effective[k] = true;
    }
    for( k, _ in pairs(c.CAP) ) {
      assert(cap.effective[k]);
    }
    for( k, _ in pairs(c.CAP) ) {
      cap.effective[k] = false;
    }
    for( k, _ in pairs(c.CAP) ) {
      assert(! cap.effective[k]);
    }
  },
  test_get_cap_version = function() {
    var hdr = t.user_cap_header();
    S.capget(hdr); // man page says returns error, but does not seem to
    assert_equal(hdr.version, c.LINUX_CAPABILITY_VERSION[3], "expect capability version 3 API on recent kernel");
  },
  test_capget = function() {
    if( S.geteuid() == 0 ) { return; } // do not run test as root
    var cap = S.capget();
    var count = 0;
    for( k, _ in pairs(c.CAP) ) {
      if( cap.effective[k] && k != "SYSLOG" ) { // Travis CI randomly has this set have sent report
        ++count    ;
      }
    }
    assert(count == 0, "non-root has no caps, has " .. count .. ": " .. tostring(cap));
  },
  test_capget_root = function() {
    var cap = S.capget();
    var count = 0;
    for( k, _ in pairs(c.CAP) ) {
      if( cap.effective[k] ) {
        ++count    ;
      }
    }
      assert(count > 0, "root should have some caps");
  },
  test_capset_root = function() {
    var p = assert(S.clone());
    if( p == 0 ) {
      var cap = fork_assert(S.capget());
      cap.effective.sys_chroot = false;
      fork_assert(S.capset(cap));
      var ok, err = S.chroot(".");
      fork_assert(! ok && err.PERM, "should not have chroot capability");
      S.exit();
    } else {
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert_equal(status.EXITSTATUS, 0);
    }
  },
  test_filesystem_caps_get = function() {
    assert(util.touch(tmpfile));
    var c, err = util.capget(tmpfile);
    if( ! c && err.NOTSUP ) { error ("skipped"); } // xattr/fs caps might not be supported
    assert(! c && err.NODATA, "expect no caps");
    assert(S.unlink(tmpfile));
  },
  test_filesystem_caps_getset_root = function() {
    assert(util.touch(tmpfile));
    var cap, err = util.capget(tmpfile);
    if( ! c && err.NOTSUP ) { error ("skipped"); } // xattr/fs caps might not be supported
    assert(! cap && err.NODATA, "expect no caps");
    assert(util.capset(tmpfile, {permitted = "sys_chroot, sys_admin", inheritable = "chown, mknod"}, "create"));
    cap = assert(util.capget(tmpfile));
    assert(cap.permitted.sys_chroot && cap.permitted.sys_admin, "expect capabilities set");
    assert(cap.inheritable.chown && cap.inheritable.mknod, "expect capabilities set");
    assert(S.unlink(tmpfile));
  },
};

test.mq = {
  test_mq_open_close_unlink = function() {
    var mq, err = S.mq_open(mqname, "rdwr,creat", "rusr,wusr", {maxmsg = 10, msgsize = 512});
    if( ! mq && err.NOSYS ) { return; } // kernel may not support
    assert(S.mq_unlink(mqname)); // unlink so errors do not leave dangling
    assert(mq->close());
  },
  test_mq_getsetattr = function() {
    var mq, err = S.mq_open(mqname, "rdwr,creat, nonblock", "rusr,wusr", {maxmsg = 10, msgsize = 512});
    if( ! mq && err.NOSYS ) { return; } // kernel may not support
    assert(S.mq_unlink(mqname));
    var attr = mq->getattr();
    assert_equal(attr.flags, c.O.NONBLOCK);
    assert_equal(attr.maxmsg, 10);
    assert_equal(attr.msgsize, 512);
    assert(mq->setattr(0)); // clear nonblock flag
    attr = mq->getattr();
    assert_equal(attr.flags, 0);
    assert(mq->close());
  },
  test_mq_send_receive = function() {
    var mq, err = S.mq_open(mqname, "rdwr,creat", "rusr,wusr", {maxmsg = 10, msgsize = 1});
    if( ! mq && err.NOSYS ) { return; } // kernel may not support
    assert(S.mq_unlink(mqname));
    assert(mq->timedsend("a"));  // default prio is zero so should be behind second message
    assert(mq->send("b", null, 10, 1)); // 1 is timeout in seconds
    var prio = t.int1(-1); // initialise with invalid value
    var msg = mq->timedreceive(null, 1, prio, 1);
    assert_equal(msg, "b");
    assert_equal(prio[0], 10);
    msg = mq->receive(null, 1);
    assert_equal(msg, "a");
    assert(mq->close());    
  },
  // TODO mq_notify
};

if( ! S.__rump ) { // rump has no processes, memory allocation, process accounting, mmap and proc not applicable
test.mremap = { // differs in prototype by OS
  test_mremap = function() {
    var size = 4096;
    var size2 = size * 2;
    var mem = assert(S.mmap(null, size, "read", "private, anonymous", -1, 0));
    mem = assert(S.mremap(mem, size, size2, "maymove"));
    assert(S.munmap(mem, size2));
  },
};

test.remap_file_pages = {
  test_remap_file_pages = function() {
    var fd = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    assert(S.unlink(tmpfile));
    var size = S.getpagesize();
    var mem = assert(fd->mmap(null, size, "read", "shared", 0));
    var ok, err = S.remap_file_pages(mem, size, 0, 0, 0);
    if( ! ok && err.NOSYS ) { error ("skipped"); }
    assert(ok, err);
    assert(S.munmap(mem, size));
    assert(fd->close());
  },
};

test.signals_linux = {
  test_itimer = function() {
    var tt = assert(S.getitimer("real"));
    assert(tt.interval.sec == 0, "expect timer not set");

    var fd = assert(S.signalfd("alrm", "nonblock")); // TODO make test portable
    assert(S.sigprocmask("block", "alrm"));

    assert(S.setitimer("real", {0, 0.01}));
    assert(S.nanosleep(0.1)); // nanosleep does not interact with itimer

    var sig = assert(util.signalfd_read(fd));
    assert_equal(#sig, 1);
    assert(sig[1].alrm, "expect alarm clock to have rung");
    assert(fd->close());
    assert(S.sigprocmask("unblock", "alrm"));
  },
  test_sigprocmask = function() {
    var m = assert(S.sigprocmask());
    assert(! m.winch, "expect sigwinch not masked");
    m = m->add(c.SIG.WINCH);
    assert(! m.isemptyset, "expect set not empty");
    assert(m.winch, "expect to have added SIGWINCH");
    m = m->del("WINCH, pipe");
    assert(! m.winch, "expect set empty again");
    m = m->add("winch");
    m = assert(S.sigprocmask("block", m));
    assert(m.isemptyset, "expect old sigprocmask to be empty");
    assert(S.kill(S.getpid(), "winch")); // should be blocked but pending
    var p = assert(S.sigpending());
    assert(p.winch, "expect pending winch");

    // signalfd. TODO Should be in another test
    var ss = "winch, pipe, usr1, usr2";
    var fd = assert(S.signalfd(ss, "nonblock"));
    assert(S.sigprocmask("block", ss));
    assert(S.kill(S.getpid(), "usr1"));
    ss = assert(util.signalfd_read(fd));
    assert(#ss == 2, "expect to read two signals"); // previous pending winch, plus USR1
    assert((ss[1].winch && ss[2].usr1) || (ss[2].winch && ss[1].usr1), "expect a winch and a usr1 signal"); // unordered
    assert(ss[1].user, "signal sent by user");
    assert(ss[2].user, "signal sent by user");
    assert_equal(ss[1].pid, S.getpid(), "signal sent by my pid");
    assert_equal(ss[2].pid, S.getpid(), "signal sent by my pid");
    assert(fd->close());
  },
/* -- segfaulting on Android
  test_sigaction_ucontext = function() -- this test does not do much yet
    local sig = t.int1(0)
    local pid = t.int32_1(0)
    local function fh(s, info, uc)
      local ucontext = pt.ucontext(uc)
      sig[0] = s
      pid[0] = info.pid
      local mcontext = ucontext.uc_mcontext
    end
    jit.off(fh, true)
    local f = t.sa_sigaction(fh)
    assert(S.sigaction("pipe", {sigaction = f}))
    assert(S.kill(S.getpid(), "pipe"))
    assert(S.sigaction("pipe", "dfl"))
    assert_equal(sig[0], c.SIG.PIPE)
    assert_equal(pid[0], S.getpid())
    f:free() -- free ffi slot for function
  end,
*/
// broken since updating sigaction, may well need a restorer
/*
  test_sigaction_function_handler = function()
    local sig = t.int1(0)
    local function fh(s) sig[0] = s end
    if jit then jit.off(fh, true) end -- TODO sort out if needed/broken
    local f = t.sighandler(fh)
    assert(S.sigaction("pipe", {handler = f}))
    assert(S.kill(S.getpid(), "pipe"))
    assert(S.sigaction("pipe", "dfl"))
    assert_equal(sig[0], c.SIG.PIPE)
    f:free() -- free ffi slot for function
  end,
*/
/* -- failing on Android, uncertain about correctness with LuaJIT
  test_sigaction_function_sigaction = function()
    local sig = t.int1(0)
    local pid = t.int32_1(0)
    local f = t.sa_sigaction(function(s, info, ucontext)
      sig[0] = s
      pid[0] = info.pid
    end)
    assert(S.sigaction("pipe", {sigaction = f}))
    assert(S.kill(S.getpid(), "pipe"))
    assert(S.sigaction("pipe", "dfl"))
    assert_equal(sig[0], c.SIG.PIPE)
    assert_equal(pid[0], S.getpid())
    f:free() -- free ffi slot for function
  end,
*/
};

test.processes_linux = {
  test_fork_waitid_linux = function() { // uses Linux specific waitid extension
    var pid0 = S.getpid();
    var pid = assert(S.fork());
    if( pid == 0 ) { // child
      fork_assert(S.getppid() == pid0, "parent pid should be previous pid");
      S.exit(23);
    } else { // parent
      var infop, rusage = assert(S.waitid("all", 0, "exited, stopped, continued"));
      assert_equal(infop.signo, c.SIG.CHLD, "waitid to return SIGCHLD");
      assert_equal(infop.status, 23, "exit should be 23");
      assert_equal(infop.code, c.SIGCLD.EXITED, "normal exit expected");
      assert(rusage);
    }
  },
  test_clone = function() {
    var pid0 = S.getpid();
    var p = assert(S.clone()); // no flags, should be much like fork.
    if( p == 0 ) { // child
      fork_assert(S.getppid() == pid0, "parent pid should be previous pid");
      S.exit(23);
    } else { // parent
      var rpid, status = assert(S.waitpid(-1, "clone"));
      assert_equal(rpid, p, "expect clone to return same pid as wait");
      assert(status.WIFEXITED, "process should have exited normally");
      assert(status.EXITSTATUS == 23, "exit should be 23");
    }
  },
};
test.scheduler = {
  test_getcpu = function() {
    var r, err = S.getcpu();
    assert((err && err.NOSYS) || type(r) == "table", "table returned if supported");
  },
  test_sched_set_getscheduler = function() {
    assert(S.sched_setscheduler(0, "normal"));
    var sched = assert(S.sched_getscheduler());
    assert_equal(sched, c.SCHED.NORMAL);
  },
  test_sched_set_getscheduler_root = function() {
    assert(S.sched_setscheduler(0, "idle"));
    var sched = assert(S.sched_getscheduler());
    assert_equal(sched, c.SCHED.IDLE);
    assert(S.sched_setscheduler(0, "normal"));
  },
  test_sched_yield = function() {
    assert(S.sched_yield());
  },
  test_cpu_set = function() {
    var set = t.cpu_set({0, 1});
    assert_equal(set.val[0], 3);
    assert(set->get(0) && set->get(1) && ! set->get(2));
    assert(set[0] && set[1] && ! set[2]);
  },
  test_sched_getaffinity = function() {
    var set = S.sched_getaffinity();
    assert(set[0], "should be able to run on cpu 0");
  },
  test_sched_setaffinity = function() {
    var set = S.sched_getaffinity();
    set[1] = false;
    assert(! set[1]);
    assert(S.sched_setaffinity(0, set));
  },
  test_get_sched_priority_minmax = function() {
    var min = S.sched_get_priority_min("fifo");
    var max = S.sched_get_priority_max("fifo");
    assert_equal(min, 1); // values for Linux
    assert_equal(max, 99); // values for Linux
  },
  test_sched_getparam = function() {
    var prio = S.sched_getparam();
    assert_equal(prio, 0, "standard schedular has no priority value");
  },
    test_sched_setgetparam_root = function() {
    assert(S.sched_setscheduler(0, "fifo", 1));
    assert_equal(S.sched_getscheduler(), c.SCHED.FIFO);
    var prio = S.sched_getparam();
    assert_equal(prio, 1, "set to 1");
    S.sched_setparam(0, 50);
    prio = S.sched_getparam();
    assert_equal(prio, 50, "set to 50");
    assert(S.sched_setscheduler(0, "normal"));
  },
  test_sched_rr_get_interval = function() {
    var ts = assert(S.sched_rr_get_interval());
  },
};

test.swap = {
  test_swap_constants = function() {
    assert_equal(c.SWAP_FLAG["23, discard"], c.SWAP_FLAG["prefer, discard"] + bit.lshift(23, c.SWAP_FLAG["prio_shift"]));
  },
  test_swap_fail = function() {
    var ex = "PERM"; // EPERM if not root
    if( S.geteuid() == 0 ) { ex = "INVAL"; }
    var ok, err = S.swapon("/dev/null", "23, discard");
    if( ! ok && err.NOSYS ) { return; } // Android does not implement swap, so skip test
    assert(! ok && err[ex], "should not create swap on /dev/null");
    ok, err = S.swapoff("/dev/null");
    assert(! ok && err[ex], "no swap on /dev/null");
  },
  // TODO need mkswap to test success
};
} // exclude rump

return test;

}

return {init = init};

