// generate C test file to check ABI

package.path = "./?.ljs;";

var abi = require ("syscall.abi");

var S;

if( abi.os == "netbsd" ) { // testing natively
  S = require ("syscall");
} else { // test using rump
  S = require ("syscall.rump.init").init();
}

var version = require ("syscall.netbsd.version").version;

abi = S.abi; //DADBUG redefinition
var types = S.types;
var t, ctypes, s = types.t, types.ctypes, types.s;
var c = S.c;

for( k, v in pairs(ctypes) ) {
  var kk = string.gsub(k, "_netbsd_", "");
  if( kk != k ) { ctypes[kk], ctypes[k] = v, null; }
}
 
var ffi = require ("ffi");

var reflect = require ("include.ffi-reflect.reflect");

// internal only
c.errornames = null;

// fixups
c.STD = null;
c.EXIT = null;

// TODO this should be in system headers surely? (F_ULOCK, F_LOCK etc)
c.LOCKF = null;

for( k, v in pairs(c.IOCTL) ) { if( type(v) == "table" ) { c.IOCTL[k] = v.number; } }

c.AF.DECnet = c.AF.DECNET;
c.AF.DECNET = null;

c.R_OK = c.OK.R;
c.W_OK = c.OK.W;
c.F_OK = c.OK.F;
c.X_OK = c.OK.X;
c.OK = null;

c.SIGACT = null; // TODO cast correctly instead, giving warning
c.CHFLAGS.NODUMP = null; // alias
c.CHFLAGS.IMMUTABLE = null; // alias
c.CHFLAGS.APPEND = null; // alias
c.CHFLAGS.OPAQUE = null; // alias

c.KTRFLAG = {DESCEND = c.KTROP.DESCEND};
c.KTROP.DESCEND = null;

c.KTRFAC.V0 = null; // no underscore and lower case
c.KTRFAC.V1 = null;
c.KTRFAC.V2 = null;

c.W.WCLONE = null; // underscore in name, changed
c.W.WALL   = null; // underscore in name, changed

// the #define and the name used are different, very odd
c.KERN_PIPE.MAXLOANKVASZ = null;

// v7 only
c.CTLFLAG.UNSIGNED = null;

// complex rename
for( k, v in pairs(c.FSYNC) ) {
  c.FSYNC['F' .. k .. 'SYNC'] = v;
  c.FSYNC[k] = null;
}

// these are Linux names TODO are there actually BSD names?
ctypes["struct ethhdr"] = null;
ctypes["struct iphdr"] = null;
ctypes["struct udphdr"] = null;

// compat type may be missing
ctypes["struct compat_60_ptmget"] = null;

// not all syscalls always defined, some conditional, some very new
c.SYS.compat_10_oshmsys = null;
c.SYS.compat_10_omsgsys = null;
c.SYS.compat_10_osemsys = null;
c.SYS.compat_60_sa_enable = null;
c.SYS.compat_60_sa_stacks = null;
c.SYS.compat_60_sa_setconcurrency = null;
c.SYS.compat_60_sa_preempt = null;
c.SYS.compat_60_sa_yield = null;
c.SYS.compat_60_sa_register = null;
c.SYS.___lwp_park60 = null;
c.SYS.sendmmsg = null;
c.SYS.recvmmsg = null;
c.SYS.compat_60__lwp_park = null;
c.SYS.clock_nanosleep = null;

// not really in earlier versions
if( version < 7 ) {
  ctypes["struct mmsghdr"] = null;
}

print ([=[
/* this code is generated by ctest-netbsd.lua */

#define _BSD_SOURCE
#define _NETBSD_SOURCE
#define _INCOMPLETE_XOPEN_C063

#include <stddef.h>
#include <stdio.h>

#include <sys/sched.h>
#include <sys/termios.h>
#include <sys/unistd.h>
#include <sys/dirent.h>
#include <sys/time.h>
#include <sys/poll.h>
#include <sys/signal.h>
#include <sys/fcntl.h>
#include <sys/errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/utsname.h>
#include <sys/resource.h>
#include <sys/un.h>
#include <sys/mman.h>
#include <sys/xattr.h>
#include <sys/mount.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/reboot.h>
#include <sys/module.h>
#include <sys/syscall.h>
#include <sys/sysctl.h>
#include <sys/statvfs.h>
#include <sys/event.h>
#include <sys/ktrace.h>
#include <sys/extattr.h>
#include <sys/pipe.h>
#include <sys/aio.h>
#include <net/if.h>
#include <net/if_ether.h>
#include <net/if_bridgevar.h>
#include <net/route.h>
#include <net/bpf.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet6/in6.h>
#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>
#include <ufs/ufs/ufsmount.h>
#include <fs/ptyfs/ptyfs.h>
#include <fs/tmpfs/tmpfs_args.h>
#include <miscfs/procfs/procfs.h>

int ret = 0;

void sassert(int a, int b, char *n) {
  if (a != b) {
    printf("error with %s: %d (0x%x) != %d (0x%x)\n", n, a, a, b, b);
    ret = 1;
  }
}

void sassert_u64(unsigned long long a, unsigned long long b, char *n) {
  if (a != b) {
    printf("error with %s: %llu (0x%llx) != %llu (0x%llx)\n", n, (unsigned long long)a, (unsigned long long)a, (unsigned long long)b, (unsigned long long)b);
    ret = 1;
  }
}

int main(int argc, char **argv) {
]=]);

var ignore_offsets = {
  sig = "true", // sigset_t renamed TODO rename back
};

// iterate over S.ctypes
for( k, v in pairs(ctypes) ) {
  print("sassert(sizeof(" .. k .. "), " .. ffi.sizeof(v) .. ', "' .. k .. '");');
  // check offset of struct fields
  var refct = reflect.typeof(v);
  if( refct.what == "struct" ) {
    for( r in refct->members() ) {
      var name = r.name;
      // bit hacky - TODO fix these issues
      if( ignore_offsets[name] ) { name = null; }
      if( name ) {
        print("sassert(offsetof(" .. k .. "," .. name .. "), " .. ffi.offsetof(v, name) .. ', " offset of ' .. name .. ' in ' .. k .. '");');
      }
    }
  }
}

// test all the constants

// renamed ones
var nm = {
  E = "E",
  SIG = "SIG",
  STD = "STD",
  MODE = "S_I",
  MSYNC = "MS_",
  W = "W",
  POLL = "POLL",
  S_I = "S_I",
  LFLAG = "",
  IFLAG = "",
  OFLAG = "",
  CFLAG = "",
  CC = "",
  IOCTL = "",
  B = "B",
  AT_FDCWD = "AT_",
  FCNTL_LOCK = "F_",
  LOCKF = "F_",
  SIGACT = "SIG_",
  SIGPM = "SIG_",
  OPIPE = "O_",
  MSYNC = "MS_",
  CHFLAGS = "",
  PC = "_PC_",
  FSYNC = "",
  TCSA = "TCSA",
  TCFLUSH = "TC",
  TCFLOW = "TC",
  VFSMNT = "MNT_",
  BRDG = "BRDG",
};

for( k, v in pairs(c) ) {
  if( type(v) == "number" ) {
    print("sassert(" .. k .. ", " .. v .. ', "' .. k .. '");');
  } else if( type(v) == "table" ) {
    for( k2, v2 in pairs(v) ) {
      var name = nm[k] || k .. "_";
      if( type(v2) != "function" ) {
        if( type(v2) == "cdata" && ffi.sizeof(v2) == 8 ) {
         print("sassert_u64(" .. name .. k2 .. ", " .. tostring(v2)  .. ', "' .. name .. k2 .. '");');
        } else {
         print("sassert(" .. name .. k2 .. ", " .. tostring(tonumber(v2))  .. ', "' .. name .. k2 .. '");');
        }
      }
    }
  }
}

print ([=[
return ret;
}
]=]);

