// test suite for ljsyscall.

// TODO stop using globals for tests

arg = arg || {};

// only use this installation for tests
package.path = "./?.ljs;";

var strict = require ("include.strict.strict");

var helpers = require ("syscall.helpers");

var assert = helpers.assert;

var S;
var tmpabi;
var short;

if( arg[1] == "rumplinuxshort" ) { short, arg[1] = true, "rumplinux"; } // don't run Linux tests

if( arg[1] == "rump" || arg[1] == "rumplinux" ) {
  tmpabi = require ("syscall.abi");
  if( arg[1] == "rumplinux" ) {
    tmpabi.types = "linux"; // monkeypatch
  }
  var modules = {"kern.tty", "dev", "net", "fs.tmpfs", "fs.kernfs", "fs.ptyfs",
                   "net.net", "net.local", "net.netinet", "net.netinet6", "vfs"};
  S = require ("syscall.rump.init").init(modules);
  table.remove(arg, 1);
} else {
  S = require ("syscall");
}

var abi = S.abi;
var types = S.types;
var t, pt, s = types.t, types.pt, types.s;
var c = S.c;
var util = S.util;

if( S.__rump && abi.types == "linux" ) { // Linux rump ABI cannot do much, so switch from root so it does not try
  assert(S.rump.newlwp(S.getpid()));
  assert(S.chmod("/", "0777"));
  assert(S.chmod("/dev/zero", "0666"));
  var lwp1 = assert(S.rump.curlwp());
  assert(S.rump.rfork("CFDG"));
  S.rump.i_know_what_i_am_doing_sysent_usenative(); // switch to netBSD syscalls in this thread
  var data = t.tmpfs_args({ta_version = 1, ta_nodes_max=1000, ta_size_max=104857600, ta_root_mode = helpers.octal("0777")});
  assert(S.mount("tmpfs", "/tmp", 0, data, s.tmpfs_args));
  assert(S.mkdir("/dev/pts", "0555"));
  data = t.ptyfs_args({version = 2, gid = 0, mode = helpers.octal("0555")});
  assert(S.mount("ptyfs", "/dev/pts", 0, data, s.ptyfs_args));
  S.rump.switchlwp(lwp1);
  var ok, err = S.mount("tmpfs", "/tmp", 0, data, s.tmpfs_args);
  assert(err, "mount should fail as not in NetBSD compat now");
  assert(S.chdir("/tmp"));
  // TODO can run as non root
  //assert(S.rump.rfork("CFDG"))
  //assert(S.setuid(100))
  //assert(S.seteuid(100))
} else if( (S.__rump || abi.xen) && S.geteuid() == 0 ) { // some initial setup for non-Linux rump
  assert(S.rump.newlwp(S.getpid()));
  var octal = helpers.octal;
  var data = {ta_version = 1, ta_nodes_max=1000, ta_size_max=104857600, ta_root_mode = octal("0777")};
  assert(S.mount("tmpfs", "/tmp", 0, data));
  assert(S.chdir("/tmp"));
  assert(S.mkdir("/dev/pts", "0555"));
  assert(S.mount("ptyfs", "/dev/pts", 0, {version = 2, gid = 0, mode = octal("0320")}));
}

var bit = require ("syscall.bit");
var ffi = require ("ffi");

if( ! S.__rump ) {
  var test = require("test." .. abi.os).init(S); // OS specific tests
  for( k, v in pairs(test) ) { _G["test_" .. k] = v; }
  if( abi.bsd ) {
    test = require("test.bsd").init(S); // BSD tests
    for( k, v in pairs(test) ) { _G["test_" .. k] = v; }
  }
}
if( S.__rump ) {
  if( abi.types == "linux" && ! short ) { // add linux tests unless running short tests
    var test = require("test.linux").init(S); // OS specific tests
    for( k, v in pairs(test) ) { _G["test_" .. k] = v; }
  } else if( abi.types == "netbsd" ) {
    var test = require("test.netbsd").init(S); // OS specific tests
    for( k, v in pairs(test) ) { _G["test_" .. k] = v; }
    test = require("test.bsd").init(S); // BSD tests
    for( k, v in pairs(test) ) { _G["test_" .. k] = v; }
  }
  var test = require ("test.rump").init(S); // rump specific tests
  for( k, v in pairs(test) ) { _G["test_" .. k] = v; }
}

var function fork_assert(cond, str) { // if we have forked we need to fail in main thread not fork
  if( ! cond ) {
    print(tostring(str));
    print(debug.traceback());
    os.exit(1);
  }
  return cond, str;
}

var function assert_equal(...) {
  collectgarbage("collect"); // force gc, to test for bugs
  return assert_equals(...);
}

USE_EXPECTED_ACTUAL_IN_ASSERT_EQUALS = true; // strict wants this to be set
var luaunit = require ("include.luaunit.luaunit");

var sysfile = debug.getinfo(S.open).source;
var cov = {active = {}, cov = {}};

// TODO no longer working as more files now
var function coverage(event, line) {
  var ss = debug.getinfo(2, "nLlS");
  if( ss.source != sysfile ) { return; }
  if( event == "line" ) {
    cov.cov[line] = true;
  } else if( event == "call" ) {
    if( ss.activelines ) { for( k, _ in pairs(ss.activelines) ) { cov.active[k] = true; } }
  }
}

if( arg[1] == "coverage" ) { debug.sethook(coverage, "lc"); }

// TODO make locals in each test
var teststring = "this is a test string";
var size = 512;
var buf = t.buffer(size);

var tmpfile = "XXXXYYYYZZZ4521" .. S.getpid();
var tmpfile2 = "./666666DDDDDFFFF" .. S.getpid();
var tmpfile3 = "MMMMMTTTTGGG" .. S.getpid();
var tmpdir = "FFFFGGGGHHH123" .. S.getpid();
var longdir = "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" .. S.getpid();
var efile = "./tmpexXXYYY" .. S.getpid() .. ".sh";
var largeval = math.pow(2, 33); // larger than 2^32 for testing
var mqname = "ljsyscallXXYYZZ" .. S.getpid();

var clean = function() {
  S.rmdir(tmpfile);
  S.unlink(tmpfile);
  S.unlink(tmpfile2);
  S.unlink(tmpfile3);
  S.rmdir(tmpdir);
  S.rmdir(longdir);
  S.unlink(efile);
};

// type tests use reflection TODO move to seperate test file
var ok, reflect = null, null;
if( ! ffi.abi("64bit") || "x64" == ffi.arch ) { // ffi-reflect does not support the new 64bit abi (LuaJIT's LJ_GC64 mode)
  ok, reflect = pcall(require, "include.ffi-reflect.reflect");
}
if( ok ) {
test_types_reflect = {
  test_allocate = function() { // create an element of every ctype
    for( k, v in pairs(t) ) {
      if( type(v) == "cdata" ) {
        var x;
        if( reflect.typeof(v).vla ) {
          x = v(1);
        } else {
          x = v();
        }
      }
    }
  },
  test_meta = function() { // read every __index metatype; unfortunately most are functions, so coverage not that useful yet
    for( k, v in pairs(t) ) {
      if( type(v) == "cdata" ) {
        var x;
        if( reflect.typeof(v).vla ) {
          x = v(1);
        } else {
          x = v();
        }
        var mt = reflect.getmetatable(x);
        if( mt && type(mt.__index) == "table" ) {
          for( kk, _ in pairs(mt.__index) ) {
            var r = x[kk]; // read value via metatable
            if( mt.__newindex && type(mt.__newindex) == "table" && mt.__newindex[kk] ) { x[kk] = r; } // write, unlikely to actually test anything
          }
        }
        if( mt && mt.index ) {
          for( kk, _ in pairs(mt.index) ) {
            var r = x[kk]; // read value via metatable
            if( mt.newindex && mt.newindex[kk] ) { x[kk] = r; }
          }
        }
      }
    }
  },
  test_invalid_index_newindex = function() {
    var function index(x, k) { return x[k]; }
    var function newindex(x, k) { x[k] = x[k]; } // dont know type so assign to self
    var badindex = "_____this_index_is_not_found";
    var allok = true;
    for( k, v in pairs(t) ) {
      if( type(v) == "cdata" ) {
        var x;
        if( reflect.typeof(v).vla ) {
          x = v(1);
        } else {
          x = v();
        }
        var mt = reflect.getmetatable(x);
        if( mt ) {
          var ok, err = pcall(index, x, badindex);
          if( ok ) { print("index error on " .. k); allok = false; }
          ok, err = pcall(newindex, x, badindex);
          if( ok ) { print("newindex error on " .. k); allok = false; }
        }
      }
    }
    assert_equal(allok, true);
  },
  test_length = function() {
    var nolen = {fd = true, error = true, mqd = true, timer = true}; // internal use
    var function len(x) { return #x; }
    var allok = true;
    for( k, v in pairs(t) ) {
      if( type(v) == "cdata" ) {
        if( ! reflect.typeof(v).vla ) {
          var x = v();
          var mt = reflect.getmetatable(x);
          var ok, err = pcall(len, x);
          if( mt && ! ok && ! nolen[k] ) {
            print("no len on " .. k);
            allok = false;
            }
        }
      }
    }
    assert_equal(allok, true);
  },
  test_tostring = function() {
    for( k, v in pairs(t) ) {
      if( type(v) == "cdata" ) {
        var x, s;
        if( reflect.typeof(v).vla ) {
          x = v(1);
          s = tostring(v);
        } else {
          x = v();
          s = tostring(v);
        }
      }
    }
  },
};
}

test_basic = {
  test_b64 = function() {
    var h, l = bit.i6432(-1);
    assert_equal(h, bit.tobit(0xffffffff));
    assert_equal(l, bit.tobit(0xffffffff));
    h, l = bit.i6432(0xfffbffff);
    assert_equal(h, bit.tobit(0x0));
    assert_equal(l, bit.tobit(0xfffbffff));
  },
  test_bor64 = function() {
    var a, b = t.int64(0x10ffff0000), t.int64(0x020000ffff);
    assert_equal(tonumber(bit.bor64(a, b)), 0x12ffffffff);
    assert_equal(tonumber(bit.bor64(a, b, a, b)), 0x12ffffffff);
  },
  test_band64 = function() {
    var a, b = t.int64(0x12ffffffff), t.int64(0x020000ffff);
    assert_equal(tonumber(bit.band64(a, b)), 0x020000ffff);
    assert_equal(tonumber(bit.band64(a, b, a, b)), 0x020000ffff);
  },
  test_lshift64 = function() {
    assert_equal(tonumber(bit.lshift64(1, 0)), 1);
    assert_equal(tonumber(bit.lshift64(1, 1)), 2);
    assert_equal(tonumber(bit.lshift64(0xffffffff, 4)), 0xffffffff0);
    assert_equal(tonumber(bit.lshift64(0xffffffff, 8)), 0xffffffff00);
    assert_equal(tonumber(bit.lshift64(1, 32)), 0x100000000);
    assert_equal(tonumber(bit.lshift64(1, 36)), 0x1000000000);
  },
  test_rshift64 = function() {
    assert_equal(tonumber(bit.rshift64(1, 0)), 1);
    assert_equal(tonumber(bit.rshift64(2, 1)), 1);
    assert_equal(tonumber(bit.rshift64(0xffffffff0, 4)), 0xffffffff);
    assert_equal(tonumber(bit.rshift64(0xffffffff00, 8)), 0xffffffff);
    assert_equal(tonumber(bit.rshift64(0x100000000, 32)), 1);
    assert_equal(tonumber(bit.rshift64(0x1000000000, 36)), 1);
  },
  test_major_minor = function() {
    var d = t.device(2, 3);
    assert_equal(d.major, 2);
    assert_equal(d.minor, 3);
  },
  test_fd_nums = function() { // TODO should also test on the version from types.lua
    assert_equal(t.fd(18)->nogc()->getfd(), 18, "should be able to trivially create fd");
  },
  test_error_string = function() {
    var err = t.error(c.E.NOENT);
    assert(tostring(err) == "No such file or directory", "should get correct string error message");
  },
  test_missing_error_string = function() {
    var err = t.error(0);
    assert(! tostring(err), "should get missing error message");
  },
  test_no_missing_error_strings = function() {
    var allok = true;
    for( k, v in pairs(c.E) ) {
      var msg = t.error(v);
      if( ! msg ) {
        print("no error message for " .. k);
        allok = false;
      }
    }
    assert(allok, "missing error message");
  },
  test_booltoc = function() {
    assert_equal(helpers.booltoc(true), 1);
    assert_equal(helpers.booltoc[true], 1);
    assert_equal(helpers.booltoc[0], 0);
  },
  test_constants = function() {
    assert_equal(c.O.CREAT, c.O.creat); // test can use upper and lower case
    assert_equal(c.O.CREAT, c.O.Creat); // test can use mixed case
    assert(rawget(c.O, "CREAT"));
    assert(! rawget(c.O, "creat"));
    assert(rawget(getmetatable(c.O).__index, "creat")); // a little implementation dependent
  },
  test_at_flags = function() {
    if( ! c.AT_FDCWD ) { return; } // OSX does no support any *at functions
    assert_equal(c.AT_FDCWD[null], c.AT_FDCWD.FDCWD); // nil returns current dir
    assert_equal(c.AT_FDCWD.fdcwd, c.AT_FDCWD.FDCWD);
    var fd = t.fd(-1);
    assert_equal(c.AT_FDCWD[fd], -1);
    assert_equal(c.AT_FDCWD[33], 33);
  },
  test_multiflags = function() {
    assert_equal(c.O["creat, excl, rdwr"], c.O("creat", "excl", "rdwr")); // function form takes multiple arguments
  },
  test_multiflags_negation = function() {
    assert_equal(c.O("creat", "~creat"), 0); // negating flag should clear
    assert_equal(c.O("creat, excl", "~creat", "rdwr", "~rdwr"), c.O.EXCL);
  },
};

test_open_close = {
  teardown = clean,
  test_open_nofile = function() {
    var fd, err = S.open("/tmp/file/does/not/exist", "rdonly");
    assert(err, "expected open to fail on file not found");
    assert(err.NOENT, "expect NOENT from open non existent file");
  },
  test_close_invalid_fd = function() {
    var ok, err = S.close(127);
    assert(err, "expected to fail on close invalid fd");
    assert_equal(err.errno, c.E.BADF, "expect BADF from invalid numberic fd");
  },
  test_open_valid = function() {
    var fd = assert(S.open("/dev/null", "rdonly"));
    var fd2 = assert(S.open("/dev/zero", "RDONLY"));
    assert_equal(fd2->getfd(), fd->getfd() + 1);
    assert(fd->close());
    assert(fd2->close());
  },
  test_fd_cleared_on_close = function() {
    var fd = assert(S.open("/dev/null", "rdonly"));
    assert(fd->close());
    var fd2 = assert(S.open("/dev/zero")); // reuses same fd
    var ok, err = assert(fd->close()); // this should not close fd again, but no error as does nothing
    assert(fd2->close()); // this should succeed
  },
  test_double_close = function() {
    var fd = assert(S.open("/dev/null", "rdonly"));
    var fileno = fd->getfd();
    assert(fd->close());
    var err;
    fd, err = S.close(fileno);
    assert(! fd, "expected to fail on close already closed fd");
    assert(err && err.badf, "expect BADF from invalid numberic fd");
  },
  test_access = function() {
    assert(S.access("/dev/null", "r"), "expect access to say can read /dev/null");
    assert(S.access("/dev/null", c.OK.R), "expect access to say can read /dev/null");
    assert(S.access("/dev/null", "w"), "expect access to say can write /dev/null");
  },
  test_fd_gc = function() {
    var fd = assert(S.open("/dev/null", "rdonly"));
    var fileno = fd->getfd();
    fd = null;
    collectgarbage("collect");
    var _, err = S.read(fileno, buf, size);
    assert(err, "should not be able to read from fd after gc");
    assert(err.BADF, "expect BADF from already closed fd");
  },
  test_fd_nogc = function() {
    var fd = assert(S.open("/dev/zero", "RDONLY"));
    var fileno = fd->getfd();
    fd->nogc();
    fd = null;
    collectgarbage("collect");
    var n = assert(S.read(fileno, buf, size));
    assert(S.close(fileno));
  },
  test_umask = function() { // TODO also test effect on permissions
    var mask;
    mask = S.umask("WGRP, WOTH");
    mask = S.umask("WGRP, WOTH");
    assert_equal(mask, c.MODE.WGRP + c.MODE.WOTH, "umask not set correctly");
  },
};

test_read_write = {
  teardown = clean,
  test_read = function() {
    var fd = assert(S.open("/dev/zero"));
    var size = 64;
    var buf = t.buffer(size);
    for( i = 0, size - 1 ) { buf[i] = 255; }
    var n = assert(fd->read(buf, size));
    assert(n >= 0, "should not get error reading from /dev/zero");
    assert_equal(n, size);
    for( i = 0, size - 1 ) { assert(buf[i] == 0, "should read zeroes from /dev/zero"); }
    assert(fd->close());
  },
  test_read_to_string = function() {
    var fd = assert(S.open("/dev/zero"));
    var str = assert(fd->read(null, 10));
    assert_equal(#str, 10, "string returned from read should be length 10");
    assert(fd->close());
  },
  test_write_ro = function() {
    var fd = assert(S.open("/dev/zero"));
    var n, err = fd->write(buf, size);
    assert(err, "should not be able to write to file opened read only");
    assert(err.BADF, "expect BADF when writing read only file");
    assert(fd->close());
  },
  test_write = function() {
    var fd = assert(S.open("/dev/zero", "RDWR"));
    var n = assert(fd->write(buf, size));
    assert(n >= 0, "should not get error writing to /dev/zero");
    assert_equal(n, size, "should not get truncated write to /dev/zero");
    assert(fd->close());
  },
  test_write_string = function() {
    var fd = assert(S.open("/dev/zero", "RDWR"));
    var n = assert(fd->write(teststring));
    assert_equal(n, #teststring, "write on a string should write out its length");
    assert(fd->close());
  },
  test_pread_pwrite = function() {
    var fd = assert(S.open("/dev/zero", "RDWR"));
    var offset = 1;
    var n;
    n = assert(fd->pread(buf, size, offset));
    assert_equal(n, size, "should not get truncated pread on /dev/zero");
    n = assert(fd->pwrite(buf, size, offset));
    assert_equal(n, size, "should not get truncated pwrite on /dev/zero");
    assert(fd->close());
  },
  test_readv_writev = function() {
    var fd = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    var n = assert(fd->writev({"test", "ing", "writev"}));
    assert_equal(n, 13, "expect length 13");
    assert(fd->seek());
    var b1, b2, b3 = t.buffer(6), t.buffer(4), t.buffer(3);
    n = assert(fd->readv({b1, b2, b3}));
    assert_equal(n, 13, "expect length 13");
    assert_equal(ffi.string(b1, 6), "testin");
    assert_equal(ffi.string(b2, 4), "gwri");
    assert_equal(ffi.string(b3, 3), "tev");
    assert(S.unlink(tmpfile));
  },
  test_preadv_pwritev = function() {
    if( ! S.preadv ) { error ("skipped"); }
    var offset = 10;
    var fd = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    var n = assert(fd->pwritev({"test", "ing", "writev"}, offset));
    assert_equal(n, 13, "expect length 13");
    var b1, b2, b3 = t.buffer(6), t.buffer(4), t.buffer(3);
    n = assert(fd->preadv({b1, b2, b3}, offset));
    assert_equal(n, 13, "expect length 13");
    assert_equal(ffi.string(b1, 6), "testin");
    assert_equal(ffi.string(b2, 4), "gwri");
    assert_equal(ffi.string(b3, 3), "tev");
    assert(fd->seek(offset));
    n = assert(fd->readv({b1, b2, b3}));
    assert_equal(n, 13, "expect length 13");
    assert_equal(ffi.string(b1, 6), "testin");
    assert_equal(ffi.string(b2, 4), "gwri");
    assert_equal(ffi.string(b3, 3), "tev");
    assert(S.unlink(tmpfile));
  },
};

test_poll_select = {
  test_poll = function() {
    var a, b = assert(S.socketpair("unix", "stream"));
    var pev = t.pollfds({{fd = a, events = "in"}});
    var p = assert(S.poll(pev, 0));
    assert_equal(p, 0); // no events
    for( k, v in ipairs(pev) ) {
      assert_equal(v.fd, a->getfd());
      assert_equal(v.revents, 0);
    }
    assert(b->write(teststring));
    p = assert(S.poll(pev, 0));
    assert_equal(p, 1); // 1 event
    for( k, v in ipairs(pev) ) {
      assert_equal(v.fd, a->getfd());
      assert(v.IN, "one IN event now");
    }
    assert(a->read());
    assert(b->close());
    assert(a->close());
  },
  test_select = function() {
    var a, b = assert(S.socketpair("unix", "stream"));
    var sel = assert(S.select({readfds = {a, b}}, 0));
    assert_equal(sel.count, 0);
    assert(b->write(teststring));
    sel = assert(S.select({readfds = {a, b}}, 0));
    assert_equal(sel.count, 1);
    assert(b->close());
    assert(a->close());
  },
  test_pselect = function() {
    var a, b = assert(S.socketpair("unix", "stream"));
    var sel = assert(S.pselect({readfds = {a, b}}, 0, "alrm"));
    assert_equal(sel.count, 0);
    assert(b->write(teststring));
    sel = assert(S.pselect({readfds = {a, b}}, 0, "alrm"));
    assert_equal(sel.count, 1);
    assert(b->close());
    assert(a->close());
  },
};

test_address_names = {
  test_ipv4_names = function() {
    assert_equal(tostring(t.in_addr("127.0.0.1")), "127.0.0.1");
    assert_equal(tostring(t.in_addr("loopback")), "127.0.0.1");
    assert_equal(tostring(t.in_addr("1.2.3.4")), "1.2.3.4");
    assert_equal(tostring(t.in_addr("255.255.255.255")), "255.255.255.255");
    assert_equal(tostring(t.in_addr("broadcast")), "255.255.255.255");
  },
  test_ipv6_names = function() {
    var sa = assert(t.sockaddr_in6(1234, "2002::4:5"));
    assert_equal(sa.port, 1234, "want same port back");
    assert_equal(tostring(sa.sin6_addr), "2002::4:5", "expect same address back");
    sa = assert(t.sockaddr_in6(1234, "loopback"));
    assert_equal(sa.port, 1234, "want same port back");
    assert_equal(tostring(sa.sin6_addr), "::1", "expect same address back");
  },
  test_inet_name = function() {
    var addr = t.in_addr("127.0.0.1");
    assert(addr, "expect to get valid address");
    assert_equal(tostring(addr), "127.0.0.1");
  },
  test_inet_name6 = function() {
    for( _, a in ipairs ({"::1", "::2:0:0:0", "0:0:0:2::", "1::"}) ) {
      var addr = t.in6_addr(a);
      assert(addr, "expect to get valid address");
      assert_equal(tostring(addr), a);
    }
  },
  test_util_netmask_broadcast = function() {
    var addr = t.in_addr("0.0.0.0");
    var nb = addr->get_mask_bcast(32);
    assert_equal(tostring(nb.broadcast), "0.0.0.0");
    assert_equal(tostring(nb.netmask), "0.0.0.0");
    addr = t.in_addr("10.10.20.1");
    nb = addr->get_mask_bcast(24);
    assert_equal(tostring(nb.broadcast), "10.10.20.255");
    assert_equal(tostring(nb.netmask), "0.0.0.255");
    addr = t.in_addr("0.0.0.0");
    nb = addr->get_mask_bcast(0);
    assert_equal(tostring(nb.broadcast), "255.255.255.255");
    assert_equal(tostring(nb.netmask), "255.255.255.255");
  },
};

test_file_operations = {
  teardown = clean,
  test_dup = function() {
    var fd = assert(S.open("/dev/zero"));
    var fd2 = assert(fd->dup());
    assert(fd2->close());
    assert(fd->close());
  },
  test_dup2 = function() {
    if( ! S.dup2 ) { error ("skipped"); }
    var fd = assert(S.open("/dev/zero"));
    var fd2 = assert(fd->dup2(17));
    assert_equal(fd2->getfd(), 17, "dup2 should set file id as specified");
    assert(fd2->close());
    assert(fd->close());
  },
  test_dup3 = function() {
    if( ! S.dup3 ) { error ("skipped"); }
    var fd = assert(S.open("/dev/zero"));
    var fd2 = assert(fd->dup3(17));
    assert_equal(fd2->getfd(), 17, "dup3 should set file id as specified");
    assert(fd2->close());
    assert(fd->close());
  },
  test_link = function() {
    var fd = assert(S.creat(tmpfile, "0755"));
    assert(S.link(tmpfile, tmpfile2));
    assert(S.unlink(tmpfile2));
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_symlink = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(S.symlink(tmpfile, tmpfile2));
    var s = assert(S.readlink(tmpfile2));
    assert_equal(s, tmpfile, "should be able to read symlink");
    assert(S.unlink(tmpfile2));
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_sync = function() {
    S.sync(); // cannot fail...
  },
  test_syncfs = function() {
    if( ! S.syncfs ) { error ("skipped"); }
    var fd = S.open("/dev/null");
    assert(fd->syncfs());
    assert(fd->close());
  }, 
  test_fchmod = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(fd->fchmod("RUSR, WUSR"));
    var st = fd->stat();
    assert_equal(bit.band(st.mode, c.S_I["RUSR, WUSR"]), c.S_I["RUSR, WUSR"]);
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_chmod = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(S.chmod(tmpfile, "RUSR, WUSR"));
    assert(S.access(tmpfile, "rw"));
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_chown_root = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(S.chown(tmpfile, 66, 55));
    var stat = S.stat(tmpfile);
    assert_equal(stat.uid, 66, "expect uid changed");
    assert_equal(stat.gid, 55, "expect gid changed");
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_chown = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(S.chown(tmpfile)); // unchanged
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_fchown_root = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(fd->chown(66, 55));
    var stat = fd->stat();
    assert_equal(stat.uid, 66, "expect uid changed");
    assert_equal(stat.gid, 55, "expect gid changed");
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_lchown_root = function() {
    assert(S.symlink("/dev/zero", tmpfile));
    assert(S.lchown(tmpfile, 66, 55));
    var stat = S.lstat(tmpfile);
    assert_equal(stat.uid, 66, "expect uid changed");
    assert_equal(stat.gid, 55, "expect gid changed");
    assert(S.unlink(tmpfile));
  },
  test_fsync = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(fd->fsync());
    assert(fd->sync()); // synonym
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_fdatasync = function() {
    if( ! S.fdatasync ) { error ("skipped"); }
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(fd->fdatasync());
    assert(fd->datasync()); // synonym
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_seek = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    var offset = 1;
    var n;
    n = assert(fd->lseek(offset, "set"));
    assert_equal(n, offset, "seek should position at set position");
    n = assert(fd->lseek(offset, "cur"));
    assert_equal(n, offset + offset, "seek should position at set position");
    var t = fd->tell();
    assert_equal(t, n, "tell should return current offset");
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_seek_error = function() {
    var s, err = S.lseek(-1, 0, "set");
    assert(! s, "seek should fail with invalid fd");
    assert(err.badf, "bad file descriptor");
  },
  test_mkdir_rmdir = function() {
    assert(S.mkdir(tmpdir, "RWXU"));
    assert(S.rmdir(tmpdir));
  },
  test_chdir = function() {
    var cwd = assert(S.getcwd());
    assert(S.chdir("/"));
    var fd = assert(S.open("/"));
    assert(fd->fchdir());
    var nd = assert(S.getcwd());
    assert(nd == "/", "expect cwd to be /");
    assert(S.chdir(cwd)); // return to original directory
  },
  test_getcwd_long = function() {
    var cwd = assert(S.getcwd());
    var cwd2 = cwd;
    if( cwd2 == "/" ) { cwd2 = ""; }
    assert(S.mkdir(longdir, "RWXU"));
    assert(S.chdir(longdir));
    var nd = assert(S.getcwd());
    assert_equal(nd, cwd2 .. "/" .. longdir, "expect to get filename plus cwd");
    assert(S.chdir(cwd));
    assert(S.rmdir(longdir));
  },
  test_rename = function() {
    var fd = assert(S.creat(tmpfile, "rwxu"));
    assert(fd->close());
    assert(S.rename(tmpfile, tmpfile2));
    assert(! S.stat(tmpfile));
    assert(S.stat(tmpfile2));
    assert(S.unlink(tmpfile2));
  },
  test_stat_device = function() {
    var stat = assert(S.stat("/dev/zero"));
    assert_equal(stat.nlink, 1, "expect link count on /dev/zero to be 1");
    assert(stat.ischr, "expect /dev/zero to be a character device");
    assert_equal(stat.typename, "char device");
  },
  test_stat_file = function() {
    var fd = assert(S.creat(tmpfile, "rwxu"));
    assert(fd->write("four"));
    assert(fd->close());
    var stat = assert(S.stat(tmpfile));
    assert_equal(stat.size, 4, "expect size 4");
    assert(stat.isreg, "regular file");
    assert_equal(stat.typename, "file");
    assert(S.unlink(tmpfile));
  },
  test_stat_directory = function() {
    var fd = assert(S.open("/"));
    var stat = assert(fd->stat());
    assert(stat.isdir, "expect / to be a directory");
    assert_equal(stat.typename, "directory");
    assert(fd->close());
  },
  test_stat_symlink = function() {
    var fd = assert(S.creat(tmpfile2, "rwxu"));
    assert(fd->close());
    assert(S.symlink(tmpfile2, tmpfile));
    var stat = assert(S.stat(tmpfile));
    assert(stat.isreg, "expect file to be a regular file");
    assert(! stat.islnk, "should not be symlink");
    assert(S.unlink(tmpfile));
    assert(S.unlink(tmpfile2));
  },
  test_stat_aliases = function() {
    var st = S.stat(".");
    assert(st.access);
    assert(st.modification);
    assert(st.change);
    assert_equal(st.typename, "directory");
  },
  test_lstat_symlink = function() {
    var fd = assert(S.creat(tmpfile2, "rwxu"));
    assert(fd->close());
    assert(S.symlink(tmpfile2, tmpfile));
    var stat = assert(S.lstat(tmpfile));
    assert(stat.islnk, "expect lstat to stat the symlink");
    assert_equal(stat.typename, "link");
    assert(! stat.isreg, "lstat should find symlink not regular file");
    assert(S.unlink(tmpfile));
    assert(S.unlink(tmpfile2));
  },
  test_truncate = function() {
    var fd = assert(S.creat(tmpfile, "rwxu"));
    assert(fd->write(teststring));
    assert(fd->close());
    var stat = assert(S.stat(tmpfile));
    assert_equal(stat.size, #teststring, "expect to get size of written string");
    assert(S.truncate(tmpfile, 1));
    stat = assert(S.stat(tmpfile));
    assert_equal(stat.size, 1, "expect get truncated size");
    fd = assert(S.open(tmpfile, "RDWR"));
    assert(fd->truncate(1024));
    stat = assert(fd->stat());
    assert_equal(stat.size, 1024, "expect get truncated size");
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_mknod_chr_root = function() {
    assert(S.mknod(tmpfile, "fchr,0666", {1, 5}));
    var stat = assert(S.stat(tmpfile));
    assert(stat.ischr, "expect to be a character device");
    assert_equal(stat.rdev.major, 1);
    assert_equal(stat.rdev.minor, 5);
    assert_equal(stat.rdev.device, t.device(1, 5).device);
    assert(S.unlink(tmpfile));
  },
  test_copy_dev_zero_root = function() {
    var st = assert(S.stat("/dev/zero"));
    assert(S.mknod(tmpfile, "fchr,0666", st.rdev)); // copy device node
    var st2 = assert(S.stat(tmpfile));
    assert_equal(st2.rdev.dev, st.rdev.dev);
    var fd, err = S.open(tmpfile, "rdonly");
    if( ! fd && (err.OPNOTSUPP || err.NXIO) ) { error ("skipped"); } // FreeBSD, OpenBSD have restrictibe device policies
    assert(fd, err);
    assert(S.unlink(tmpfile));
    var buf = t.buffer(64);
    var n = assert(fd->read(buf, 64));
    assert_equal(n, 64);
    for( i = 0, 63 ) { assert_equal(buf[i], 0); }
    assert(fd->close());
  },
  test_mkfifo = function() {
    assert(S.mkfifo(tmpfile, "rwxu"));
    var stat = assert(S.stat(tmpfile));
    assert(stat.isfifo, "expect to be a fifo");
    assert(S.unlink(tmpfile));
  },
  test_futimens = function() {
    if( ! S.futimens ) { error ("skipped"); }
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(fd->futimens());
    var st1 = fd->stat();
    assert(fd->futimens({"omit", "omit"}));
    var st2 = fd->stat();
    assert_equal(st1.atime, st2.atime);
    assert_equal(st1.mtime, st2.mtime);
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_futimes = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    var st1 = fd->stat();
    assert(fd->futimes({100, 200}));
    var st2 = fd->stat();
    assert(st1.atime != st2.atime && st1.mtime != st2.mtime, "atime and mtime changed");
    assert_equal(st2.atime, 100);
    assert_equal(st2.mtime, 200);
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_utime = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    var st1 = fd->stat();
    assert(S.utime(tmpfile, 100, 200));
    var st2 = fd->stat();
    assert(st1.atime != st2.atime && st1.mtime != st2.mtime, "atime and mtime changed");
    assert_equal(st2.atime, 100);
    assert_equal(st2.mtime, 200);
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_utimes = function() {
    assert(util.createfile(tmpfile));
    var st1 = S.stat(tmpfile);
    assert(S.utimes(tmpfile, {100, 200}));
    var st2 = S.stat(tmpfile);
    assert(st1.atime != st2.atime && st1.mtime != st2.mtime, "atime and mtime changed");
    assert_equal(st2.atime, 100);
    assert_equal(st2.mtime, 200);
    assert(S.unlink(tmpfile));
  },
  test_lutimes = function() {
    assert(S.symlink("/no/such/file", tmpfile));
    var st1 = S.lstat(tmpfile);
    assert(S.lutimes(tmpfile, {100, 200}));
    var st2 = S.lstat(tmpfile);
    assert(st1.atime != st2.atime && st1.mtime != st2.mtime, "atime and mtime changed");
    assert_equal(st2.atime, 100);
    assert_equal(st2.mtime, 200);
    assert(S.unlink(tmpfile));
  },
};

test_file_operations_at = {
  teardown = clean,
  test_linkat = function() {
    if( ! S.linkat ) { error ("skipped"); }
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(S.linkat("fdcwd", tmpfile, "fdcwd", tmpfile2, "symlink_follow"));
    assert(S.unlink(tmpfile2));
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_openat = function() {
    if( ! S.openat ) { error ("skipped"); }
    var fd = assert(S.openat("fdcwd", tmpfile, "rdwr,creat", "rwxu"));
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_faccessat = function() {
    if( ! S.faccessat ) { error ("skipped"); }
    var fd = S.open("/dev");
    assert(fd->faccessat("null", "r"));
    assert(fd->faccessat("null", c.OK.R), "expect access to say can read /dev/null");
    assert(fd->faccessat("null", "w"), "expect access to say can write /dev/null");
    assert(! fd->faccessat("/dev/null", "x"), "expect access to say cannot execute /dev/null");
    assert(fd->close());
  },
  test_symlinkat = function() {
    if( ! (S.symlinkat && S.readlinkat) ) { error ("skipped"); }
    var dirfd = assert(S.open("."));
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(S.symlinkat(tmpfile, dirfd, tmpfile2));
    var s = assert(S.readlinkat(dirfd, tmpfile2));
    assert_equal(s, tmpfile, "should be able to read symlink");
    assert(S.unlink(tmpfile2));
    assert(S.unlink(tmpfile));
    assert(fd->close());
    assert(dirfd->close());
  },
  test_mkdirat_unlinkat = function() {
    if( ! (S.mkdirat && S.unlinkat) ) { error ("skipped"); }
    var fd = assert(S.open("."));
    assert(fd->mkdirat(tmpfile, "RWXU"));
    assert(fd->unlinkat(tmpfile, "removedir"));
    assert(! S.stat(tmpfile), "expect dir gone");
    assert(fd->close());
  },
  test_renameat = function() {
    if( ! S.renameat ) { error ("skipped"); }
    assert(util.writefile(tmpfile, teststring, "RWXU"));
    assert(S.renameat("fdcwd", tmpfile, "fdcwd", tmpfile2));
    assert(! S.stat(tmpfile));
    assert(S.stat(tmpfile2));
    assert(S.unlink(tmpfile2));
  },
  test_fstatat = function() {
    if( ! S.fstatat ) { error ("skipped"); }
    var fd = assert(S.open("."));
    assert(util.writefile(tmpfile, teststring, "RWXU"));
    var stat = assert(fd->fstatat(tmpfile));
    assert(stat.size == #teststring, "expect length to br what was written");
    assert(fd->close());
    assert(S.unlink(tmpfile));
  },
  test_fstatat_fdcwd = function() {
    if( ! S.fstatat ) { error ("skipped"); }
    assert(util.writefile(tmpfile, teststring, "RWXU"));
    var stat = assert(S.fstatat("fdcwd", tmpfile, null, "symlink_nofollow"));
    assert(stat.size == #teststring, "expect length to be what was written");
    assert(S.unlink(tmpfile));
  },
  test_fchmodat = function() {
    if( ! S.fchmodat ) { error ("skipped"); }
    var dirfd = assert(S.open("."));
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(dirfd->fchmodat(tmpfile, "RUSR, WUSR"));
    assert(S.access(tmpfile, "rw"));
    assert(S.unlink(tmpfile));
    assert(fd->close());
    assert(dirfd->close());
  },
  test_fchownat_root = function() {
    if( ! S.fchownat ) { error ("skipped"); }
    var dirfd = assert(S.open("."));
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(dirfd->fchownat(tmpfile, 66, 55, "symlink_nofollow"));
    var stat = S.stat(tmpfile);
    assert_equal(stat.uid, 66, "expect uid changed");
    assert_equal(stat.gid, 55, "expect gid changed");
    assert(S.unlink(tmpfile));
    assert(fd->close());
    assert(dirfd->close());
  },
  test_mkfifoat = function() {
    if( ! S.mkfifoat ) { error ("skipped"); }
    var fd = assert(S.open("."));
    assert(S.mkfifoat(fd, tmpfile, "rwxu"));
    var stat = assert(S.stat(tmpfile));
    assert(stat.isfifo, "expect to be a fifo");
    assert(fd->close());
    assert(S.unlink(tmpfile));
  },
  test_mknodat_root = function() {
    if( ! S.mknodat ) { error ("skipped"); }
    var fd = assert(S.open("."));
    assert(fd->mknodat(tmpfile, "fchr,0666", t.device(1, 5)));
    var stat = assert(S.stat(tmpfile));
    assert(stat.ischr, "expect to be a character device");
    assert_equal(stat.rdev.major, 1);
    assert_equal(stat.rdev.minor, 5);
    assert_equal(stat.rdev.device, t.device(1, 5).device);
    assert(fd->close());
    assert(S.unlink(tmpfile));
  },
};

test_directory_operations = {
  teardown = clean,
  test_getdents_dev = function() {
    var d = {};
    for( fn, f in util.ls("/dev") ) {
      d[fn] = true;
      if( fn == "zero" ) { assert(f.CHR, "/dev/zero is a character device"); }
      if( fn == "." ) {
        assert(f.DIR, ". is a directory");
        assert(! f.CHR, ". is not a character device");
        assert(! f.SOCK, ". is not a socket");
        assert(! f.LNK, ". is not a symlink");
      }
      if( fn == ".." ) { assert(f.DIR, ".. is a directory"); }
    }
    assert(d.zero, "expect to find /dev/zero");
  },
  test_getdents_error = function() {
    var fd = assert(S.open("/dev/zero", "RDONLY"));
    var d, err = S.getdents(fd);
    assert(err, "getdents should fail on /dev/zero");
    assert(fd->close());
  },
  test_getdents = function() {
    assert(S.mkdir(tmpdir, "rwxu"));
    assert(util.createfile(tmpdir .. "/file1"));
    assert(util.createfile(tmpdir .. "/file2"));
    // with only two files will get in one iteration of getdents
    var fd = assert(S.open(tmpdir, "directory, rdonly"));
    var f, count = {}, 0;
    for( d in fd->getdents() ) {
      f[d.name] = true;
      ++count    ;
    }
    assert_equal(count, 4);
    assert(f.file1 && f.file2 && f["."] && f[".."], "expect four files");
    assert(fd->close());
    assert(S.unlink(tmpdir .. "/file1"));
    assert(S.unlink(tmpdir .. "/file2"));
    assert(S.rmdir(tmpdir));
  },
  test_dents_stat_conversion = function() {
    var st = assert(S.stat("/dev/zero"));
    assert(st.ischr, "/dev/zero is a character device");
    for( fn, f in util.ls("/dev") ) {
      if( fn == "zero" ) {
        assert(f.CHR, "/dev/zero is a character device");
        assert_equal(st.todt, f.type);
        assert_equal(f.toif, st.type);
        assert_equal(st.todt, c.DT.CHR);
        assert_equal(f.toif, c.S_I.FCHR);
      }
    }
  },
  test_ls = function() {
    assert(S.mkdir(tmpdir, "rwxu"));
    assert(util.createfile(tmpdir .. "/file1"));
    assert(util.createfile(tmpdir .. "/file2"));
    var f, count = {}, 0;
    for( d in util.ls(tmpdir) ) {
      f[d] = true;
      ++count    ;
    }
    assert_equal(count, 4);
    assert(f.file1 && f.file2 && f["."] && f[".."], "expect four files");
    assert(S.unlink(tmpdir .. "/file1"));
    assert(S.unlink(tmpdir .. "/file2"));
    assert(S.rmdir(tmpdir));
  },
  test_ls_long = function() {
    assert(S.mkdir(tmpdir, "rwxu"));
    var num = 300; // sufficient to need more than one getdents call
    for( i = 1, num ) { assert(util.createfile(tmpdir .. "/file" .. i)); }
    var f, count = {}, 0;
    for( d in util.ls(tmpdir) ) {
      f[d] = true;
      ++count    ;
    }
    assert_equal(count, num + 2);
    for( i = 1, num ) { assert(f["file" .. i]); }
    for( i = 1, num ) { assert(S.unlink(tmpdir .. "/file" .. i)); }
    assert(S.rmdir(tmpdir));
  },
  test_dirtable = function() {
    assert(S.mkdir(tmpdir, "0777"));
    assert(util.createfile(tmpdir .. "/file"));
    var list = assert(util.dirtable(tmpdir, true));
    assert_equal(#list, 1, "one item in directory");
    assert_equal(list[1], "file", "one file called file");
    assert_equal(tostring(list), "file\n");
    assert(S.unlink(tmpdir .. "/file"));
    assert(S.rmdir(tmpdir));
  },
};

test_largefile = {
  teardown = clean,
  test_seek = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(S.unlink(tmpfile));
    var offset = 2**34; // should work with Lua numbers up to 56 bits, above that need explicit 64 bit type.
    var n;
    n = assert(fd->lseek(offset, "set"));
    assert_equal(n, offset, "seek should position at set position");
    n = assert(fd->lseek(offset, "cur"));
    assert_equal(n, offset + offset, "seek should position at set position");
    assert(fd->close());
  },
  test_seek_error = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    assert(S.unlink(tmpfile));
    var off, err = fd->lseek(-1, "cur");
    assert(! off && err.INVAL);
    assert(fd->close());
  },
  test_ftruncate = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    var offset = largeval;
    assert(fd->truncate(offset));
    var st = assert(fd->stat());
    assert_equal(st.size, offset);
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_truncate = function() {
    var fd = assert(S.creat(tmpfile, "RWXU"));
    var offset = largeval;
    assert(S.truncate(tmpfile, offset));
    var st = assert(S.stat(tmpfile));
    assert_equal(st.size, offset);
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_preadv_pwritev = function() {
    if( ! S.preadv ) { error ("skipped"); }
    var offset = largeval;
    var fd = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    var n = assert(fd->pwritev({"test", "ing", "writev"}, offset));
    assert_equal(n, 13, "expect length 13");
    var b1, b2, b3 = t.buffer(6), t.buffer(4), t.buffer(3);
    n = assert(fd->preadv({b1, b2, b3}, offset));
    assert_equal(n, 13, "expect length 13");
    assert_equal(ffi.string(b1, 6), "testin");
    assert_equal(ffi.string(b2, 4), "gwri");
    assert_equal(ffi.string(b3, 3), "tev");
    assert(fd->seek(offset));
    n = assert(fd->readv({b1, b2, b3}));
    assert_equal(n, 13, "expect length 13");
    assert_equal(ffi.string(b1, 6), "testin");
    assert_equal(ffi.string(b2, 4), "gwri");
    assert_equal(ffi.string(b3, 3), "tev");
    assert(S.unlink(tmpfile));
  },
  test_open = function() {
    var fd = assert(S.open(tmpfile, "creat,wronly,trunc", "RWXU"));
    var offset = largeval;
    assert(fd->truncate(offset));
    var st = assert(fd->stat());
    assert_equal(st.size, offset);
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
  test_openat = function() {
    if( ! S.openat ) { error ("skipped"); }
    var fd = assert(S.openat("fdcwd", tmpfile, "creat,wronly,trunc", "RWXU"));
    var offset = largeval;
    assert(fd->truncate(offset));
    var st = assert(fd->stat());
    assert_equal(st.size, offset);
    assert(S.unlink(tmpfile));
    assert(fd->close());
  },
};

test_ids = {
  test_setuid = function() {
    assert(S.setuid(S.getuid()));
  },
  test_setgid = function() {
    assert(S.setgid(S.getgid()));
  },
  test_setgid_root = function() {
    var gid = S.getgid();
    assert(S.setgid(66));
    assert_equal(S.getgid(), 66, "gid should be as set");
    assert(S.setgid(gid));
    assert_equal(S.getgid(), gid, "gid should be as set");
  },
  test_seteuid = function() {
    assert(S.seteuid(S.geteuid()));
  },
  test_seteuid_root = function() {
    var uid = S.geteuid();
    assert(S.seteuid(66));
    assert_equal(S.geteuid(), 66, "gid should be as set");
    assert(S.seteuid(uid));
    assert_equal(S.geteuid(), uid, "gid should be as set");
  },
  test_setegid = function() {
    assert(S.setegid(S.getegid()));
  },
  test_setegid_root = function() {
    var gid = S.getegid();
    assert(S.setegid(66));
    assert_equal(S.getegid(), 66, "gid should be as set");
    assert(S.setegid(gid));
    assert_equal(S.getegid(), gid, "gid should be as set");
  },
  test_getgroups = function() {
    var g = assert(S.getgroups());
    assert(#g, "groups behaves like a table");
  },
  test_setgroups_root = function() {
    var og = assert(S.getgroups());
    assert(S.setgroups({0, 1, 66, 77, 5}));
    var g = assert(S.getgroups());
    assert_equal(#g, 5, "expect 5 groups now");
    assert(S.setgroups(og));
    g = assert(S.getgroups());
    assert_equal(#g, #og, "expect same number of groups as previously");
  },
};

test_sockets_pipes = {
  teardown = clean,
  test_sockaddr_storage = function() {
    var sa = t.sockaddr_storage({family = "inet6", port = 2});
    assert_equal(sa.family, c.AF.INET6, "inet6 family");
    assert_equal(sa.port, 2, "should get port back");
    sa.port = 3;
    assert_equal(sa.port, 3, "should get port back");
    sa.family = "inet";
    assert_equal(sa.family, c.AF.INET, "inet family");
    sa.port = 4;
    assert_equal(sa.port, 4, "should get port back");
  },
  test_pipe = function() {
    var pr, pw = assert(S.pipe());
    assert(pw->write("test"));
    assert_equal(pr->read(), "test");
    assert(pr->close());
    assert(pw->close());
  },
  test_pipe2 = function() {
    if( ! S.pipe2 ) { error ("skipped"); }
    var pr, pw = assert(S.pipe2("nonblock, cloexec"));
    assert(pw->write("test"));
    assert_equal(pr->read(), "test");
    assert(pr->close());
    assert(pw->close());
  },
  test_socketpair = function() {
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    assert(sv1->write("test"));
    var r = assert(sv2->read());
    assert_equal(r, "test");
    assert(sv1->close());
    assert(sv2->close());
  },
  test_inet_socket = function() { // TODO break this test up
    var ss, err = S.socket("inet", "stream");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    assert(ss->nonblock());
    var sa = assert(t.sockaddr_in(0, "loopback"));
    assert_equal(sa.family, c.AF.INET);
    assert(ss->bind(sa));
    var ba = assert(ss->getsockname());
    assert_equal(ba.family, c.AF.INET);
    assert(ss->listen()); // will fail if we did not bind
    var cs, ok;
    cs, err = S.socket("inet", "stream");
    if( ! cs && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(cs, err);
    ok, err = cs->connect(ba);
    var as = ss->accept();
    ok, err = cs->connect(ba);
    assert(ok || err.ISCONN);
    assert(ss->block()); // force accept to wait
    as = as || assert(ss->accept());
    assert(as->block());
    ba = assert(cs->getpeername());
    assert_equal(ba.family, c.AF.INET);
    assert_equal(tostring(ba.addr), "127.0.0.1");
    assert_equal(ba.sin_addr.s_addr, t.in_addr("loopback").s_addr);
    var n = assert(cs->send(teststring));
    assert_equal(n, #teststring);
    var str = assert(as->read(null, #teststring));
    assert_equal(str, teststring);
    // test scatter gather
    var b0 = t.buffer(4);
    var b1 = t.buffer(3);
    ffi.copy(b0, "test", 4); // string init adds trailing 0 byte
    ffi.copy(b1, "ing", 3);
    n = assert(cs->writev({{b0, 4}, {b1, 3}}));
    assert_equal(n, 7);
    b0 = t.buffer(3);
    b1 = t.buffer(4);
    var iov = t.iovecs({{b0, 3}, {b1, 4}});
    n = assert(as->readv(iov));
    assert_equal(n, 7);
    assert(ffi.string(b0, 3) == "tes" && ffi.string(b1, 4) == "ting", "expect to get back same stuff");
    assert(cs->close());
    assert(as->close());
    assert(ss->close());
  },
  test_inet_socket_readv = function() { // part of above, no netbsd bug (but commenting out writev does trigger)
    var ss, err = S.socket("inet", "stream");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    assert(ss->nonblock());
    var sa = assert(t.sockaddr_in(0, "loopback"));
    assert_equal(sa.family, c.AF.INET);
    assert(ss->bind(sa));
    var ba = assert(ss->getsockname());
    assert_equal(ba.family, c.AF.INET);
    assert(ss->listen()); // will fail if we did not bind
    var cs = assert(S.socket("inet", "stream")); // client socket
    var ok;
    ok, err = cs->connect(ba);
    var as = ss->accept();
    ok, err = cs->connect(ba);
    assert(ok || err.ISCONN);
    assert(ss->block()); // force accept to wait
    as = as || assert(ss->accept());
    assert(as->block());
    var b0 = t.buffer(4);
    var b1 = t.buffer(3);
    ffi.copy(b0, "test", 4); // string init adds trailing 0 byte
    ffi.copy(b1, "ing", 3);
    var n = assert(cs->writev({{b0, 4}, {b1, 3}}));
    assert(n == 7, "expect writev to write 7 bytes");
    b0 = t.buffer(3);
    b1 = t.buffer(4);
    var iov = t.iovecs({{b0, 3}, {b1, 4}});
    n = assert(as->readv(iov));
    assert_equal(n, 7, "expect readv to read 7 bytes");
    assert(ffi.string(b0, 3) == "tes" && ffi.string(b1, 4) == "ting", "expect to get back same stuff");
    assert(cs->close());
    assert(as->close());
    assert(ss->close());
  },
  test_inet6_socket = function() { // TODO break this test up
    var ss, err = S.socket("inet6", "stream");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    assert(ss->nonblock());
    var sa = assert(t.sockaddr_in6(0, "loopback"));
    assert_equal(sa.family, c.AF.INET6);
    assert(ss->bind(sa));
    var ba = assert(ss->getsockname());
    assert_equal(ba.family, c.AF.INET6);
    assert(ss->listen()); // will fail if we did not bind
    var cs = assert(S.socket("inet6", "stream")); // client socket
    var ok;
    ok, err = cs->connect(ba);
    var as = ss->accept();
    ok, err = cs->connect(ba);
    assert(ok || err.ISCONN);
    assert(ss->block()); // force accept to wait
    as = as || assert(ss->accept());
    assert(as->block());
    ba = assert(cs->getpeername());
    assert_equal(ba.family, c.AF.INET6);
    assert_equal(tostring(ba.addr), "::1");
    var n = assert(cs->send(teststring));
    assert_equal(n, #teststring);
    var str = assert(as->read(null, #teststring));
    assert_equal(str, teststring);
    // test scatter gather
    var b0 = t.buffer(4);
    var b1 = t.buffer(3);
    ffi.copy(b0, "test", 4); // string init adds trailing 0 byte
    ffi.copy(b1, "ing", 3);
    n = assert(cs->writev({{b0, 4}, {b1, 3}}));
    assert_equal(n, 7);
    b0 = t.buffer(3);
    b1 = t.buffer(4);
    var iov = t.iovecs({{b0, 3}, {b1, 4}});
    n = assert(as->readv(iov));
    assert_equal(n, 7);
    assert(ffi.string(b0, 3) == "tes" && ffi.string(b1, 4) == "ting", "expect to get back same stuff");
    assert(cs->close());
    assert(as->close());
    assert(ss->close());
  },
  test_inet6_inet_conn_socket = function() { // TODO break this test up
    var ss, err = S.socket("inet6", "stream");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    assert(ss->nonblock());
    var ok;
    ok, err = ss->setsockopt(c.IPPROTO.IPV6, c.IPV6.V6ONLY, 0);
    if( ! ok && err.INVAL ) { error ("skipped"); } // OpenBSD does not support inet on inet6 sockets
    var sa = assert(t.sockaddr_in6(0, "any"));
    assert_equal(sa.family, c.AF.INET6);
    assert(ss->bind(sa));
    var ba = assert(ss->getsockname());
    assert_equal(ba.family, c.AF.INET6);
    assert(ss->listen()); // will fail if we did not bind
    var cs = assert(S.socket("inet6", "stream")); // ipv6 client socket, ok
    var ba6 = t.sockaddr_in6(ba.port, "loopback"); 
    ok, err = cs->connect(ba6);
    var as = ss->accept();
    ok, err = cs->connect(ba6);
    assert(ok || err.ISCONN, "unexpected error " .. tostring(err));
    assert(ss->block()); // force accept to wait
    as = as || assert(ss->accept());
    assert(as->block());
    ba = assert(cs->getpeername());
    assert_equal(ba.family, c.AF.INET6);
    assert_equal(tostring(ba.addr), "::1");
    var n = assert(cs->send(teststring));
    assert_equal(n, #teststring);
    var str = assert(as->read(null, #teststring));
    assert_equal(str, teststring);
    assert(cs->close());
    assert(as->close());
    // second connection
    assert(ss->nonblock());
    cs, err = S.socket("inet", "stream"); // ipv4 client socket, ok
    if( ! cs && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(cs, err);
    var ba4 = t.sockaddr_in(ba.port, "loopback"); // TODO add function to convert sockaddr in6 to in4
    ok, err = cs->connect(ba4);
    as = ss->accept();
    ok, err = cs->connect(ba4);
    assert(ok || err.ISCONN, "unexpected error " .. tostring(err));
    assert(ss->block()); // force accept to wait
    as = as || assert(ss->accept());
    assert(as->block());
    ba = assert(cs->getpeername());
    assert_equal(ba.family, c.AF.INET);
    assert_equal(tostring(ba.addr), "127.0.0.1");
    n = assert(cs->send(teststring));
    assert_equal(n, #teststring);
    str = assert(as->read(null, #teststring));
    assert_equal(str, teststring);
    assert(cs->close());
    assert(as->close());
    assert(ss->close());
  },
  test_inet6_only_inet_conn_socket = function() {
    var ss, err = S.socket("inet6", "stream");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    assert(ss->nonblock());
    assert(ss->setsockopt(c.IPPROTO.IPV6, c.IPV6.V6ONLY, 1));
    var sa = assert(t.sockaddr_in6(0, "loopback"));
    assert_equal(sa.family, c.AF.INET6);
    assert(ss->bind(sa));
    var ba = assert(ss->getsockname());
    assert_equal(ba.family, c.AF.INET6);
    assert(ss->listen()); // will fail if we did not bind
    var cs = assert(S.socket("inet6", "stream")); // ipv6 client socket, ok
    var ok;
    ok, err = cs->connect(ba);
    var as = ss->accept();
    ok, err = cs->connect(ba);
    assert(ok || err.ISCONN, "unexpected error " .. tostring(err));
    assert(ss->block()); // force accept to wait
    as = as || assert(ss->accept());
    assert(as->block());
    ba = assert(cs->getpeername());
    assert_equal(ba.family, c.AF.INET6);
    assert_equal(tostring(ba.addr), "::1");
    var n = assert(cs->send(teststring));
    assert_equal(n, #teststring);
    var str = assert(as->read(null, #teststring));
    assert_equal(str, teststring);
    assert(cs->close());
    assert(as->close());
    // second connection
    assert(ss->nonblock());
    cs, err = S.socket("inet", "stream"); // ipv4 client socket, will fail to connect
    if( ! cs && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(cs, err);
    var ba4 = t.sockaddr_in(ba.port, "loopback"); // TODO add function to convert sockaddr in6 to in4
    ok, err = cs->connect(ba4);
    assert(! ok, "expect connect to fail with ipv4 connection when set to ipv6 only");
    assert(err.CONNREFUSED, err);
    assert(cs->close());
    assert(as->close());
    assert(ss->close());
  },
  test_inet6_only_inet_conn_socket2 = function() {
    var ss, err = S.socket("inet6", "stream");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    assert(ss->nonblock());
    assert(ss->setsockopt(c.IPPROTO.IPV6, c.IPV6.V6ONLY, 1));
    var sa = assert(t.sockaddr_in6(0, "loopback"));
    assert_equal(sa.family, c.AF.INET6);
    assert(ss->bind(sa));
    var ba = assert(ss->getsockname());
    assert_equal(ba.family, c.AF.INET6);
    assert(ss->listen()); // will fail if we did not bind
    var ok, cs;
    cs, err = S.socket("inet", "stream"); // ipv4 client socket, will fail to connect
    if( ! cs && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(cs, err);
    var ba4 = t.sockaddr_in(ba.port, "loopback"); // TODO add function to convert sockaddr in6 to in4
    ok, err = cs->connect(ba4);
    assert(! ok, "expect connect to fail with ipv4 connection when set to ipv6 only");
    assert(err.CONNREFUSED, err);
    assert(cs->close());
    assert(ss->close());
  },
  test_udp_socket = function() {
    var ss, err = S.socket("inet", "dgram");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    var cs;
    cs, err = S.socket("inet", "dgram");
    if( ! cs && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(cs, err);
    var sa = assert(t.sockaddr_in(0, "loopback"));
    assert(ss->bind(sa));
    var bsa = ss->getsockname(); // find bound address
    var n = assert(cs->sendto(teststring, #teststring, 0, bsa));
    var f = assert(ss->recv(buf, size));
    assert_equal(f, #teststring);
    assert(ss->close());
    assert(cs->close());
  },
  test_inet6_udp_socket = function() {
    var ss, err = S.socket("inet6", "dgram");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    var loop6 = "::1";
    var cs = assert(S.socket("inet6", "dgram"));
    var sa = assert(t.sockaddr_in6(0, loop6));
    assert(ss->bind(sa));
    var bsa = ss->getsockname(); // find bound address
    var n = assert(cs->sendto(teststring, null, c.MSG.NOSIGNAL || 0, bsa)); // got a sigpipe here on MIPS
    var f = assert(ss->recv(buf, size));
    assert_equal(f, #teststring);
    assert(cs->close());
    assert(ss->close());
  },
  test_recvfrom = function() {
    var ss, err = S.socket("inet", "dgram");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    var cs;
    cs, err = S.socket("inet", "dgram");
    if( ! cs && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(cs, err);
    var sa = t.sockaddr_in(0, "loopback");
    assert(ss->bind(sa));
    assert(cs->bind(sa));
    var bsa = ss->getsockname();
    var csa = cs->getsockname();
    var n = assert(cs->sendto(teststring, #teststring, c.MSG.NOSIGNAL || 0, bsa));
    var rsa = t.sockaddr_in();
    var f = assert(ss->recvfrom(buf, size, "", rsa));
    assert_equal(f, #teststring);
    assert_equal(rsa.port, csa.port);
    assert_equal(tostring(rsa.addr), "127.0.0.1");
    assert(ss->close());
    assert(cs->close());
  },
  test_recvfrom_alloc = function() {
    var ss, err = S.socket("inet", "dgram");
    if( ! ss && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(ss, err);
    var cs;
    cs, err = S.socket("inet", "dgram");
    if( ! cs && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(cs, err);
    var sa = t.sockaddr_in(0, "loopback");
    assert(ss->bind(sa));
    assert(cs->bind(sa));
    var bsa = ss->getsockname();
    var csa = cs->getsockname();
    var n = assert(cs->sendto(teststring, #teststring, c.MSG.NOSIGNAL || 0, bsa));
    var f, rsa = assert(ss->recvfrom(buf, size)); // will allocate and return address
    assert_equal(f, #teststring);
    assert_equal(rsa.port, csa.port);
    assert_equal(tostring(rsa.addr), "127.0.0.1");
    assert(ss->close());
    assert(cs->close());
  },
  test_named_unix = function() {
    var sock = assert(S.socket("local", "stream"));
    var sa = t.sockaddr_un(tmpfile);
    assert(sock->bind(sa));
    var st = assert(S.stat(tmpfile));
    assert(st.issock);
    assert(sock->close());
    assert(S.unlink(tmpfile));
  },
  test_notsock_error = function() { // this error number differs on NetBSD, Linux so good test of rump/rumplinux error handling
    var fd = assert(S.open("/dev/null", "RDONLY"));
    var sa = t.sockaddr_in(0, "loopback");
    var ok, err = fd->bind(sa);
    assert(! ok && err.NOTSOCK);
    assert_equal(tostring(err), "Socket operation on non-socket");
    assert(fd->close());
  },
  test_getsockopt_acceptconn = function() {
    var s, err = S.socket("inet", "stream");
    if( ! s && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(s, err);
    var sa = t.sockaddr_in(0, "loopback");
    assert(s->bind(sa));
    var ok;
    ok, err = s->getsockopt("socket", "acceptconn");
    if( ! ok && err.NOPROTOOPT ) { error ("skipped"); } // NetBSD 6, OSX do not support this on socket level
    assert(ok, err);
    assert_equal(ok, 0);
    assert(s->close());
  },
  test_sockopt_sndbuf = function() {
    var s, err = S.socket("inet", "stream");
    if( ! s && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(s, err);
    var n = assert(s->getsockopt("socket", "sndbuf"));
    assert(n > 0);
    assert(s->close());
  },
  test_sockopt_sndbuf_inet6 = function() {
    var s, err = S.socket("inet6", "stream");
    if( ! s && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(s, err);
    var n = assert(s->getsockopt("socket", "sndbuf"));
    assert(n > 0);
    assert(s->close());
  },
  test_setsockopt_keepalive = function() {
    var s, err = S.socket("inet", "stream");
    if( ! s && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(s, err);
    var sa = t.sockaddr_in(0, "loopback");
    assert(s->bind(sa));
    assert_equal(s->getsockopt("socket", "keepalive"), 0);
    assert(s->setsockopt("socket", "keepalive", 1));
    assert(s->getsockopt("socket", "keepalive") != 0);
    assert(s->close());
  },
  test_setsockopt_keepalive_inet6 = function() {
    var s, err = S.socket("inet6", "stream");
    if( ! s && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(s, err);
    s = assert(S.socket("inet6", "stream"));
    var sa = t.sockaddr_in6(0, "loopback");
    assert(s->bind(sa));
    assert_equal(s->getsockopt("socket", "keepalive"), 0);
    assert(s->setsockopt("socket", "keepalive", 1));
    assert(s->getsockopt("socket", "keepalive") != 0);
    assert(s->close());
  },
  test_sockopt_tcp_nodelay = function() {
    var s, err = S.socket("inet", "stream");
    if( ! s && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(s, err);
    var sa = t.sockaddr_in(0, "loopback");
    assert(s->bind(sa));
    assert_equal(s->getsockopt(c.IPPROTO.TCP, c.TCP.NODELAY), 0);
    assert(s->setsockopt(c.IPPROTO.TCP, c.TCP.NODELAY, 1));
    assert(s->getsockopt(c.IPPROTO.TCP, c.TCP.NODELAY) != 0);
    assert(s->close());
  },
  test_sockopt_tcp_nodelay_inet6 = function() {
    var s, err = S.socket("inet6", "stream");
    if( ! s && err.AFNOSUPPORT ) { error ("skipped"); }
    assert(s, err);
    s = assert(S.socket("inet6", "stream"));
    var sa = t.sockaddr_in6(0, "loopback");
    assert(s->bind(sa));
    assert_equal(s->getsockopt(c.IPPROTO.TCP, c.TCP.NODELAY), 0);
    assert(s->setsockopt(c.IPPROTO.TCP, c.TCP.NODELAY, 1));
    assert(s->getsockopt(c.IPPROTO.TCP, c.TCP.NODELAY) != 0);
    assert(s->close());
  },
  test_accept_noaddr = function() {
    var s = S.socket("unix", "stream");
    assert(s->nonblock());
    var sa = t.sockaddr_un(tmpfile);
    assert(s->bind(sa));
    assert(s->listen());
    var a, err = s->accept();
    assert((! a) && err.AGAIN, "expect again: " .. tostring(err));
    assert(s->close());
    assert(S.unlink(tmpfile));
  },
  test_accept4 = function() {
    if( ! S.accept4 ) { error ("skipped"); }
    var s = S.socket("unix", "stream, nonblock");
    var sa = t.sockaddr_un(tmpfile);
    assert(s->bind(sa));
    assert(s->listen());
    sa = t.sockaddr_un();
    var a, err = s->accept4(sa, null, "nonblock");
    assert((! a) && err.AGAIN, "expect again: " .. tostring(err));
    assert(s->close());
    assert(S.unlink(tmpfile));
  },
  test_send = function() {
    var buf = t.buffer(10);
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    assert(sv1->send("test"));
    var r = assert(sv2->recv(buf, 10));
    assert_equal(r, #"test");
    assert_equal(ffi.string(buf, r), "test");
    assert(sv1->close());
    assert(sv2->close());
  },
  test_sendto = function() {
    var buf = t.buffer(10);
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    assert(sv1->sendto("test"));
    var r, addr = assert(sv2->recvfrom(buf, 10));
    assert_equal(r, #"test");
    assert_equal(ffi.string(buf, r), "test");
    //assert_equal(addr.family, c.AF.UNIX) -- TODO addrlen seen as 0 so not filled in?
    assert(sv1->close());
    assert(sv2->close());
  },
  test_sendto_src = function() {
    var buf = t.buffer(10);
    var sa = t.sockaddr_un();
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    assert(sv1->sendto("test"));
    var r = assert(sv2->recvfrom(buf, 10, 0, sa));
    assert_equal(r, #"test");
    assert_equal(ffi.string(buf, r), "test");
    assert_equal(sa.family, c.AF.UNIX); // TODO addrlen seen as 0 so not filled in?
    assert(sv1->close());
    assert(sv2->close());
  },
  test_sendmsg = function() {
    var buf = t.buffer(4);
    ffi.copy(buf, "test", 4);
    var iov = t.iovecs({{buf, 4}});
    var sa = t.sockaddr_storage();
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    var msg = t.msghdr({iov = iov});
    assert(sv1->sendmsg(msg));
    msg = t.msghdr({name = sa, iov = iov});
    var r = assert(sv2->recvmsg(msg));
    assert_equal(r, #"test");
    assert_equal(ffi.string(buf, r), "test");
    //assert_equal(sa.family, c.AF.UNIX) -- TODO addrlen seen as 0 so not filled in?
    assert(sv1->close());
    assert(sv2->close());
  },
  test_sendmmsg = function() {
    if( ! S.sendmmsg ) { error ("skipped"); }
    var buf = t.buffer(4);
    ffi.copy(buf, "test", 4);
    var iov = t.iovecs({{buf, 4}});
    var sa = t.sockaddr_storage();
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    var msg = t.mmsghdrs({{iov = iov}});
    var ok, err = sv1->sendmmsg(msg);
    if( ! ok && err.NOSYS ) { error ("skipped"); }
    assert(ok, err);
    msg = t.mmsghdrs({{name = sa, iov = iov}});
    assert(sv2->recvmmsg(msg));
    assert_equal(msg.msg[0].len, #"test");
    assert_equal(ffi.string(msg.msg[0].hdr.msg_iov[0].base, msg.msg[0].len), "test");
    //assert_equal(sa.family, c.AF.UNIX) -- TODO addrlen seen as 0 so not filled in?
    assert(sv1->close());
    assert(sv2->close());
  },
};

test_timespec_timeval = {
  test_timespec = function() {
    var ts = t.timespec(1);
    assert_equal(ts.time, 1);
    assert_equal(ts.sec, 1);
    assert_equal(ts.nsec, 0);
    ts = t.timespec({1, 0});
    assert_equal(ts.time, 1);
    assert_equal(ts.sec, 1);
    assert_equal(ts.nsec, 0);
  },
  test_timeval = function() {
    var ts = t.timeval(1);
    assert_equal(ts.time, 1);
    assert_equal(ts.sec, 1);
    assert_equal(ts.usec, 0);
    ts = t.timeval({1, 0});
    assert_equal(ts.time, 1);
    assert_equal(ts.sec, 1);
    assert_equal(ts.usec, 0);
  },
};

test_locking = {
  teardown = clean,
  test_fcntl_setlk = function() {
    var fd = assert(S.open(tmpfile, "creat, rdwr", "RWXU"));
    assert(S.unlink(tmpfile));
    assert(fd->truncate(4096));
    assert(fd->fcntl("setlk", {type = "rdlck", whence = "set", start = 0, len = 4096}));
    assert(fd->close());
  },
  test_lockf_lock = function() {
    var fd = assert(S.open(tmpfile, "creat, rdwr", "RWXU"));
    assert(S.unlink(tmpfile));
    assert(fd->truncate(4096));
    assert(fd->lockf("lock", 4096));
    assert(fd->close());
  },
  test_lockf_tlock = function() {
    var fd = assert(S.open(tmpfile, "creat, rdwr", "RWXU"));
    assert(S.unlink(tmpfile));
    assert(fd->truncate(4096));
    assert(fd->lockf("tlock", 4096));
    assert(fd->close());
  },
  test_lockf_ulock = function() {
    var fd = assert(S.open(tmpfile, "creat, rdwr", "RWXU"));
    assert(S.unlink(tmpfile));
    assert(fd->truncate(4096));
    assert(fd->lockf("lock", 4096));
    assert(fd->lockf("ulock", 4096));
    assert(fd->close());
  },
  test_lockf_test = function() {
    var fd = assert(S.open(tmpfile, "creat, rdwr", "RWXU"));
    assert(S.unlink(tmpfile));
    assert(fd->truncate(4096));
    assert(fd->lockf("test", 4096));
    assert(fd->close());
  },
  test_flock = function() {
    var fd = assert(S.open(tmpfile, "creat, rdwr", "RWXU"));
    assert(fd->flock("sh, nb"));
    assert(fd->flock("ex"));
    assert(fd->flock("un"));
    assert(fd->close());
  },
};

test_termios = {
  test_pts_termios = function() {
    var ptm = assert(S.posix_openpt("rdwr, noctty"));
    assert(ptm->grantpt());
    assert(ptm->unlockpt());
    //assert(ptm:isatty()) -- oddly fails in osx, unclear if that is valid
    var pts_name = assert(ptm->ptsname());
    var pts = assert(S.open(pts_name, "rdwr, noctty"));
    assert(pts->isatty(), "should be a tty");
    if( S.tcgetsid ) {
      var ok, err = pts->tcgetsid();
      assert(! ok, "should not get sid as noctty");
    }
    var termios = assert(pts->tcgetattr());
    assert(termios.ospeed != 115200, "speed should not be 115200");
    termios.speed = 115200;
    assert_equal(termios.ispeed, 115200);
    assert_equal(termios.ospeed, 115200);
    //assert(bit.band(termios.lflag, c.LFLAG.ICANON) ~= 0, "CANON non zero") -- default seems to differ on mips?
    termios->makeraw();
    assert_equal(bit.band(termios.lflag, c.LFLAG.ICANON), 0);
    assert(pts->tcsetattr("now", termios));
    termios = assert(pts->tcgetattr()); // TODO failing on mips
    assert_equal(termios.ospeed, 115200);
    assert_equal(bit.band(termios.lflag, c.LFLAG.ICANON), 0);
    var ok, err = pts->tcsendbreak(0); // as this is not actually a serial line, NetBSD seems to fail here
    assert(pts->tcdrain());
    assert(pts->tcflush('ioflush'));
    assert(pts->tcflow('ooff'));
    //assert(pts:tcflow('ioff')) -- blocking in NetBSD
    assert(pts->tcflow('oon'));
    //assert(pts:tcflow('ion')) -- blocking in NetBSD
    assert(pts->close());
    assert(ptm->close());
  },
  test_isatty_fail = function() {
    var fd = S.open("/dev/zero");
    assert(! fd->isatty(), "not a tty");
    assert(fd->close());
  },
  test_ioctl_winsize = function() {
    var ws, err = S.stdout->ioctl("TIOCGWINSZ");
    if( ! ws && err.NOTTY ) { error ("skipped"); } // stdout might not be a tty in test env
    assert(ws, err);
    assert(ws.row > 0 && ws.col > 0);
  },
};

test_misc = {
  teardown = clean,
  test_chroot_root = function() {
    var cwd = assert(S.open(".", "rdonly"));
    var cname = assert(S.getcwd());
    var root = assert(S.open("/", "rdonly"));
    assert(S.mkdir(tmpfile, "0700"));
    assert(S.chdir("/"));
    assert(S.chroot(cname .. "/" .. tmpfile));
    var ok, err = S.stat("/dev");
    assert(! ok, "should not find /dev after chroot");
    // note that NetBSD will chdir after chroot, so chroot(".") will not work, but does provide fchroot, which Linux does not
    // however other BSDs also do this; we could only test with fork so give up
    if( S.fchroot ) {
      assert(root->chroot());
    } else {
      if( abi.os != "linux" ) { error ("skipped"); }
      assert(S.chroot("."));
    }
    assert(cwd->chdir());
    assert(S.rmdir(tmpfile));
  },
  test_pathconf = function() {
    var pc = assert(S.pathconf(".", "name_max"));
    assert(pc >= 255, "name max should be at least 255");
  },
  test_fpathconf = function() {
    var fd = assert(S.open(".", "rdonly"));
    var pc = assert(fd->pathconf("name_max"));
    assert(pc >= 255, "name max should be at least 255");
    assert(fd->close());
  },
  test_sysctl = function() {
    var os = abi.os;
    if( S.__rump ) { os = "netbsd"; }
    var sc = "kern.ostype";
    if( os == "linux" ) { sc = "kernel.ostype"; }
    var val = assert(S.sysctl(sc));
    if( val->lower() == "darwin" ) { val = "osx"; }
    assert_equal(val->lower(), os);
  },
};

test_raw_socket = {
  test_ip_checksum = function() {
    var packet = {0x45, 0x00,
      0x00, 0x73, 0x00, 0x00,
      0x40, 0x00, 0x40, 0x11,
      0xb8, 0x61, 0xc0, 0xa8, 0x00, 0x01,
      0xc0, 0xa8, 0x00, 0xc7};

    var expected;
    if( abi.le ) { expected = 0x61B8; } else { expected = 0xB861; }

    var buf = t.buffer(#packet, packet);
    var iphdr = pt.iphdr(buf);
    iphdr[0].check = 0;
    var cs = iphdr[0]->checksum();
    assert(cs == expected, "expect correct ip checksum: got " .. string.format("%%%04X", cs) .. " expected " .. string.format("%%%04X", expected));
  },
  test_raw_udp_root = function() { // TODO create some helper functions, this is not very nice

    var h = require ("syscall.helpers"); // TODO should not have to use later

    var loop = "127.0.0.1";
    var raw = assert(S.socket("inet", "raw", "raw"));
    // needed if not on Linux
    assert(raw->setsockopt(c.IPPROTO.IP, c.IP.HDRINCL, 1)); // TODO new sockopt code should be able to cope
    var msg = "raw message.";
    var udplen = s.udphdr + #msg;
    var len = s.iphdr + udplen;
    var buf = t.buffer(len);
    var iphdr = pt.iphdr(buf);
    var udphdr = pt.udphdr(buf + s.iphdr);
    ffi.copy(buf + s.iphdr + s.udphdr, msg, #msg);
    var bound = false;
    var sport = 666;
    var sa = t.sockaddr_in(sport, loop);

    var buf2 = t.buffer(#msg);

    var cl = assert(S.socket("inet", "dgram")); // destination
    var ca = t.sockaddr_in(0, loop);
    assert(cl->bind(ca));
    ca = cl->getsockname();

    // TODO iphdr should have __index helpers for endianness etc (note use raw s_addr)
    iphdr[0] = {ihl = 5, version = 4, tos = 0, id = 0, frag_off = h.htons(0x4000), ttl = 64, protocol = c.IPPROTO.UDP, check = 0,
             saddr = sa.sin_addr.s_addr, daddr = ca.sin_addr.s_addr, tot_len = h.htons(len)};

    //udphdr[0] = {src = sport, dst = ca.port, length = udplen} -- doesnt work with metamethods
    udphdr[0].src = sport;
    udphdr[0].length = udplen;

    udphdr[0].dst = ca.port;
    // we do not need to calulate checksum, can leave as zero (for Linux at least)
    //udphdr[0]:checksum(iphdr[0], buf + s.iphdr + s.udphdr)
    iphdr[0].check = 0;

    // TODO in FreeBSD, NetBSD len is in host byte order not net, see Stephens, http://developerweb.net/viewtopic.php?id=4657
    // TODO the metamethods should take care of this
    if( S.__rump || abi.bsd ) { iphdr[0].tot_len = len; }

    ca.port = 0; // should not set port

    if( abi.os == "openbsd" ) { error ("skipped"); } // TODO fix
    var n = assert(raw->sendto(buf, len, 0, ca));

    // TODO receive issues on netBSD 
    if( ! (S.__rump || abi.bsd) ) {
      var f = assert(cl->recvfrom(buf2, #msg));
      assert_equal(f, #msg);
    }
    assert(raw->close());
    assert(cl->close());
  },
};

test_util = {
  teardown = clean,
  test_rm_recursive = function() {
    assert(S.mkdir(tmpdir, "rwxu"));
    assert(S.mkdir(tmpdir .. "/subdir", "rwxu"));
    assert(util.createfile(tmpdir .. "/file"));
    assert(util.createfile(tmpdir .. "/subdir/subfile"));
    assert(S.stat(tmpdir), "directory should be there");
    assert(S.stat(tmpdir).isdir, "should be a directory");
    var ok, err = S.rmdir(tmpdir);
    assert(util.rm(tmpdir)); // rm -r
    assert(! S.stat(tmpdir), "directory should be deleted");
    assert(! ok && err.notempty, "should have failed as not empty");
  },
  test_rm_broken_symlink = function() {
    assert(S.mkdir(tmpdir, "rwxu"));
    assert(S.symlink(tmpdir .. "/none", tmpdir .. "/link"));
    assert(util.rm(tmpdir));
    assert(! S.stat(tmpdir), "directory should be deleted");
  },
  test_touch = function() {
    assert(! S.stat(tmpfile3));
    assert(util.touch(tmpfile3));
    assert(S.stat(tmpfile3));
    assert(util.touch(tmpfile3));
    assert(S.unlink(tmpfile3));
  },
  test_readfile_writefile = function() {
    assert(util.writefile(tmpfile, teststring, "RWXU"));
    var ss = assert(util.readfile(tmpfile));
    assert_equal(ss, teststring, "readfile should get back what writefile wrote");
    assert(S.unlink(tmpfile));
  },
  test_cp = function() {
    assert(util.writefile(tmpfile, teststring, "rusr,wusr"));
    assert(util.cp(tmpfile, tmpfile2, "rusr,wusr"));
    assert_equal(assert(util.readfile(tmpfile2)), teststring);
    assert(S.unlink(tmpfile));
    assert(S.unlink(tmpfile2));
  },
  test_basename_dirname = function() {
    assert_equal(util.dirname  ("/usr/lib"), "/usr");
    assert_equal(util.basename ("/usr/lib"), "lib");
    assert_equal(util.dirname  ("/usr/"), "/");
    assert_equal(util.basename ("/usr/"), "usr");
    assert_equal(util.dirname  ("usr"), ".");
    assert_equal(util.basename ("usr"), "usr");
    assert_equal(util.dirname  ("/"), "/");
    assert_equal(util.basename ("/"), "/");
    assert_equal(util.dirname  ("."), ".");
    assert_equal(util.basename ("."), ".");
    assert_equal(util.dirname  (".."), ".");
    assert_equal(util.basename (".."), "..");
    assert_equal(util.dirname  (""), ".");
    assert_equal(util.basename (""), ".");
  },
};

// TODO work in progress to make work in BSD, temp commented out
// note send creds moved, as varies by OS
if( ! (S.__rump || abi.bsd) ) {
test_sendfd = {
  test_sendfd = function() {
    var sv1, sv2 = assert(S.socketpair("unix", "stream"));
    assert(util.sendfds(sv1, S.stdin));
    var r = assert(util.recvcmsg(sv2));
    assert(#r.fd == 1, "expect to get one file descriptor back");
    assert(r.fd[1]->close());
    assert(sv1->close());
    assert(sv2->close());
  },
};
}

test_sleep = {
  test_nanosleep = function() {
    assert(S.nanosleep(0.001));
  },
  test_sleep = function() {
    assert(S.sleep(0));
  },
};

test_clock = {
  test_clock_gettime = function() {
    if( ! S.clock_gettime ) { error ("skipped"); }
    var tt = assert(S.clock_getres("realtime"));
    tt = assert(S.clock_gettime("realtime"));
    // TODO add settime
  },
  test_clock_nanosleep = function() {
    if( ! S.clock_nanosleep ) { error ("skipped"); }
    var rem = assert(S.clock_nanosleep("realtime", null, 0.001));
    assert_equal(rem, null);
  },
  test_clock_nanosleep_abs = function() {
    if( ! S.clock_nanosleep ) { error ("skipped"); }
    assert(S.clock_nanosleep("realtime", "abstime", 0));
  },
};

test_timeofday = {
  test_gettimeofday = function() {
    if( ! S.gettimeofday ) { error ("skipped"); }
    var tv = assert(S.gettimeofday());
    assert(math.floor(tv.time) == tv.sec, "should be able to get float time from timeval");
  },
  test_settimeofday_fail = function() {
    if( ! S.settimeofday ) { error ("skipped"); }
    var ok, err = S.settimeofday();
    // eg NetBSD does nothing on null, Linux errors
    assert(ok || (err.PERM || err.INVAL || err.FAULT), "null settimeofday should succeed or fail correctly");
  },
};

// on rump timers may not deliver signals, but for our tests we will not let them expire, or disable signals
test_timers = {
  test_timers = function() {
    if( ! S.timer_create ) { error ("skipped"); }
    var tid = assert(S.timer_create("monotonic"));
    var it = tid->gettime();
    assert_equal(it.value.time, 0);
    assert(tid->settime(0, {0, 10000}));
    it = tid->gettime();
    assert(it.value.time > 0, "expect some time left");
    var over = assert(tid->getoverrun());
    assert_equal(over, 0);
    assert(tid->delete());
  },
  test_timers_nosig = function() {
    if( ! S.timer_create ) { error ("skipped"); }
    var tid = assert(S.timer_create("monotonic", {notify = "none"}));
    var it = tid->gettime();
    assert_equal(it.value.time, 0);
    assert(tid->settime(0, {0, 10000}));
    it = tid->gettime();
    assert(it.value.time > 0, "expect some time left");
    var over = assert(tid->getoverrun());
    assert_equal(over, 0);
    assert(tid->delete());
  },
};

if( ! (S.__rump || abi.xen) ) { // rump has no processes, memory allocation, process accounting, mmap and proc not applicable

test_signals = {
  test_signal_return = function() {
    var orig = assert(S.signal("alrm", "ign"));
    var ret = assert(S.signal("alrm", "dfl"));
    assert_equal(ret, "IGN");
    ret = assert(S.signal("alrm", orig));
    assert_equal(ret, "DFL");
  },
  test_pause = function() {
    var pid = assert(S.fork());
    if( pid == 0 ) { // child
      S.pause();
      S.exit(23);
    } else { // parent
      S.kill(pid, "term");
      var _, status = assert(S.waitpid(pid));
      assert(status.WIFSIGNALED, "expect normal exit in clone");
      assert_equal(status.WTERMSIG, c.SIG.TERM);
    }
  },
  test_alarm = function() {
    assert(S.signal("alrm", "ign"));
    assert(S.alarm(10));
    assert(S.alarm(0)); // cancel again
    assert(S.signal("alrm", "dfl"));
  },
};

test_shm = {
  test_shm = function() {
    if( ! S.shm_open ) { error ("skipped"); }
    var name = "/XXXXXYYYY" .. S.getpid();
    var fd, err = S.shm_open(name, "rdwr, creat", "0600");
    if( ! fd && (err.ACCES || err.NOENT) ) { error ("skipped"); } // Travis CI, Android do not have mounted...
    assert(fd, err);
    assert(S.shm_unlink(name));
    assert(fd->truncate(4096));
    assert(fd->close());
  },
};

test_util_misc = {
  teardown = clean,
  test_mapfile = function() {
    assert(util.writefile(tmpfile, teststring, "RWXU"));
    var ss = assert(util.mapfile(tmpfile));
    assert_equal(ss, teststring, "mapfile should get back what writefile wrote");
    assert(S.unlink(tmpfile));
  },
};

test_rusage = {
  test_rusage = function() {
    var ru = assert(S.getrusage("self"));
    assert(ru.utime.time > 0, "should have used some cpu time");
  },
};

test_proc = {
  test_ps = function() {
    var ps, err = util.ps();
    if( ! ps && err.NOENT ) { error ("skipped"); } // FreeBSD usually does not have proc mounted, although usually mount point
    assert(ps);
    var me = S.getpid();
    var found = false;
    if( #ps == 0 ) { error ("skipped"); } // not mounted but mount point exists
    for( i = 1, #ps ) {
      if( ps[i].pid == 1 ) {
        assert(ps[i].cmdline->find("init") || ps[i].cmdline->find("systemd"), "expect init or systemd to be process 1 usually");
      }
      if( ps[i].pid == me ) { found = true; }
    }
    assert(found, "expect to find my process in ps");
    assert(tostring(ps), "can convert ps to string");
  },
  test_proc_self = function() {
    var p = util.proc();
    if( ! p.cmdline ) { error ("skipped"); } // no files found, /proc not mounted
    assert(p.cmdline && #p.cmdline > 1, "expect cmdline to exist");
    assert(! p.wrongname, "test non existent files");
    assert_equal(p.root, "/", "expect our root to be / usually");
  },
  test_proc_init = function() {
    var p = util.proc(1);
    if( ! p.cmdline ) { error ("skipped"); } // no files found, /proc not mounted
    assert(p && p.cmdline, "expect init to have cmdline");
    assert(p.cmdline->find("init") || p.cmdline->find("systemd"), "expect init or systemd to be process 1 usually");
  },
};

test_mmap = {
  teardown = clean,
  test_getpagesize = function() {
    var pagesize = assert(S.getpagesize());
    assert(pagesize >= 4096, "pagesize at least 4k");
  },
  test_mmap_fail = function() {
    var size = 4096;
    var mem, err = S.mmap(pt.void(1), size, "read", "private, fixed, anon", -1, 0);
    assert(err, "expect non aligned fixed map to fail");
    assert(err.INVAL, "expect non aligned map to return EINVAL");
  },
  test_mmap_anon = function() {
    var size = 4096;
    var mem = assert(S.mmap(null, size, "read", "private, anon", -1, 0));
    assert(S.munmap(mem, size));
  },
  test_mmap_file = function() {
    var fd = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    assert(S.unlink(tmpfile));
    var size = 4096;
    var mem = assert(fd->mmap(null, size, "read", "shared", 0));
    assert(S.munmap(mem, size));
    assert(fd->close());
  },
  test_mmap_page_offset = function() {
    var fd = assert(S.open(tmpfile, "rdwr,creat", "rwxu"));
    assert(S.unlink(tmpfile));
    var pagesize = S.getpagesize();
    var mem = assert(fd->mmap(null, pagesize, "read", "shared", pagesize));
    assert(S.munmap(mem, size));
    assert(fd->close());
  },
  test_msync = function() {
    var size = 4096;
    var mem = assert(S.mmap(null, size, "read", "private, anon", -1, 0));
    assert(S.msync(mem, size, "sync"));
    assert(S.munmap(mem, size));
  },
  test_madvise = function() {
    var size = 4096;
    var mem = assert(S.mmap(null, size, "read", "private, anon", -1, 0));
    assert(S.madvise(mem, size, "random"));
    assert(S.munmap(mem, size));
  },
  test_mlock = function() {
    var size = 4096;
    var mem = assert(S.mmap(null, size, "read", "private, anon", -1, 0));
    var ok, err = S.mlock(mem, size);
    if( ! ok && err.PERM ) { error ("skipped"); } // may not be allowed by default
    assert(ok, err);
    assert(S.munlock(mem, size));
    assert(S.munmap(mem, size));
  },
  test_mlockall = function() {
    if( ! S.mlockall ) { error ("skipped"); }
    var ok, err = S.mlockall("current");
    if( ! ok && err.PERM ) { error ("skipped"); } // may not be allowed by default
    if( ! ok && err.NOMEM ) { error ("skipped"); } // may fail due to rlimit
    assert(ok, err);
    assert(S.munlockall());
  },
};

test_processes = {
  test_nice = function() {
    var n = assert(S.getpriority("process"));
    assert_equal(n, 0, "process should start at priority 0");
    var nn = assert(S.nice(1));
    assert_equal(nn, 1);
    nn = assert(S.setpriority("process", 0, 1)); // sets to 1, which it already is
  },
  test_fork_wait = function() {
    var pid0 = S.getpid();
    assert(pid0 > 1, "expecting my pid to be larger than 1");
    assert(S.getppid() > 1, "expecting my parent pid to be larger than 1");
    var pid = assert(S.fork());
    if( pid == 0 ) { // child
      fork_assert(S.getppid() == pid0, "parent pid should be previous pid");
      S.exit(23);
    } else { // parent
      var rpid, status = assert(S.wait());
      assert(rpid == pid, "expect fork to return same pid as wait");
      assert(status.WIFEXITED, "process should have exited normally");
      assert(status.EXITSTATUS == 23, "exit should be 23");
    }
  },
  test_fork_waitpid = function() {
    var pid0 = S.getpid();
    assert(pid0 > 1, "expecting my pid to be larger than 1");
    assert(S.getppid() > 1, "expecting my parent pid to be larger than 1");
    var pid = assert(S.fork());
    if( pid == 0 ) { // child
      fork_assert(S.getppid() == pid0, "parent pid should be previous pid");
      S.exit(23);
    } else { // parent
      var rpid, status = assert(S.waitpid(-1));
      assert(rpid == pid, "expect fork to return same pid as wait");
      assert(status.WIFEXITED, "process should have exited normally");
      assert(status.EXITSTATUS == 23, "exit should be 23");
    }
  },
  test_fork_waitid = function() {
    if( ! S.waitid ) { error ("skipped"); } // NetBSD at least has no waitid
    var pid0 = S.getpid();
    var pid = assert(S.fork());
    if( pid == 0 ) { // child
      fork_assert(S.getppid() == pid0, "parent pid should be previous pid");
      S.exit(23);
    } else { // parent
      var infop = assert(S.waitid("all", 0, "exited, stopped, continued"));
      assert_equal(infop.signo, c.SIG.CHLD, "waitid to return SIGCHLD");
      assert_equal(infop.signame, "CHLD", "name of signal is CHLD");
      assert_equal(infop.status, 23, "exit should be 23");
      assert_equal(infop.code, c.SIGCLD.EXITED, "normal exit expected");
    }
  },
  test_fork_wait4 = function() {
    var pid0 = S.getpid();
    assert(pid0 > 1, "expecting my pid to be larger than 1");
    assert(S.getppid() > 1, "expecting my parent pid to be larger than 1");
    var pid = assert(S.fork());
    if( pid == 0 ) { // child
      fork_assert(S.getppid() == pid0, "parent pid should be previous pid");
      S.exit(23);
    } else { // parent
      var rpid, status, rusage = assert(S.wait4("any"));
      assert(rpid == pid, "expect fork to return same pid as wait");
      assert(status.WIFEXITED, "process should have exited normally");
      assert(status.EXITSTATUS == 23, "exit should be 23");
      assert(rusage, "expect to get rusage data back");
    }
  },
  test_fork_wait3 = function() {
    var pid0 = S.getpid();
    assert(pid0 > 1, "expecting my pid to be larger than 1");
    assert(S.getppid() > 1, "expecting my parent pid to be larger than 1");
    var pid = assert(S.fork());
    if( pid == 0 ) { // child
      fork_assert(S.getppid() == pid0, "parent pid should be previous pid");
      S.exit(23);
    } else { // parent
      var rpid, status, rusage = assert(S.wait3());
      assert(rpid == pid, "expect fork to return same pid as wait");
      assert(status.WIFEXITED, "process should have exited normally");
      assert(status.EXITSTATUS == 23, "exit should be 23");
      assert(rusage, "expect to get rusage data back");
    }
  },
  test_execve = function() {
    var pid = assert(S.fork());
    if( (pid == 0) ) { // child
      var shell = "/bin/sh";
      if( ! S.stat(shell) ) { shell = "/system/bin/sh"; } // Android has no /bin/sh
      if( ! S.stat(shell) ) { return; } // no shell!
      var script = "#!" .. shell .. [=[

[ $1 = "test" ] || (echo "shell assert $1"; exit 1)
[ $2 = "ing" ] || (echo "shell assert $2"; exit 1)
[ $PATH = "/bin:/usr/bin" ] || (echo "shell assert $PATH"; exit 1)

]=];
      fork_assert(util.writefile(efile, script, "RWXU"));
      fork_assert(S.execve(efile, {efile, "test", "ing"}, {"PATH=/bin:/usr/bin"})); // note first param of args overwritten
      // never reach here
      os.exit();
    } else { // parent
      var rpid, status = assert(S.waitpid("any"));
      assert(rpid == pid, "expect fork to return same pid as wait");
      assert(status.WIFEXITED, "process should have exited normally");
      assert(status.EXITSTATUS == 0, "exit should be 0");
      assert(S.unlink(efile));
    }
  },
  test_setsid = function() {
    // need to fork twice in case start as process leader
    var pp1r, pp1w = assert(S.pipe());
    var pp2r, pp2w = assert(S.pipe());
    var pid = assert(S.fork());
    if( (pid == 0) ) { // child
      pid = fork_assert(S.fork());
      if( (pid == 0) ) { // child
        fork_assert(pp1r->read(null, 1));
        var ok, err = S.setsid();
        ok = ok && ok == S.getpid() && ok == S.getsid();
        if( ok ) { pp2w->write("y"); } else { pp2w->write("n"); }
        S.exit(0);
      } else {
        S.exit(0);
      }
    } else {
      assert(S.wait());
      assert(pp1w->write("a"));
      var ok = pp2r->read(null, 1);
      assert_equal(ok, "y");
      pp1r->close();
      pp1w->close();
      pp2r->close();
      pp2w->close();
    }
  },
  test_setpgid = function() {
    S.setpgid();
    assert_equal(S.getpgid(), S.getpid());
    assert_equal(S.getpgrp(), S.getpid());
  },
};

}

// currently disabled in xen as not much use, probably could add though
if( S.environ && ! abi.xen ) { // use this as a proxy for whether libc functions defined (eg not defined in rump)
test_libc = {
  test_environ = function() {
    var e = S.environ();
    assert(e.PATH, "expect PATH to be set in environment");
    assert(S.setenv("XXXXYYYYZZZZZZZZ", "test"));
    assert(S.environ().XXXXYYYYZZZZZZZZ == "test", "expect to be able to set env vars");
    assert(S.unsetenv("XXXXYYYYZZZZZZZZ"));
    assert(! S.environ().XXXXYYYYZZZZZZZZ, "expect to be able to unset env vars");
  },
};
}

var function removeroottests() {
  for( k in pairs(_G) ) {
    if( k->match("test") ) {
      if( k->match("root")
      ) { _G[k] = null;
      } else {
        for( j in pairs(_G[k]) ) {
          if( j->match("test") && j->match("root") ) { _G[k][j] = null; }
        }
      }
    }
  }
}

// basically largefile on NetBSD is always going to work but tests may not use sparse files so run out of memory
if( S.__rump || abi.xen ) {
  test_largefile = null;
}

// note at present we check for uid 0, but could check capabilities instead.
if( S.geteuid() == 0 ) {
  if( S.unshare ) {
    // cut out this section if you want to (careful!) debug on real interfaces
    var err;
    ok, err = S.unshare("newnet, newns, newuts");
    if( ! ok ) { removeroottests(); // remove if you like, but may interfere with networking
    } else {
      var nl = S.nl;
      var i = assert(nl.interfaces());
      var lo = assert(i.lo);
      assert(lo->up());
      assert(S.mount("none", "/sys", "sysfs"));
    }
  } else { // not Linux
    // run all tests, no namespaces available
  }
} else { // remove tests that need root
  removeroottests();
}

var f;
if( arg[1] ) { f = luaunit->run(unpack(arg)); } else { f = luaunit->run(); }

clean();

debug.sethook();

if( f != 0 ) {
  os.exit(1);
}

collectgarbage("collect");

os.exit(0);


