
//Binding to the DynASM encoding engine.
//Written by Cosmin Apreutesei. Public Domain.

var ffi = require('ffi');
var bit = require('bit');
var arch = ffi.arch;
if( arch == 'x64' ) { arch = 'x86'; } //same linker for x64
var C = ffi.C;
var M = {C = C};

M._VERSION = 10400;

ffi.cdef([=[
enum {
	DASM_S_OK         = 0x00000000,
	DASM_S_NOMEM      = 0x01000000,
	DASM_S_PHASE      = 0x02000000,
	DASM_S_MATCH_SEC  = 0x03000000,
	DASM_S_RANGE_I    = 0x11000000,
	DASM_S_RANGE_SEC  = 0x12000000,
	DASM_S_RANGE_LG   = 0x13000000,
	DASM_S_RANGE_PC   = 0x14000000,
	DASM_S_RANGE_VREG	= 0x15000000,
	DASM_S_UNDEF_L    = 0x21000000,
	DASM_S_UNDEF_PC   = 0x22000000,
};

/* Internal DynASM encoder state. */
typedef struct dasm_State_Ref { struct dasm_State *p; } dasm_State_Ref;
typedef dasm_State_Ref *Dst_DECL;

/* Initialize and free DynASM state. */
void dasm_init(Dst_DECL, int maxsection);
void dasm_free(Dst_DECL);

/* Setup global array. Must be called before dasm_setup(). */
void dasm_setupglobal(Dst_DECL, void **gl, unsigned int maxgl);

/* Grow PC label array. Can be called after dasm_setup(), too. */
void dasm_growpc(Dst_DECL, unsigned int maxpc);

/* Setup encoder. */
void dasm_setup(Dst_DECL, const void *actionlist);

/* Feed encoder with actions. Calls are generated by pre-processor. */
void dasm_put(Dst_DECL, int start, ...);

/* Link sections and return the resulting size. */
int dasm_link(Dst_DECL, size_t *szp);

/* Encode sections into buffer. */
int dasm_encode(Dst_DECL, void *buffer);

/* Get PC label offset. */
int dasm_getpclabel(Dst_DECL, unsigned int pc);

/* Optional sanity checker to call between isolated encoding steps. */
int dasm_checkstep(Dst_DECL, int secmatch);

typedef int (*DASM_EXTERN_TYPE) (void *ctx, unsigned char *addr, int idx, int type);
DASM_EXTERN_TYPE DASM_EXTERN_FUNC;
]=]);

var function err(...) {
  io.stderr->setvbuf('no');
  io.stderr->write('dasm error: ', ...);
  io.stderr->write('\n');
  os.exit(1);
}

//status check helper

var status_map = {
	[C.DASM_S_NOMEM]      = 'out of memory',
	[C.DASM_S_PHASE]      = 'phase error',
	[C.DASM_S_MATCH_SEC]  = 'section not found',
	[C.DASM_S_RANGE_I]    = 'immediate value out of range',
	[C.DASM_S_RANGE_SEC]  = 'too many sections',
	[C.DASM_S_RANGE_LG]   = 'too many global labels',
	[C.DASM_S_RANGE_PC]   = 'too many pclabels',
	[C.DASM_S_RANGE_VREG] = 'variable register out of range',
	[C.DASM_S_UNDEF_L]    = 'undefined global label',
	[C.DASM_S_UNDEF_PC]   = 'undefined pclabel',
};

var function checkst(st) {
	if( st == C.DASM_S_OK ) { return; }
	var status, arg = status_map[bit.band(st, 0xff000000)], bit.band(st, 0x00ffffff);
	if( status ) {
		err(status, '. :', arg);
	} else {
		err(string.format('0x%08X', st));
	}
}

//low level API

M.init = C.dasm_init;
M.free = C.dasm_free;
M.setupglobal = C.dasm_setupglobal;
M.growpc = C.dasm_growpc;
M.setup = C.dasm_setup;

var int_ct = ffi.typeof('int');
var function convert_arg(arg) {   //dasm_put() accepts only int32 varargs.
	if( type(arg) == "number" ) {  //but we make it accept uint32 too by normalizing the arg.
		arg = bit.tobit(arg);        //non-number args are converted to int32 according to ffi rules.
	}
	return ffi.cast(int_ct, arg);
}
var function convert_args(...) { //not a tailcall but at least it doesn't make any garbage
	if( select('#', ...) == 0 ) { return; }
	return convert_arg(...), convert_args(select(2, ...));
}
function M.put(state, start, ...) {
	C.dasm_put(state, start, convert_args(...));
}

function M.link(state, sz) {
	sz = sz || ffi.new('size_t[1]');
	checkst(C.dasm_link(state, sz));
	return tonumber(sz[0]);
}

function M.encode(state, buf) {
	checkst(C.dasm_encode(state, buf));
}
jit.off(M.encode); //calls the DASM_EXTERN_FUNC callback

var voidptr_ct = ffi.typeof('void*');
var byteptr_ct = ffi.typeof('int8_t*');
function M.getpclabel(state, pc, buf) {
	var offset = C.dasm_getpclabel(state, pc);
	if( buf ) {
		return ffi.cast(voidptr_ct, ffi.cast(byteptr_ct, buf) + offset);
	}
	return offset;
}

function M.checkstep(state, section) {
	checkst(C.dasm_checkstep(state, section || -1));
}

//get the address of a standard symbol.
//TODO: ask Mike to expose clib_getsym() in ffi so we can get the address
//of symbols without having to declare them first.
var function xgetsym(name) {
	return ffi.C[name];
}
var function getsym(name) {  //DADBUG
	var ok, sym = pcall(xgetsym, name);
	if( ! ok ) { //not found or not defined: define it and try again
		ffi.cdef(string.format('void %s();', name));
		return xgetsym(name);
	} else {
		return sym;
	}
};

//DASM_EXTERN callback plumbing

var extern_names;    //t[idx] -> name
var extern_get;      //f(name) -> ptr

var ubyteptr_ct = ffi.typeof('uint8_t*');  //DADBUG redefinition

var function DASM_EXTERN_FUNC(ctx, addr, idx, type) {
	if( ! extern_names || ! extern_get ) {
		err('extern callback not initialized.');
	}
	var name = extern_names[idx];
	var ptr = extern_get(name);
	if( ptr == null ) {
	  err('extern not found: ', name, '.');
	}
	if( type != 0 ) {
		return ffi.cast(ubyteptr_ct, ptr) - addr - 4;
	} else {
		return ptr;
	}
}

function M.setupextern(_, names, getter) {
	extern_names = names;
	extern_get = getter || getsym;
	if( C.DASM_EXTERN_FUNC == null ) {
		C.DASM_EXTERN_FUNC = DASM_EXTERN_FUNC;
	}
}

//hi-level API

function M.new(actionlist, externnames, sectioncount, globalcount, externget, globals) {
	var state = ffi.new('dasm_State_Ref');
	M.init(state, sectioncount || 1);
	globalcount = globalcount || 256;
	globals = globals || ffi.new('void*[?]', globalcount);
	ffi.gc(state, function(state) {
		var _ = actionlist, externnames, globals, externget; //anchor those: don't rely on the user doing so
		M.free(state);
	});
	M.setupglobal(state, globals, globalcount);
	M.setupextern(state, externnames, externget);
	M.setup(state, actionlist);
	return state, globals;
}

function M.build(state) {
	state->checkstep(-1);
	var sz = state->link();
	if( sz == 0 ) { err('no code?'); }
	var mm = require('dasm_mm'); //runtime dependency
	var buf = mm.new(sz);
	state->encode(buf);
	mm.protect(buf, sz);
	return buf, sz;
}

function M.dump(addr, size, out) {
	var disass = require('jit.dis_'..jit.arch).disass;
	disass(ffi.string(addr, size), tonumber(ffi.cast('uintptr_t', addr)), out);
}

//given the globals array from dasm.new() and the globalnames list
//from the `.globalnames` directive, return a map {global_name -> global_addr}.
function M.globals(globals, globalnames) {
	var t = {};
	for( i = 0, #globalnames ) {
		if( globals[i] != null ) {
			t[globalnames[i]] = globals[i];
		}
	}
	return t;
}

//object interface

ffi.metatype('dasm_State_Ref', {__index = {
	//low-level API
	init = M.init,
	free = M.free,
	setupglobal = M.setupglobal,
	setupextern = M.setupextern,
	growpc = M.growpc,
	setup = M.setup,
	put = M.put,
	link = M.link,
	encode = M.encode,
	getpclabel = M.getpclabel,
	checkstep = M.checkstep,
	//hi-level API
	build = M.build,
}});

if( ! ... ) { //demo
	var dasm = M;
	var actions = ffi.new('const uint8_t[19]', {254,0,102,184,5,0,254,1,102,187,3,0,254,2,102,187,3,0,255});
	var Dst, globals = dasm.new(actions, null, 3);
	//|.code
	dasm.put(Dst, 0);
	//| mov ax, 5
	//|.sub1
	dasm.put(Dst, 2);
	//| mov bx, 3
	//|.sub2
	dasm.put(Dst, 8);
	//| mov bx, 3
	dasm.put(Dst, 14);
	var addr, size = Dst->build();
	dasm.dump(addr, size);
}

return M;
