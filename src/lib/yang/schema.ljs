// Use of this source code is governed by the Apache 2.0 license; see COPYING.
module(..., package.seeall);

var lib = require("core.lib");
var parser = require("lib.yang.parser");
var util = require("lib.yang.util");

var function error_with_loc(loc, msg, ...) {
   error(string.format("%s: "..msg, loc, ...));
}
var function assert_with_loc(expr, loc, msg, ...) {
   if( ! expr ) { error_with_loc(loc, msg, ...); }
   return expr;
}

var function shallow_copy(node) {
   var out = {};
   for( k,v in pairs(node) ) { out[k] = v; }
   return out;
}

// (kind -> (function(Node) -> value))
var initializers = {};
var function declare_initializer(init, ...) {
   for( _, keyword in ipairs({...}) ) { initializers[keyword] = init; }
}

var function parse_node(src) {
   var ret = {};
   ret.kind = assert(src.keyword, 'missing keyword');
   var children = parse_children(src);
   var initialize = initializers[ret.kind];
   if( initialize ) { initialize(ret, src.loc, src.argument, children); }
   return ret;
}

function parse_children(src) {
   var ret = {};
   for( i, statement in ipairs(src.statements || {}) ) {
      var child = parse_node(statement);
      if( ! ret[child.kind] ) { ret[child.kind] = {}; }
      table.insert(ret[child.kind], child);
   }
   return ret;
}

var function require_argument(loc, argument) {
   return assert_with_loc(argument, loc, 'missing argument');
}

var function parse_range_or_length_arg(loc, kind, range) {
   var function parse_part(part) {
      var l, r = part->match("^%s*([^%.]*)%s*%.%.%s*([^%s]*)%s*$");
      if( ! r ) {
         l = part->match("^%s*([^%.]*)%s*$");
         r = (l != 'min') && l;
      }
      assert_with_loc(l && r, loc, 'bad range component: %s', part);
      if( l != 'min' ) { l = util.tointeger(l); }
      if( r != 'max' ) { r = util.tointeger(r); }
      if( l != 'min' && l < 0 && kind == 'length' ) {
         error("length argument may not be negative: "..l);
      }
      if( r != 'max' && r < 0 && kind == 'length' ) {
         error("length argument may not be negative: "..r);
      }
      if( l != 'min' && r != 'max' && r < l ) {
         error("invalid "..kind..": "..part);
      }
      return { l, r };
   }
   var res = {};
   for( part in range->split("|") ) { table.insert(res, parse_part(part)); }
   if( #res == 0 ) { error_with_loc(loc, "empty "..kind, range); }
   return res;
}

var function collect_children(children, kinds) {
   if( type(kinds) == 'string' ) {
      return collect_children(children, {kinds});
   }
   var ret = {};
   for( _, kind in ipairs(kinds) ) {
      if( children[kind] ) {
         for( _, child in pairs(children[kind]) ) {
            table.insert(ret, child);
         }
      }
   }
   return ret;
}

var function collect_children_by_prop(loc, children, kinds, prop) {
   var ret = {};
   for( _, child in ipairs(collect_children(children, kinds)) ) {
      assert_with_loc(child[prop], loc, 'child of kind %s missing prop %s',
                      child.kind, prop);
      assert_with_loc(! ret[child[prop]], loc, 'duplicate %s: %s',
                      prop, child[prop]);
      ret[child[prop]] = child;
   }
   return ret;
}

var function collect_children_by_id(loc, children, kinds) {
   return collect_children_by_prop(loc, children, kinds, 'id');
}

var function collect_body_children(loc, children) {
   return collect_children_by_id(
      loc, children,
      {'container', 'leaf', 'list', 'leaf-list', 'uses', 'choice', 'anyxml'});
}

var function at_least_one(tab) {
   for( k, v in pairs(tab) ) { return true; }
   return false;
}

var function collect_body_children_at_least_1(loc, children) {
   var ret = collect_body_children(loc, children);
   if( ! at_least_one(ret) ) {
      error_with_loc(loc, "missing data statements");
   }
   return ret;
}

var function collect_data_or_case_children_at_least_1(loc, children) {
   var ret = collect_children_by_id(
      loc, children,
      {'container', 'leaf', 'list', 'leaf-list', 'uses', 'choice',
       'anyxml', 'case'});
   if( ! at_least_one(ret) ) {
      error_with_loc(loc, "missing data statements");
   }
   return ret;
}

var function collect_child_properties(children, kind, field) {
   var ret = {};
   for( _, child in ipairs(collect_children(children, kind)) ) {
      table.insert(ret, child[field]);
   }
   return ret;
}

var function maybe_child(loc, children, kind) {
   children = collect_children(children, kind);
   if( #children > 1 ) {
      error_with_loc(loc, 'expected at most one child of type %s', kind);
   }
   return children[1];
}

var function maybe_child_property(loc, children, kind, prop) {
   var child = maybe_child(loc, children, kind);
   if( child ) { return child[prop]; }
}

var function require_child(loc, children, kind) {
   var child = maybe_child(loc, children, kind);
   if( child ) { return child; }
   error_with_loc(loc, 'missing child of type %s', kind);
}

var function require_child_property(loc, children, kind, prop) {
   return require_child(loc, children, kind)[prop];
}

// Simple statement kinds with string, natural, or boolean values all
// just initialize by parsing their argument and storing it as the
// "value" property in the schema node.
var function init_string(node, loc, argument, children) {
   node.value = require_argument(loc, argument);
}
var function init_natural(node, loc, argument, children) {
   var arg = require_argument(loc, argument);
   var as_num = tonumber(arg);
   assert_with_loc(as_num && math.floor(as_num) == as_num && as_num >= 0,
                   loc, 'not a natural number: %s', arg);
   node.value = as_num;
}
// Must be one or 1 or 1.1.
var function init_yang_version (node, loc, argument, children) {
   var arg = require_argument(loc, argument);
   assert_with_loc(arg == "1" || arg == "1.1", 'not a valid version number: %s', arg);
   node.value = tonumber(arg);
}
var function init_boolean(node, loc, argument, children) {
   var arg = require_argument(loc, argument);
   if( arg == 'true' ) { node.value = true;
   } else if( arg == 'false' ) { node.value = false;
   } else { error_with_loc(loc, 'not a valid boolean: %s', arg); }
}

// For all other statement kinds, we have custom initializers that
// parse out relevant sub-components and store them as named
// properties on the schema node.
var function init_anyxml(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.must = collect_child_properties(children, 'must', 'value');
   node.config = maybe_child_property(loc, children, 'config', 'value');
   node.mandatory = maybe_child_property(loc, children, 'mandatory', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_argument(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.yin_element = maybe_child_property(loc, children, 'yin-element', 'value');
}
var function init_augment(node, loc, argument, children) {
   node.node_id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.body = collect_data_or_case_children_at_least_1(loc, children);
}
var function init_belongs_to(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.prefix = require_child(loc, children, 'prefix').value;
}
var function init_case(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.body = collect_body_children(loc, children);
}
var function init_choice(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.default = maybe_child_property(loc, children, 'default', 'value');
   node.config = maybe_child_property(loc, children, 'config', 'value');
   node.mandatory = maybe_child_property(loc, children, 'mandatory', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.body = collect_children_by_id(
      loc, children,
      {'container', 'leaf', 'leaf-list', 'list', 'anyxml', 'case'});
}
var function init_container(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.must = collect_child_properties(children, 'must', 'value');
   node.presence = maybe_child_property(loc, children, 'presence', 'value');
   node.config = maybe_child_property(loc, children, 'config', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.body = collect_body_children(loc, children);
}
var function init_extension(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.argument = maybe_child_property(loc, children, 'argument', 'id');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_feature(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_grouping(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.body = collect_body_children(loc, children);
}
var function init_identity(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.bases = collect_child_properties(children, 'base', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_import(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.prefix = require_child_property(loc, children, 'prefix', 'value');
   node.revision_date = maybe_child_property(loc, children, 'revision-date', 'value');
}
var function init_include(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.revision_date = maybe_child_property(loc, children, 'revision-date', 'value');
}
var function init_input(node, loc, argument, children) {
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.body = collect_body_children_at_least_1(loc, children);
}
var function init_leaf(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.type = require_child(loc, children, 'type');
   node.units = maybe_child_property(loc, children, 'units', 'value');
   node.must = collect_child_properties(children, 'must', 'value');
   node.default = maybe_child_property(loc, children, 'default', 'value');
   node.config = maybe_child_property(loc, children, 'config', 'value');
   node.mandatory = maybe_child_property(loc, children, 'mandatory', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_leaf_list(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.type = require_child(loc, children, 'type');
   node.units = maybe_child_property(loc, children, 'units', 'value');
   node.must = collect_child_properties(children, 'must', 'value');
   node.config = maybe_child_property(loc, children, 'config', 'value');
   node.min_elements = maybe_child_property(loc, children, 'min-elements', 'value');
   node.max_elements = maybe_child_property(loc, children, 'max-elements', 'value');
   node.ordered_by = maybe_child_property(loc, children, 'ordered-by', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_length(node, loc, argument, children) {
   node.value = parse_range_or_length_arg(loc, node.kind,
                                          require_argument(loc, argument));
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_list(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.must = collect_child_properties(children, 'must', 'value');
   node.key = maybe_child_property(loc, children, 'key', 'value');
   node.unique = collect_child_properties(children, 'unique', 'value');
   node.config = maybe_child_property(loc, children, 'config', 'value');
   node.min_elements = maybe_child_property(loc, children, 'min-elements', 'value');
   node.max_elements = maybe_child_property(loc, children, 'max-elements', 'value');
   node.ordered_by = maybe_child_property(loc, children, 'ordered-by', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.body = collect_body_children_at_least_1(loc, children);
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_module(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.yang_version = maybe_child_property(loc, children, 'yang-version', 'value');
   node.namespace = require_child_property(loc, children, 'namespace', 'value');
   node.prefix = require_child_property(loc, children, 'prefix', 'value');
   node.imports = collect_children_by_prop(loc, children, 'import', 'prefix');
   node.includes = collect_children_by_id(loc, children, 'include');
   node.organization = maybe_child_property(loc, children, 'organization', 'value');
   node.contact = maybe_child_property(loc, children, 'contact', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.revisions = collect_children(children, 'revision');
   node.augments = collect_children(children, 'augment');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.features = collect_children_by_id(loc, children, 'feature');
   node.extensions = collect_children_by_id(loc, children, 'extension');
   node.identities = collect_children_by_id(loc, children, 'identity');
   node.rpcs = collect_children_by_id(loc, children, 'rpc');
   node.notifications = collect_children_by_id(loc, children, 'notification');
   node.deviations = collect_children_by_id(loc, children, 'deviation');
   node.body = collect_body_children(loc, children);
}
var function init_namespace(node, loc, argument, children) {
   // TODO: parse uri?
   node.value = require_argument(loc, argument);
}
var function init_notification(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.body = collect_body_children(loc, children);
}
var function init_output(node, loc, argument, children) {
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.body = collect_body_children_at_least_1(loc, children);
}
var function init_path(node, loc, argument, children) {
   // TODO: parse path string
   node.value = require_argument(loc, argument);
}
var function init_pattern(node, loc, argument, children) {
   node.value = require_argument(loc, argument);
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_range(node, loc, argument, children) {
   node.value = parse_range_or_length_arg(loc, node.kind,
                                          require_argument(loc, argument));
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_enum(node, loc, argument, children) {
   node.name = require_argument(loc, argument);
   var value = maybe_child_property(loc, children, 'value', 'value');
   if( value ) { node.value = tonumber(value); }
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
}
var function init_refine(node, loc, argument, children) {
   node.node_id = require_argument(loc, argument);
   // All subnode kinds.
   node.must = collect_child_properties(children, 'must', 'value');
   node.config = maybe_child_property(loc, children, 'config', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   // Containers.
   node.presence = maybe_child_property(loc, children, 'presence', 'value');
   // Leaves, choice, and (for mandatory) anyxml.
   node.default = maybe_child_property(loc, children, 'default', 'value');
   node.mandatory = maybe_child_property(loc, children, 'mandatory', 'value');
   // Leaf lists and lists.
   node.min_elements = maybe_child_property(loc, children, 'min-elements', 'value');
   node.max_elements = maybe_child_property(loc, children, 'max-elements', 'value');
}
var function init_revision(node, loc, argument, children) {
   // TODO: parse date
   node.value = require_argument(loc, argument);
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_rpc(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.input = maybe_child(loc, children, 'input');
   node.output = maybe_child(loc, children, 'output');
}
var function init_type(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.range = maybe_child(loc, children, 'range');
   node.fraction_digits = maybe_child_property(loc, children, 'fraction-digits', 'value');
   node.length = maybe_child(loc, children, 'length');
   node.patterns = collect_children(children, 'pattern');
   node.enums = collect_children(children, 'enum');
   // !!! path
   node.leafref = maybe_child_property(loc, children, 'path', 'value');
   node.require_instances = collect_children(children, 'require-instance');
   node.bases = collect_child_properties(children, 'base', 'value');
   node.union = collect_children(children, 'type');
   node.bits = collect_children(children, 'bit');
}
var function init_submodule(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.yang_version = maybe_child_property(loc, children, 'yang-version', 'value');
   node.belongs_to = require_child(loc, children, 'belongs-to');
   node.imports = collect_children_by_id(loc, children, 'import');
   node.includes = collect_children_by_id(loc, children, 'include');
   node.organization = maybe_child_property(loc, children, 'organization', 'value');
   node.contact = maybe_child_property(loc, children, 'contact', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.revisions = collect_children(children, 'revision');
   node.augments = collect_children(children, 'augment');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.groupings = collect_children_by_id(loc, children, 'grouping');
   node.features = collect_children_by_id(loc, children, 'feature');
   node.extensions = collect_children_by_id(loc, children, 'extension');
   node.identities = collect_children_by_id(loc, children, 'identity');
   node.rpcs = collect_children_by_id(loc, children, 'rpc');
   node.notifications = collect_children_by_id(loc, children, 'notification');
   node.deviations = collect_children_by_id(loc, children, 'deviation');
   node.body = collect_body_children(loc, children);
}
var function init_typedef(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.type = require_child(loc, children, 'type');
   node.units = maybe_child_property(loc, children, 'units', 'value');
   node.default = maybe_child_property(loc, children, 'default', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
}
var function init_uses(node, loc, argument, children) {
   node.id = require_argument(loc, argument);
   node.when = maybe_child_property(loc, children, 'when', 'value');
   node.if_features = collect_child_properties(children, 'if-feature', 'value');
   node.status = maybe_child_property(loc, children, 'status', 'value');
   node.description = maybe_child_property(loc, children, 'description', 'value');
   node.reference = maybe_child_property(loc, children, 'reference', 'value');
   node.typedefs = collect_children_by_id(loc, children, 'typedef');
   node.refines = collect_children(children, 'refine');
   node.augments = collect_children(children, 'augment');
}
var function init_value(node, loc, argument, children) {
   var arg = require_argument(loc, argument);
   var as_num = tonumber(arg);
   assert_with_loc(as_num && math.floor(as_num) == as_num,
                   loc, 'not an integer: %s', arg);
   node.value = as_num;
}

declare_initializer(
   init_string, 'prefix', 'organization', 'contact', 'description',
   'reference', 'units',  'revision-date', 'base','if-feature',
   'default', 'enum', 'bit', 'status', 'presence', 'ordered-by', 'must',
   'error-message', 'error-app-tag', 'max-value', 'key', 'unique', 'when',
   'deviation', 'deviate');
declare_initializer(
   init_natural, 'fraction-digits', 'position', 'min-elements', 'max-elements');
declare_initializer(init_yang_version, 'yang-version');
declare_initializer(
   init_boolean, 'config', 'mandatory', 'require-instance', 'yin-element');
declare_initializer(init_anyxml, 'anyxml');
declare_initializer(init_argument, 'argument');
declare_initializer(init_augment, 'augment');
declare_initializer(init_belongs_to, 'belongs-to');
declare_initializer(init_case, 'case');
declare_initializer(init_choice, 'choice');
declare_initializer(init_container, 'container');
declare_initializer(init_extension, 'extension');
declare_initializer(init_feature, 'feature');
declare_initializer(init_grouping, 'grouping');
declare_initializer(init_identity, 'identity');
declare_initializer(init_import, 'import');
declare_initializer(init_include, 'include');
declare_initializer(init_input, 'input');
declare_initializer(init_leaf, 'leaf');
declare_initializer(init_leaf_list, 'leaf-list');
declare_initializer(init_length, 'length');
declare_initializer(init_list, 'list');
declare_initializer(init_module, 'module');
declare_initializer(init_namespace, 'namespace');
declare_initializer(init_notification, 'notification');
declare_initializer(init_output, 'output');
declare_initializer(init_path, 'path');
declare_initializer(init_pattern, 'pattern');
declare_initializer(init_range, 'range');
declare_initializer(init_enum, 'enum');
declare_initializer(init_refine, 'refine');
declare_initializer(init_revision, 'revision');
declare_initializer(init_rpc, 'rpc');
declare_initializer(init_submodule, 'submodule');
declare_initializer(init_type, 'type');
declare_initializer(init_typedef, 'typedef');
declare_initializer(init_uses, 'uses');
declare_initializer(init_value, 'value');

var function schema_from_ast(ast) {
   var ret;
   var submodules = {};
   for( _,node in ipairs(ast) ) {
      if( node.keyword == 'module' ) {
         assert(! ret, 'expected only one module form');
         ret = parse_node(node);
      } else if( node.keyword == 'submodule' ) {
         assert(! submodules[node.id], 'duplicate submodule name: '..node.id);
         submodules[node.id] = parse_node(node);
      } else {
         error('expected only module and submodule statements, got: '..node.keyword);
      }
   }
   assert(ret, 'missing module form');
   ret.submodules = submodules;
   return ret;
}

var primitive_types = lib.set(
   'int8', 'int16', 'int32', 'int64', 'uint8', 'uint16', 'uint32', 'uint64',
   'binary', 'bits', 'boolean', 'decimal64', 'empty', 'enumeration',
   'identityref', 'instance-identifier', 'leafref', 'string', 'union');

// Inherits config attributes from parents
var function inherit_config(schema) {
   var function visit(node, config) {
      if( node.config == null ) {
         node = shallow_copy(node);
         node.config = config;
      } else if( node.config == false ) {
         config = node.config;
      } else {
         assert(config);
      }

      if( node.body ) {
         node.body = shallow_copy(node.body);
         for( name, child in pairs(node.body) ) {
            node.body[name] = visit(child, config);
         }
      }
      return node;
   }

   return visit(schema, true);
}

var default_features = {};
function get_default_capabilities() {
   var ret = {};
   for( mod,features in pairs(default_features) ) {
      var feature_names = {};
      for( feature,_ in pairs(features) ) {
         table.insert(feature_names, feature);
      }
      ret[mod] = { feature = feature_names };
   }
   return ret;
}
function set_default_capabilities(capabilities) {
   default_features = {};
   for( mod,caps in pairs(capabilities) ) {
      default_features[mod] = {};
      for( _,feature in ipairs(caps.feature) ) {
         default_features[mod][feature] = true;
      }
   }
}

// Inline "grouping" into "uses".
// Inline "submodule" into "include".
// Inline "imports" into "module".
// Inline "typedef" into "type".
// Resolve if-feature, identity bases, and identityref bases.
// Warn on any "when", resolving them as being true.
// Resolve all augment nodes. (TODO)
function resolve(schema, features) {
   if( features == null ) { features = default_features; }
   var function pop_prop(node, prop) {
      var val = node[prop];
      node[prop] = null;
      return val;
   }
   var function lookup(env, prop, name) {
      if( ! env ) { error(prop..' not found: '..name); }
      if( ! env[prop] || ! env[prop][name] ) {
         return lookup(env.env, prop, name);
      }
      return env[prop][name];
   }
   var function lookup_lazy(env, prop, name) {
      var val = lookup(env, prop, name);
      if( type(val) == 'table' ) { return val; }
      // Force lazy expansion and memoize result.
      return val();
   }
   var visit;
   var function visit_top_level(node, env, prop) {
      assert(! env[prop]);
      env[prop] = {};
      var p = lookup(env, 'prefix', '_');
      for( k,v in pairs(pop_prop(node, prop) || {}) ) {
         env[prop][k] = visit(v, env);
         env[prop][p..':'..k] = env[prop][k];
      }
   }
   var function visit_lazy(tab, env) {
      var ret = {};
      var prefix = lookup(env, 'prefix', '_');
      var function error_recursion() {
      }
      for( k,v in pairs(tab) ) {
         // FIXME: Only add prefix:k if at top level.
         var state;
         var function lazy() {
            if( state == 'visiting' ) {
               error('mutually recursive definitions: '..k);
            } else if( state ) {
               return state;
            } else {
               state = 'visiting';
            }
            state = visit(v, env);
            return state;
         }
         ret[k] = lazy;
         ret[prefix..':'..k] = ret[k];
      }
      return ret;
   }
   // Resolve argument of "base" statements to identity fqid and collect in a list.
   var function resolve_bases(bases, env) {
      var ret = {};
      for( _, base in ipairs(bases) ) {
         table.insert(ret, lookup_lazy(env, 'identities', base).fqid);
      }
      return ret;
   }
   var function visit_type(node, env) {
      node = shallow_copy(node);
      var success, typedef = pcall(lookup, env, 'typedefs', node.id);
      if( success ) {
         // Typedefs are lazy, so force their value.  We didn't use
         // lookup_lazy because we don't want the pcall to hide errors
         // from the lazy expansion.
         typedef = typedef();
         assert(typedef.kind == "typedef");
         node.base_type = typedef;
         node.primitive_type = assert(typedef.primitive_type);
         node.enums = {};
         for( _, enum in ipairs(typedef.type.enums) ) {
            node.enums[enum.name] = true;
         }
         node.union = typedef.type.union;
      } else {
         // If the type name wasn't bound, it must be primitive.
         assert(primitive_types[node.id], 'unknown type: '..node.id);
         if( node.id == 'union' ) {
            var union = {};
            for( _,type in ipairs(node.union) ) {
               table.insert(union, visit_type(type, env));
            }
            node.union = union;
         } else if( node.id == 'identityref' ) {
            node.bases = resolve_bases(node.bases, env);
            node.default_prefix = schema.id;
         }
         node.primitive_type = node.id;
      }
      return node;
   }
   // Already made "local" above.
   function visit(node, env) {
      node = shallow_copy(node);
      env = {env=env};
      if( node.typedefs ) {
         // Populate node.typedefs as a table of thunks that will
         // lazily expand and memoize their result when called.  This
         // is not only a performance optimization but also allows the
         // typedefs to be mutually visible.
         env.typedefs = visit_lazy(pop_prop(node, 'typedefs'), env);
      }
      if( node.groupings ) {
         // Likewise expand groupings at their point of definition.
         env.groupings = visit_lazy(pop_prop(node, 'groupings'), env);
      }
      var when = pop_prop(node, 'when');
      if( when ) {
         print('warning: assuming "when" condition to be true: '..when.value);
      }
      if( node.kind == 'module' || node.kind == 'submodule' ) {
         visit_top_level(node, env, 'extensions');
         // Because features can themselves have if-feature, and
         // identities can reference each other, expand them lazily.
         env.features = visit_lazy(pop_prop(node, 'features'), env);
         env.identities = visit_lazy(pop_prop(node, 'identities'), env);
         for( _,prop in ipairs({'rpcs', 'notifications'}) ) {
            node[prop] = shallow_copy(node[prop]);
            for( k,v in pairs(node[prop]) ) { node[prop][k] = visit(v, env); }
         }
      }
      if( node.kind == 'rpc' ) {
         if( node.input ) { node.input = visit(node.input, env); }
         if( node.output ) { node.output = visit(node.output, env); }
      }
      if( node.kind == 'identity' ) {
         // Attach fully-qualified identity.
         node.fqid = lookup(env, 'module_id', '_')..":"..node.id;
         node.bases = resolve_bases(node.bases, env);
      }
      if( node.kind == 'feature' ) {
         node.module_id = lookup(env, 'module_id', '_');
         if( ! (features[node.module_id] || {})[node.id] ) {
            node.unavailable = true;
         }
      }
      for( _,feature in ipairs(pop_prop(node, 'if_features') || {}) ) {
         var feature_node = lookup_lazy(env, 'features', feature);
         if( node.kind == 'feature' ) {
            // This is a feature that depends on a feature.  These we
            // keep in the environment but if the feature is
            // unavailable, we mark it as such.
            var mod, id = feature_node.module_id, feature_node.id;
            if( ! (features[mod] || {})[id] ) { node.unavailable = true; }
         } else if( feature_node.unavailable ) {
            return null, env;
         }
      }
      if( node.type ) {
         node.type = visit_type(node.type, env);
         if( ! node.primitive_type ) {
            node.primitive_type = node.type.primitive_type;
         }
      }
      if( node.body ) {
         var body = node.body;
         node.body = {};
         for( k,v in pairs(body) ) {
            if( v.kind == 'uses' ) {
               // Inline "grouping" into "uses".
               var grouping = lookup_lazy(env, 'groupings', v.id);
               for( xk,xv in pairs(grouping.body) ) {
                  assert(! node.body[xk], 'duplicate identifier: '..xk);
                  node.body[xk] = xv;
               }
               for( _,refine in ipairs(v.refines) ) {
                  var target = node.body[refine.node_id];
                  assert(target, 'missing refine node: '..refine.node_id);
                  // FIXME: Add additional "must" statements.
                  for( _,xk in ipairs({'config', 'description', 'reference',
                                     'presence', 'default', 'mandatory',
                                     'min_elements', 'max_elements'}) ) {
                     if( refine[xk] != null ) { target[xk] = refine[xk]; }
                  }
               }
               // TODO: Handle augment statements.
            } else {
               assert(! node.body[k], 'duplicate identifier: '..k);
               node.body[k] = visit(v, env);
            }
         }
      }
      // Mark "key" children of lists as being mandatory.
      if( node.kind == 'list' && node.key ) {
         for( k in node.key->split(' +') ) {
            var leaf = assert(node.body[k]);
            leaf.mandatory = true;
         }
      }
      return node, env;
   }
   var function include(dst, src) {
      for( k,v in pairs(src) ) {
         assert(dst[k] == null || dst[k] == v, 'incompatible definitions: '..k);
         if( ! k->match(':') ) { dst[k] = v; }
      }
   }
   var linked = {};
   var function link(node, env) {
      if( linked[node.id] ) {
         assert(linked[node.id] != 'pending', 'recursive import of '..node.id);
         node, env = unpack(linked[node.id]);
         return node, env;
      }
      linked[node.id] = 'pending';
      node = shallow_copy(node);
      var module_env = {env=env, prefixes={}, extensions={}, features={},
                          identities={}, typedefs={}, groupings={},
                          module_id={_=node.id}};
      node.body = shallow_copy(node.body);
      node.rpcs = shallow_copy(node.rpcs);
      node.notifications = shallow_copy(node.notifications);
      for( k,v in pairs(pop_prop(node, 'includes')) ) {
         var submodule = lookup(env, 'submodules', k);
         assert(submodule.belongs_to.id == node.id);
         submodule, submodule_env = link(submodule, env);
         include(module_env.extensions, submodule_env.extensions);
         include(module_env.features, submodule_env.features);
         include(module_env.identities, submodule_env.identities);
         include(module_env.typedefs, submodule_env.typedefs);
         include(module_env.groupings, submodule_env.groupings);
         include(node.body, submodule.body);
         include(node.rpcs, submodule.rpcs);
         include(node.notifications, submodule.notifications);
      }
      if( node.prefix ) {
         assert(node.kind == 'module', node.kind);
         module_env.prefixes[node.prefix] = node.id;
         module_env.prefix = {_=node.prefix};
      }
      for( k,v in pairs(pop_prop(node, 'imports')) ) {
         assert(! module_env.prefixes[v.prefix], 'duplicate prefix');
         // CHECKME: Discarding body from import, just importing env.
         // Is this OK?
	 var schema;
         schema, env = load_schema_by_name(v.id, v.revision_date);
         var prefix = v.prefix;
         module_env.prefixes[prefix] = schema.id;
         for( _,prop in ipairs({'extensions', 'features', 'identities',
                               'typedefs', 'groupings'}) ) {
            for( xk,xv in pairs(env[prop]) ) {
               if( ! xk->match(':') ) {
                  module_env[prop][prefix..':'..xk] = xv;
               }
            }
         }
      }
      node, env = visit(node, module_env);
      // The typedefs, groupings, identities, and so on of this module
      // are externally visible for other modules that may import this
      // one; save them and their environment.
      linked[node.id] = {node, env};
      return node, env;
   }
   schema = shallow_copy(schema);
   return link(schema, {submodules=pop_prop(schema, 'submodules')});
}

var xprimitive_types = { //DADBUG redefinition
   ['ietf-inet-types']=lib.set('ipv4-address', 'ipv6-address',
                           'ipv4-prefix', 'ipv6-prefix'),
   ['ietf-yang-types']=lib.set('mac-address')
};

// NB: mutates schema in place!
var function primitivize(schema) {
   for( k, _ in pairs(xprimitive_types[schema.id] || {}) ) {
      assert(schema.typedefs[k]).primitive_type = k;
   }
   return schema;
}

function parse_schema(src, filename) {
   return schema_from_ast(parser.parse(src, filename));
}
function parse_schema_file(filename) {
   return schema_from_ast(parser.parse_file(filename));
}

function load_schema(src, filename) {
   var s, e = resolve(primitivize(parse_schema(src, filename)));
   return inherit_config(s), e;
}
function load_schema_file(filename) {
   var s, e = resolve(primitivize(parse_schema_file(filename)));
   return inherit_config(s), e;
}
load_schema_file = util.memoize(load_schema_file);

function load_schema_source_by_name(name, revision) {
   // FIXME: @ is not valid in a Lua module name.
   // if revision then name = name .. '@' .. revision end
   name = name->gsub('-', '_');
   return require('lib.yang.'..name..'_yang');
}

function load_schema_by_name(name, revision) {
   return load_schema(load_schema_source_by_name(name, revision));
}
load_schema_by_name = util.memoize(load_schema_by_name);

function add_schema(src, filename) {
   // Assert that the source actually parses, and get the ID.
   var s, e = load_schema(src, filename);
   // Assert that this schema isn't known.
   assert(! pcall(load_schema_source_by_name, s.id));
   assert(s.id);
   // Intern.
   package.loaded['lib.yang.'..s.id->gsub('-', '_')..'_yang'] = src;
   return s.id;
}

function add_schema_file(filename) {
   var file_in = assert(io.open(filename));
   var contents = file_in->read("*a");
   file_in->close();
   return add_schema(contents, filename);
}

function lookup_identity (fqid) {
   var schema_name, id = fqid->match("^([^:]*):(.*)$");
   var schema, env = load_schema_by_name(schema_name);
   var id_thunk = env.identities[id];
   if( ! id_thunk ) {
      error('no identity '..id..' in module '..schema_name);
   }
   return id_thunk(); // Force the lazy lookup.
}
lookup_identity = util.memoize(lookup_identity);

function identity_is_instance_of (identity, fqid) {
   for( _, base in ipairs(identity.bases) ) {
      if( base == fqid ) { return true; }
      var base_id = lookup_identity(base);
      if( identity_is_instance_of(base_id, fqid) ) { return true; }
   }
   return false;
}
identity_is_instance_of = util.memoize(identity_is_instance_of);

function selftest() {
   print('selftest: lib.yang.schema');

   set_default_capabilities(get_default_capabilities());

   var test_schema = [=[module fruit {
      namespace "urn:testing:fruit";
      prefix "fruit";

      import ietf-inet-types {prefix inet; }
      import ietf-yang-types {prefix yang; }

      organization "Fruit Inc.";

      contact "John Smith fake@person.tld";

      description "Module to test YANG schema lib";

      revision 2016-05-27 {
         description "Revision 1";
         reference "tbc";
      }

      revision 2016-05-28 {
         description "Revision 2";
         reference "tbc";
      }

      feature bowl {
         description "A fruit bowl";
         reference "fruit-bowl";
      }

      identity foo;
      identity bar { base foo; }
      identity baz { base bar; base foo; }

      grouping fruit {
         description "Represents a piece of fruit";

         leaf name {
            type string;
            mandatory true;
            description "Name of fruit.";
         }

         leaf score {
            type uint8 {
               range 0..10;
            }
            mandatory true;
            description "How nice is it out of 10";
         }

         leaf tree-grown {
            type boolean;
            description "Is it grown on a tree?";
         }
      }

      container fruit-bowl {
         description "Represents a fruit bowl";

         leaf description {
            type string;
            description "About the bowl";
         }

         list contents {
            uses fruit;
         }
      }
   }]=];

   var schema, env = load_schema(test_schema);
   assert(schema.id == "fruit");
   assert(schema.namespace == "urn:testing:fruit");
   assert(schema.prefix == "fruit");
   assert(schema.contact == "John Smith fake@person.tld");
   assert(schema.organization == "Fruit Inc.");
   assert(schema.description == "Module to test YANG schema lib");

   // Check all revisions are accounted for.
   assert(schema.revisions[1].description == "Revision 1");
   assert(schema.revisions[1].value == "2016-05-27");
   assert(schema.revisions[2].description == "Revision 2");
   assert(schema.revisions[2].value == "2016-05-28");

   // Check that the feature statements are in the exports interface
   // but not the schema itself.
   assert(! schema.features);
   assert(env.features["bowl"]);
   // Poke through lazy features abstraction by invoking thunk.
   assert(env.features["bowl"]().description == 'A fruit bowl');

   // Poke through lazy identity bases by invoking thunk.
   assert(#env.identities["baz"]().bases == 2);
   assert(#env.identities["bar"]().bases == 1);
   assert(env.identities["bar"]().bases[1] == 'fruit:foo');
   assert(#env.identities["foo"]().bases == 0);

   assert(#lookup_identity("ietf-alarms:alarm-identity").bases == 0);

   // Check that groupings get inlined into their uses.
   assert(schema.body['fruit-bowl']);
   assert(schema.body['fruit-bowl'].description == 'Represents a fruit bowl');
   var contents = schema.body['fruit-bowl'].body['contents'];
   assert(contents);
   assert(contents.kind == 'list');
   // TODO: Copy description over?  Probably not given that one node
   // can use multiple groupings.
   // assert(contents.description == 'Represents a piece of fruit')
   assert(contents.body['name'].kind == 'leaf');
   assert(contents.body['name'].type.id == 'string');
   assert(contents.body["name"].mandatory == true);
   assert(contents.body["name"].description == "Name of fruit.");
   assert(contents.body["score"].type.id == "uint8");
   assert(contents.body["score"].mandatory == true);
   var equal = require('core.lib').equal;
   assert(equal(contents.body["score"].type.range.value, {{0, 10}}));

   // Check the container has a leaf called "description"
   var desc = schema.body["fruit-bowl"].body['description'];
   assert(desc.type.id == "string");
   assert(desc.description == "About the bowl");

   parse_schema(require('lib.yang.ietf_yang_types_yang'));
   parse_schema(require('lib.yang.ietf_inet_types_yang'));

   load_schema_by_name('ietf-yang-types');

   // We could save and restore capabilities to avoid the persistent
   // side effect, but it would do no good:  the schemas would be
   // memoized when the features were present.  So just add to the
   // capabilities, for now, assuming tests are run independently from
   // programs.
   var caps = get_default_capabilities();
   var new_caps = { ['ietf-softwire-br'] = {feature={'binding'}} };
   for( mod_name, mod_caps in pairs(new_caps) ) {
      if( ! caps[mod_name] ) { caps[mod_name] = {feature={}}; }
      for( _,feature in ipairs(mod_caps.feature) ) {
         table.insert(caps[mod_name].feature, feature);
      }
   }
   set_default_capabilities(caps);

   load_schema_by_name('ietf-softwire-common');
   load_schema_by_name('ietf-softwire-br');
   load_schema_by_name('snabb-softwire-v2');

   var br = load_schema_by_name('ietf-softwire-br');
   var binding = br.body['br-instances'].body['br-type'].body['binding'];
   assert(binding);
   var bt = binding.body['binding'].body['br-instance'].body['binding-table'];
   assert(bt);
   var ps = bt.body['binding-entry'].body['port-set'];
   assert(ps);
   // The binding-entry grouping is defined in ietf-softwire-common and
   // imported by ietf-softwire-br, but with a refinement that the
   // default is 0.  Test that the refinement was applied.
   assert(ps.body['psid-offset'].default == "0");

   var inherit_config_schema = [=[module config-inheritance {
      namespace cs;
      prefix cs;

      container foo {
         container bar {
            config false;

            leaf baz {
               type uint8;
            }
         }
      }

      grouping quux {
         leaf quuz {
            type uint8;
         }
      }

      container corge { uses quux; }
      container grault { config true; uses quux; }
      container garply { config false; uses quux; }
   }]=];

   var icschema = load_schema(inherit_config_schema);

   // Test things that should be null, still are.
   assert(icschema.config == true);
   assert(icschema.body.foo.config == true);

   // Assert the regular config is propergated through container.
   assert(icschema.body.foo.body.bar.config == false);
   assert(icschema.body.foo.body.bar.body.baz.config == false);

   // Now test the grouping, we need to ensure copying is done correctly.
   assert(icschema.body.corge.config == true);
   assert(icschema.body.corge.body.quuz.config == true);
   assert(icschema.body.grault.config == true);
   assert(icschema.body.grault.body.quuz.config == true);
   assert(icschema.body.garply.config == false);
   assert(icschema.body.garply.body.quuz.config == false);

   // Test Range with explicit value.
   assert(lib.equal(parse_range_or_length_arg(null, null, "42"), {{42, 42}}));

   print('selftest: ok');
}
