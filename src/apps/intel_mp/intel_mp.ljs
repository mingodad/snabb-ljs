// intel_mp: Device driver app for Intel 1G and 10G network cards
// It supports
//    - Intel1G i210 and i350 based 1G network cards
//    - Intel82599 82599 based 10G network cards
// The driver supports multiple processes connecting to the same physical nic.
// Per process RX / TX queues are available via RSS. Statistics collection
// processes can read counter registers
//
// Data sheets (reference documentation):
// http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/ethernet-controller-i350-datasheet.pdf
// http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/i210-ethernet-controller-datasheet.pdf
// http://www.intel.co.uk/content/dam/www/public/us/en/documents/datasheets/82599-10-gbe-controller-datasheet.pdf
// Note: section and page numbers in the comments below refer to the i210 data sheet

module(..., package.seeall);

var ffi         = require("ffi");
var C           = ffi.C;
var pci         = require("lib.hardware.pci");
var band, bor, lshift = bit.band, bit.bor, bit.lshift;
var lib         = require("core.lib");
var bits        = lib.bits;
var tophysical  = core.memory.virtual_to_physical;
var register    = require("lib.hardware.register");
var counter     = require("core.counter");
var macaddress  = require("lib.macaddress");
var shm         = require("core.shm");
var alarms      = require("lib.yang.alarms");
var S           = require("syscall");

var CallbackAlarm = alarms.CallbackAlarm;
var transmit, receive, empty = link.transmit, link.receive, link.empty;

// It's not clear what address to use for EEMNGCTL_i210 DPDK PMD / linux e1000
// both use 1010 but the docs say 12030
// https://sourceforge.net/p/e1000/mailman/message/34457421/
// http://dpdk.org/browse/dpdk/tree/drivers/net/e1000/base/e1000_regs.h

reg = { };
reg.gbl = {
   array = [=[
RETA        0x5c00 +0x04*0..31      RW Redirection Table
RSSRK       0x5C80 +0x04*0..9       RW RSS Random Key
]=],
   singleton = [=[
BPRC        0x04078 -               RC Broadcast Packets Received Count
BPTC        0x040F4 -               RC Broadcast Packets Transmitted Count
CTRL        0x00000 -               RW Device Control
CTRL_EXT    0x00018 -               RW Extended Device Control
STATUS      0x00008 -               RO Device Status
RCTL        0x00100 -               RW RX Control
CRCERRS     0x04000 -               RC CRC Error Count
GPRC        0x04074 -               RC Good Packets Received Count
GPTC        0x04080 -               RC Good Packets Transmitted Count
GORC64      0x04088 -               RC64 Good Octets Received Count 64-bit
GOTC64      0x04090 -               RC64 Good Octets Transmitted Count 64-bit
MPRC        0x0407C -               RC Multicast Packets Received Count
MPTC        0x040F0 -               RC Multicast Packets Transmitted Count
BPRC        0x04078 -               RC Broadcast Packets Received Count
BPTC        0x040F4 -               RC Broadcast Packets Transmitted
]=]
};
reg['82599ES'] = {
   array = [=[
ALLRXDCTL   0x01028 +0x40*0..63     RW Receive Descriptor Control
ALLRXDCTL   0x0D028 +0x40*64..127   RW Receive Descriptor Control
DAQF        0x0E200 +0x04*0..127    RW Destination Address Queue Filter
FTQF        0x0E600 +0x04*0..127    RW Five Tuple Queue Filter
ETQF        0x05128 +0x04*0..7      RW EType Queue Filter
ETQS        0x0EC00 +0x04*0..7      RW EType Queue Select
MPSAR       0x0A600 +0x04*0..255    RW MAC Pool Select Array
PFUTA       0X0F400 +0x04*0..127    RW PF Unicast Table Array
PFVLVF      0x0F100 +0x04*0..63     RW PF VM VLAN Pool Filter
PFVLVFB     0x0F200 +0x04*0..127    RW PF VM VLAN Pool Filter Bitmap
PFMRCTL     0x0F600 +0x04*0..3      RW PF Mirror Rule Control
PFMRVLAN    0x0F610 +0x04*0..7      RW PF Mirror Rule VLAN
PFMRVM      0x0F630 +0x04*0..7      RW PF Mirror Rule Pool
PFVFRE      0x051E0 +0x04*0..1      RW PF VF Receive Enable
PFVFTE      0x08110 +0x04*0..1      RW PF VF Transmit Enable
PFVMTXSW    0x05180 +0x04*0..1      RW PF VM Tx Switch Loopback Enable
PFVFSPOOF   0x08200 +0x04*0..7      RW PF VF Anti Spoof Control
PFVMVIR     0x08000 +0x04*0..63     RW PF VM VLAN Insert Register
PFVML2FLT   0x0F000 +0x04*0..63     RW PF VM L2 Control Register
QPRC        0x01030 +0x40*0..15     RC Queue Packets Received Count
QPRDC       0x01430 +0x40*0..15     RC Queue Packets Received Drop Count
QBRC64      0x01034 +0x40*0..15     RC64 Queue Bytes Received Count
QPTC        0x08680 +0x04*0..15     RC Queue Packets Transmitted Count
QBTC64      0x08700 +0x08*0..15     RC64 Queue Bytes Transmitted Count Low
SAQF        0x0E000 +0x04*0..127    RW Source Address Queue Filter
SDPQF       0x0E400 +0x04*0..127    RW Source Destination Port Queue Filter
PSRTYPE     0x0EA00 +0x04*0..63     RW Packet Split Receive Type Register
RAH         0x0A204 +0x08*0..127    RW Receive Address High
RAL         0x0A200 +0x08*0..127    RW Receive Address Low
RAL64       0x0A200 +0x08*0..127    RW64 Receive Address Low and High
RQSM        0x02300 +0x04*0..31     RW Receive Queue Statistic Mapping Registers
RTTDT2C     0x04910 +0x04*0..7      RW DCB Transmit Descriptor Plane T2 Config
RTTPT2C     0x0CD20 +0x04*0..7      RW DCB Transmit Packet Plane T2 Config
RTRPT4C     0x02140 +0x04*0..7      RW DCB Receive Packet Plane T4 Config
RXPBSIZE    0x03C00 +0x04*0..7      RW Receive Packet Buffer Size
RQSMR       0x02300 +0x04*0..31     RW Receive Queue Statistic Mapping Registers
TQSM        0x08600 +0x04*0..31     RW Transmit Queue Statistic Mapping Registers
TXPBSIZE    0x0CC00 +0x04*0..7      RW Transmit Packet Buffer Size
TXPBTHRESH  0x04950 +0x04*0..7      RW Tx Packet Buffer Threshold
VFTA        0x0A000 +0x04*0..127    RW VLAN Filter Table Array
QPRDC       0x01430 +0x40*0..15     RC Queue Packets Received Drop Count
FCRTH       0x03260 +0x40*0..7      RW Flow Control Receive Threshold High
]=],
   inherit = "gbl",
   rxq = [=[
DCA_RXCTRL  0x0100C +0x40*0..63     RW Rx DCA Control Register
DCA_RXCTRL  0x0D00C +0x40*64..127   RW Rx DCA Control Register
SRRCTL      0x01014 +0x40*0..63     RW Split Receive Control Registers
SRRCTL      0x0D014 +0x40*64..127   RW Split Receive Control Registers
RDBAL       0x01000 +0x40*0..63     RW Receive Descriptor Base Address Low
RDBAL       0x0D000 +0x40*64..127   RW Receive Descriptor Base Address Low
RDBAH       0x01004 +0x40*0..63     RW Receive Descriptor Base Address High
RDBAH       0x0D004 +0x40*64..127   RW Receive Descriptor Base Address High
RDLEN       0x01008 +0x40*0..63     RW Receive Descriptor Length
RDLEN       0x0D008 +0x40*64..127   RW Receive Descriptor Length
RDH         0x01010 +0x40*0..63     RO Receive Descriptor Head
RDH         0x0D010 +0x40*64..127   RO Receive Descriptor Head
RDT         0x01018 +0x40*0..63     RW Receive Descriptor Tail
RDT         0x0D018 +0x40*64..127   RW Receive Descriptor Tail
RXDCTL      0x01028 +0x40*0..63     RW Receive Descriptor Control
RXDCTL      0x0D028 +0x40*64..127   RW Receive Descriptor Control
]=],
   singleton = [=[
AUTOC       0x042A0 -               RW Auto Negotiation Control
AUTOC2      0x042A8 -               RW Auto Negotiation Control 2
DMATXCTL    0x04A80 -               RW DMA Tx Control
DTXMXSZRQ   0x08100 -               RW DMA Tx Map Allow Size Requests
EEC         0x10010 -               RW EEPROM/Flash Control Register
EIMC        0x00888 -               RW Extended Interrupt Mask Clear
ERRBC       0x04008 -               RC Error Byte Count
FCCFG       0x03D00 -               RW Flow Control Configuration
FCTRL       0x05080 -               RW Filter Control
HLREG0      0x04240 -               RW MAC Core Control 0
ILLERRC     0x04004 -               RC Illegal Byte Error Count
LINKS       0x042A4 -               RO Link Status Register
MAXFRS      0x04268 -               RW Max Frame Size
MFLCN       0x04294 -               RW MAC Flow Control Register
MRQC        0x0EC80 -               RW Multiple Receive Queues Command Register
MTQC        0x08120 -               RW Multiple Transmit Queues Command Register
PFVTCTL     0x051B0 -               RW PF Virtual Control Register
PFQDE       0x02F04 -               RW PF Queue Drop Enable Register
PFDTXGSWC   0x08220 -               RW PF DMA Tx General Switch Control
RDRXCTL     0x02F00 -               RW Receive DMA Control Register
RTRPCS      0x02430 -               RW DCB Receive Packet plane Control and Status
RTTDCS      0x04900 -               RW DCB Transmit Descriptor Plane Control and Status
RTTPCS      0x0CD00 -               RW DCB Transmit Packet Plane Control and Status
RTRUP2TC    0x03020 -            RW DCB Receive Use rPriority to Traffic Class
RTTUP2TC    0x0C800 -            RW DCB Transmit User Priority to Traffic Class
RTTDQSEL    0x04904 -               RW DCB Transmit Descriptor Plane Queue Select
RTTDT1C     0x04908 -               RW DCB Transmit Descriptor Plane T1 Config
RTTBCNRC    0x04984 -            RW DCB Transmit Rate-Scheduler Config
RXCSUM      0x05000 -               RW Receive Checksum Control
RFCTL       0x05008 -               RW Receive Filter Control Register
RXCTRL      0x03000 -               RW Receive Control
RXDGPC      0x02F50 -               RC DMA Good Rx Packet Counter
TXDGPC      0x087A0 -               RC DMA Good Tx Packet Counter
RXDSTATCTRL 0x02F40 -               RW Rx DMA Statistic Counter Control
RUC         0x040A4 -               RC Receive Undersize Count
RFC         0x040A8 -               RC Receive Fragment Count
ROC         0x040AC -               RC Receive Oversize Count
RJC         0x040B0 -               RC Receive Jabber Count
SWSM        0x10140 -               RW Software Semaphore
VLNCTRL     0x05088 -               RW VLAN Control Register
ILLERRC     0x04004 -               RC Illegal Byte Error Count
ERRBC       0x04008 -               RC Error Byte Count
GORC64      0x04088 -               RC64 Good Octets Received Count 64-bit
GOTC64      0x04090 -               RC64 Good Octets Transmitted Count 64-bit
RUC         0x040A4 -               RC Receive Undersize Count
RFC         0x040A8 -               RC Receive Fragment Count
ROC         0x040AC -               RC Receive Oversize Count
RJC         0x040B0 -               RC Receive Jabber Count
GORCL       0x04088 -               RC Good Octets Received Count Low
GOTCL       0x04090 -               RC Good Octets Transmitted Count Low
]=],
   txq = [=[
DCA_TXCTRL  0x0600C +0x40*0..127    RW Tx DCA Control Register
TDBAL       0x06000 +0x40*0..127    RW Transmit Descriptor Base Address Low
TDBAH       0x06004 +0x40*0..127    RW Transmit Descriptor Base Address High
TDLEN       0x06008 +0x40*0..127    RW Transmit Descriptor Length
TDH         0x06010 +0x40*0..127    RW Transmit Descriptor Head
TDT         0x06018 +0x40*0..127    RW Transmit Descriptor Tail
TXDCTL      0x06028 +0x40*0..127    RW Transmit Descriptor Control
TDWBAL      0x06038 +0x40*0..127    RW Tx Descriptor Completion Write Back Address Low
TDWBAH      0x0603C +0x40*0..127    RW Tx Descriptor Completion Write Back Address High
]=]
};
reg['1000BaseX'] = {
   array = [=[
ALLRXDCTL   0x0c028 +0x40*0..7      RW Re Descriptor Control Queue
RAL64       0x05400 +0x08*0..15     RW64 Receive Address Low
RAL         0x05400 +0x08*0..15     RW Receive Address Low
RAH         0x05404 +0x08*0..15     RW Receive Address High
]=],
   inherit = "gbl",
   rxq = [=[
RDBAL       0x0c000 +0x40*0..7      RW Rx Descriptor Base low
RDBAH       0x0c004 +0x40*0..7      RW Rx Descriptor Base High
RDLEN       0x0c008 +0x40*0..7      RW Rx Descriptor Ring Length
RDH         0x0c010 +0x40*0..7      RO Rx Descriptor Head
RDT         0x0c018 +0x40*0..7      RW Rx Descriptor Tail
RXDCTL      0x0c028 +0x40*0..7      RW Re Descriptor Control Queue
RXCTL       0x0c014 +0x40*0..7      RW RX DCA CTRL Register Queue
SRRCTL      0x0c00c +0x40*0..7      RW Split and Replication Receive Control
]=],
   singleton = [=[
ALGNERRC  0x04004 -                 RC Alignment Error Count
RXERRC    0x0400C -                 RC RX Error Count
RLEC      0x04040 -                 RC Receive Length Error Count
CRCERRS   0x04000 -                 RC CRC Error Count
MPC       0x04010 -                 RC Missed Packets Count
MRQC      0x05818 -                 RW Multiple Receive Queues Command Register
EEER      0x00E30 -                 RW Energy Efficient Ethernet (EEE) Register
EIMC      0x01528 -                 RW Extended Interrupt Mask Clear
SWSM      0x05b50 -                 RW Software Semaphore
MANC      0x05820 -                 RW Management Control
MDIC      0x00020 -                 RW MDI Control
MDICNFG   0x00E04 -                 RW MDI Configuration
RLPML     0x05004 -                 RW Receive Long packet maximal length
RPTHC     0x04104 -                 RC Rx Packets to host count
SW_FW_SYNC 0x05b5c -                RW Software Firmware Synchronization
TCTL      0x00400 -                 RW TX Control
TCTL_EXT  0x00400 -                 RW Extended TX Control
ALGNERRC  0x04004 -                 RC Alignment Error - R/clr
RXERRC    0x0400C -                 RC RX Error - R/clr
MPC       0x04010 -                 RC Missed Packets - R/clr
ECOL      0x04018 -                 RC Excessive Collisions - R/clr
LATECOL   0x0401C -                 RC Late Collisions - R/clr
RLEC      0x04040 -                 RC Receive Length Error - R/clr
GORCL     0x04088 -                 RC Good Octets Received - R/clr
GORCH     0x0408C -                 RC Good Octets Received - R/clr
GOTCL     0x04090 -                 RC Good Octets Transmitted - R/clr
GOTCH     0x04094 -                 RC Good Octets Transmitted - R/clr
RNBC      0x040A0 -                 RC Receive No Buffers Count - R/clr
]=],
   txq = [=[
TDBAL  0xe000 +0x40*0..7            RW Tx Descriptor Base Low
TDBAH  0xe004 +0x40*0..7            RW Tx Descriptor Base High
TDLEN  0xe008 +0x40*0..7            RW Tx Descriptor Ring Length
TDH    0xe010 +0x40*0..7            RO Tx Descriptor Head
TDT    0xe018 +0x40*0..7            RW Tx Descriptor Tail
TXDCTL 0xe028 +0x40*0..7            RW Tx Descriptor Control Queue
TXCTL  0xe014 +0x40*0..7            RW Tx DCA CTRL Register Queue
]=]
};
reg.i210 = {
   array = [=[
RQDPC       0x0C030 +0x40*0..4      RC Receive Queue Drop Packet Count
TQDPC       0x0E030 +0x40*0..4      RC Transmit Queue Drop Packet Count
PQGPRC      0x10010 +0x100*0..4     RC Per Queue Good Packets Received Count
PQGPTC      0x10014 +0x100*0..4     RC Per Queue Good Packets Transmitted Count
PQGORC      0x10018 +0x100*0..4     RC Per Queue Good Octets Received Count
PQGOTC      0x10034 +0x100*0..4     RC Per Queue Octets Transmitted Count
PQMPRC      0x10038 +0x100*0..4     RC Per Queue Multicast Packets Received
]=],
   inherit = "1000BaseX",
   singleton = [=[
EEMNGCTL  0x12030 -            RW Manageability EEPROM-Mode Control Register
EEC       0x12010 -            RW EEPROM-Mode Control Register
]=]
};
reg.i350 = {
   array = [=[
RQDPC       0x0C030 +0x40*0..7      RCR Receive Queue Drop Packet Count
TQDPC       0x0E030 +0x40*0..7      RCR Transmit Queue Drop Packet Count
PQGPRC      0x10010 +0x100*0..7     RCR Per Queue Good Packets Received Count
PQGPTC      0x10014 +0x100*0..7     RCR Per Queue Good Packets Transmitted Count
PQGORC      0x10018 +0x100*0..7     RCR Per Queue Good Octets Received Count
PQGOTC      0x10034 +0x100*0..7     RCR Per Queue Octets Transmitted Count
PQMPRC      0x10038 +0x100*0..7     RCR Per Queue Multicast Packets Received
]=],
   inherit = "1000BaseX",
   singleton = [=[
EEMNGCTL  0x01010 -            RW Manageability EEPROM-Mode Control Register
EEC       0x00010 -            RW EEPROM-Mode Control Register
FACTPS	  0x05B30 -            Function Active and Power State to MNG
]=]
};

Intel = {
   config = {
      pciaddr = {required=true},
      ring_buffer_size = {default=2048},
      vmdq = {default=false},
      vmdq_queuing_mode = {default="rss-64-2"},
      macaddr = {},
      poolnum = {},
      vlan = {},
      mirror = {},
      rxcounter = {},
      txcounter = {},
      rate_limit = {default=0},
      priority = {default=1.0},
      txq = {default=0},
      rxq = {default=0},
      mtu = {default=9014},
      linkup_wait = {default=120},
      linkup_wait_recheck = {default=0.1},
      wait_for_link = {default=false},
      master_stats = {default=true},
      run_stats = {default=false}
   },
};
Intel1g = setmetatable({}, {__index = Intel });
Intel82599 = setmetatable({}, {__index = Intel});
byPciID = {
  [0x1521] = { registers = "i350", driver = Intel1g, max_q = 8 },
  [0x1533] = { registers = "i210", driver = Intel1g, max_q = 4 },
  [0x157b] = { registers = "i210", driver = Intel1g, max_q = 4 },
  [0x10fb] = { registers = "82599ES", driver = Intel82599, max_q = 16 }
};

// The `driver' variable is used as a reference to the driver class in
// order to interchangeably use NIC drivers.
driver = Intel;

function Intel::new (conf) {
   var self = {
      r = {},
      pciaddress = conf.pciaddr,
      path = pci.path(conf.pciaddr),
      ndesc = conf.ring_buffer_size,
      txq = conf.txq,
      rxq = conf.rxq,
      mtu = conf.mtu,
      linkup_wait = conf.linkup_wait,
      linkup_wait_recheck = conf.linkup_wait_recheck,
      wait_for_link = conf.wait_for_link,
      vmdq = conf.vmdq,
      poolnum = conf.poolnum,
      macaddr = conf.macaddr,
      vlan = conf.vlan,
      want_mirror = conf.mirror,
      rxcounter = conf.rxcounter,
      txcounter = conf.txcounter,
      rate_limit = conf.rate_limit,
      priority = conf.priority,
      // a path used for shm operations on NIC-global state
      // canonicalize to ensure the reference is the same from all
      // processes
      shm_root = "/intel-mp/" .. pci.canonical(conf.pciaddr) .. "/",
      // only used for main process, affects max pool number
      vmdq_queuing_mode = conf.vmdq_queuing_mode
   };

   var vendor = lib.firstline(self.path .. "/vendor");
   var device = lib.firstline(self.path .. "/device");
   var byid = byPciID[tonumber(device)];
   assert(vendor == '0x8086', "unsupported nic");
   assert(byid, "unsupported intel nic");
   self = setmetatable(self, { __index = byid.driver});

   self.max_q = byid.max_q;

   // Setup device access
   self.base, self.fd = pci.map_pci_memory_unlocked(this.pciaddress, 0);
   self.master = self.fd->flock("ex, nb");

   self->load_registers(byid.registers);

   self->init();
   self.fd->flock("sh");
   self->check_vmdq();
   // this needs to happen before register loading for rxq/txq
   // because it determines the queue numbers
   self->select_pool();
   self->load_queue_registers(byid.registers);
   self->init_tx_q();
   self->init_rx_q();
   self->set_MAC();
   self->set_VLAN();
   self->set_mirror();
   self->set_rxstats();
   self->set_txstats();
   self->set_tx_rate();

   // Initialize per app statistics
   self.shm = {
      mtu    = {counter, self.mtu},
      txdrop = {counter}
   };

   // Figure out if we are supposed to collect device statistics
   self.run_stats = conf.run_stats || (self.master && conf.master_stats);

   // Expose per-device statistics from master
   if( self.run_stats ) {
      var frame = {
         dtime     = {counter, C.get_unix_time()},
         // Keep a copy of the mtu here to have all
         // data available in a single shm frame
         mtu       = {counter, self.mtu},
         speed     = {counter},
         status    = {counter, 2}, // Link down
         type      = {counter, 0x1000}, // ethernetCsmacd
         promisc   = {counter},
         macaddr   = {counter, self.r.RAL64[0]->bits(0,48)},
         rxbytes   = {counter},
         rxpackets = {counter},
         rxmcast   = {counter},
         rxbcast   = {counter},
         rxdrop    = {counter},
         rxerrors  = {counter},
         txbytes   = {counter},
         txpackets = {counter},
         txmcast   = {counter},
         txbcast   = {counter},
         txdrop    = {counter},
         txerrors  = {counter},
         rxdmapackets = {counter}
      };
      self->init_queue_stats(frame);
      self.stats = shm.create_frame("pci/"..self.pciaddress, frame);
      self.sync_timer = lib.throttle(0.01);
   }

   alarms.add_to_inventory ({
      [{alarm_type_id='ingress-bandwith'}] = {
         resource=tostring(S.getpid()),
         has_clear=true,
         description='Ingress bandwith exceeds N Gbps',
      }
   });
   var ingress_bandwith = alarms.declare_alarm ({
      [{resource=tostring(S.getpid()),alarm_type_id='ingress-bandwith'}] = {
         perceived_severity='major',
         alarm_text='Ingress bandwith exceeds 1e9 bytes/s which can cause packet drops.'
      }
   });
   self.ingress_bandwith_alarm = CallbackAlarm.new(ingress_bandwith,
      1, 1e9, function() { return self->rxbytes(); });

   alarms.add_to_inventory ({
      [{alarm_type_id='ingress-packet-rate'}] = {
         resource=tostring(S.getpid()),
         has_clear=true,
         description='Ingress packet-rate exceeds N Gbps',
      }
   });
   var ingress_packet_rate = alarms.declare_alarm ({
      [{resource=tostring(S.getpid()),alarm_type_id='ingress-packet-rate'}] = {
         perceived_severity='major',
         alarm_text='Ingress packet-rate exceeds 2MPPS which can cause packet drops.'
      }
   });
   self.ingress_packet_rate_alarm = CallbackAlarm.new(ingress_packet_rate,
      1, 2e6, function() { return self->rxpackets(); });

   return self;
}

function Intel::disable_interrupts () {
   this.r.EIMC(0xffffffff);
}

function Intel::wait_linkup (timeout) {
   if( timeout == null ) { timeout = this.linkup_wait; }
   if( this->link_status() ) { return true; }
   for( i=1,math.max(math.floor(timeout/this.linkup_wait_recheck), 1) ) {
      C.usleep(math.floor(this.linkup_wait_recheck * 1e6));
      if( this->link_status() ) { return true; }
   }
   return false;
}

rxdesc_t = ffi.typeof([=[
struct {
   uint64_t address;
   uint16_t length, cksum;
   uint8_t status, errors;
   uint16_t vlan;
} __attribute__((packed))
]=]);

function Intel::init_rx_q () {
   if( ! this.rxq ) { return; }
   assert((this.rxq >=0) && (this.rxq < this.max_q),
   "rxqueue must be in 0.." .. this.max_q-1);
   assert((this.ndesc %128) ==0,
   "ndesc must be a multiple of 128 (for Rx only)");	// see 7.1.4.5

   this.rxqueue = ffi.new("struct packet *[?]", this.ndesc);
   this.rdh = 0;
   this.rdt = 0;
   // setup 4.5.9
   var rxdesc_ring_t = ffi.typeof("$[$]", rxdesc_t, this.ndesc);
   this.rxdesc = ffi.cast(ffi.typeof("$&", rxdesc_ring_t),
   memory.dma_alloc(ffi.sizeof(rxdesc_ring_t)));

   // VMDq pool state (4.6.10.1.4)
   if( this.vmdq ) {
      // packet splitting none, enable 4 or 2 RSS queues per pool
      if( this.max_pool == 32 ) {
         this.r.PSRTYPE[this.poolnum](bits ({ RQPL=30 }));
      } else {
         this.r.PSRTYPE[this.poolnum](bits ({ RQPL=29 }));
      }
      // multicast promiscuous, broadcast accept, accept untagged pkts
      this.r.PFVML2FLT[this.poolnum]->set(bits ({ MPE=28, BAM=27, AUPE=24 }));
   }

   // Receive state
   this.r.RDBAL(tophysical(this.rxdesc) % 2**32);
   this.r.RDBAH(tophysical(this.rxdesc) / 2**32);
   this.r.RDLEN(this.ndesc * ffi.sizeof(rxdesc_t));

   for( i = 0, this.ndesc-1 ) {
      var p= packet.allocate();
      this.rxqueue[i]= p;
      this.rxdesc[i].address= tophysical(p.data);
      this.rxdesc[i].status= 0;
   }
   this.r.SRRCTL(0);
   this.r.SRRCTL->set(bits ({
      // Set packet buff size to 0b10000 kbytes (max)
      BSIZEPACKET4 = 4,
      // Drop packets when no descriptors
      Drop_En = this->offset("SRRCTL", "Drop_En")
   }));
   this->lock_sw_sem();

   // enable VLAN tag stripping in VMDq mode
   if( this.vmdq ) {
      this.r.RXDCTL->set(bits ({ VME = 30 }));
   }

   this.r.RXDCTL->set( bits ({ Enable = 25 }));
   this.r.RXDCTL->wait( bits ({ Enable = 25 }));
   C.full_memory_barrier();
   this.r.RDT(this.ndesc - 1);

   this->rss_tab_build();
   if( this.driver == "Intel82599" ) {
      this.r.RXCTRL->set(bits({ RXEN=0 }));
      this.r.DCA_RXCTRL->clr(bits({RxCTRL=12}));
      if( this.vmdq ) {
         // enable packet reception for this pool/VF (4.6.10.1.4)
         this.r.PFVFRE[math.floor(this.poolnum/32)]->set(bits({VFRE=this.poolnum%32}));
      }
   } else if( this.driver == "Intel1g" ) {
      this.r.RCTL->set(bits ({ RXEN = 1 }));
   }
   this->unlock_sw_sem();
}
function Intel::init_tx_q () {                               // 4.5.10
   if( ! this.txq ) { return; }
   assert((this.txq >=0) && (this.txq < this.max_q),
   "txqueue must be in 0.." .. this.max_q-1);
   this.tdh = 0;
   this.tdt = 0;
   this.txqueue = ffi.new("struct packet *[?]", this.ndesc);

   // 7.2.2.3
   var txdesc_t = ffi.typeof("struct { uint64_t address, flags; }");
   var txdesc_ring_t = ffi.typeof("$[$]", txdesc_t, this.ndesc);
   this.txdesc = ffi.cast(ffi.typeof("$&", txdesc_ring_t),
   memory.dma_alloc(ffi.sizeof(txdesc_ring_t)));

   // Transmit state variables 7.2.2.3.4 / 7.2.2.3.5
   this.txdesc_flags = bits({
      dtyp0=20,
      dtyp1=21,
      eop=24,
      ifcs=25,
      dext=29
   });

   // Initialize transmit queue
   this.r.TDBAL(tophysical(this.txdesc) % 2**32);
   this.r.TDBAH(tophysical(this.txdesc) / 2**32);
   this.r.TDLEN(this.ndesc * ffi.sizeof(txdesc_t));

   // for VMDq need some additional pool configs
   if( this.vmdq ) {
      this.r.RTTDQSEL(this.poolnum);
      // set baseline value for credit refill for tx bandwidth algorithm
      this.r.RTTDT1C(0x80);
      // enables packet Tx for this VF's pool
      this.r.PFVFTE[math.floor(this.poolnum/32)]->set(bits({VFTE=this.poolnum%32}));
      // enable TX loopback
      this.r.PFVMTXSW[math.floor(this.poolnum/32)]->clr(bits({LLE=this.poolnum%32}));
   }

   if( this.r.DMATXCTL ) {
      this.r.DMATXCTL->set(bits ({ TE = 0 }));
      this.r.TXDCTL->set(bits({SWFLSH=26, hthresh=8}) + 32);
   }

   this.r.TXDCTL->set(bits ({ WTHRESH = 16, ENABLE = 25 }));
   this.r.TXDCTL->wait(bits ({ ENABLE = 25 }));

   if( this.driver == "Intel1g" ) {
      this.r.TCTL->set(bits ({ TxEnable = 1 }));
   }
}
function Intel::load_registers(key) {
   var v = reg[key];
   if( v.inherit ) { this->load_registers(v.inherit); }
   if( v.singleton ) { register.define(v.singleton, this.r, this.base); }
   if( v.array ) { register.define_array(v.array, this.r, this.base); }
}
function Intel::load_queue_registers(key) {
  var v = reg[key];
  if( v.inherit ) { this->load_queue_registers(v.inherit); }
  if( v.txq && this.txq ) {
    register.define(v.txq, this.r, this.base, this.txq);
  }
  if( v.rxq && this.rxq ) {
    register.define(v.rxq, this.r, this.base, this.rxq);
  }
}
function Intel::lock_sw_sem() {
   for( i=1,50,1 ) {
      if( band(this.r.SWSM(), 0x01) == 1 ) {
         C.usleep(100000);
      } else {
         return;
      }
   }
   error("Couldn't get lock");
}
function Intel::offset(reg, key) {
   return this.offsets[reg][key];
}
function Intel::push () {
   if( ! this.txq ) { return; }
   var li = this.input.input;
   if( li == null ) { return; }

   this.ingress_packet_rate_alarm->check();
   this.ingress_bandwith_alarm->check();

   while( ! empty(li) && this->can_transmit() ) {
      var p = receive(li);
      // NB: the comment below is taken from intel_mp.lua, which disables
      // this check for the same reason.
      //   We must not send packets that are bigger than the MTU.  This
      //   check is currently disabled to satisfy some selftests until
      //   agreement on this strategy is reached.
      //if p.length > self.mtu then
      //   packet.free(p)
      //   counter.add(self.shm.txdrop)
      //end
      this->transmit(p);
   }
   // Reclaim transmit contexts
   var cursor = this.tdh;
   this.tdh = this.r.TDH();	// possible race condition, 7.2.2.4, check DD
   //C.full_memory_barrier()
   while( cursor != this.tdh ) {
      if( this.txqueue[cursor] ) {
         packet.free(this.txqueue[cursor]);
         this.txqueue[cursor] = null;
      }
      cursor = this->ringnext(cursor);
   }
   this.r.TDT(this.tdt);

   // same code as in pull, but we only call it in case the rxq
   // is disabled for this app
   if( this.rxq && this.output.output ) { return; }
   if( this.run_stats && this.sync_timer() ) {
      this->sync_stats();
   }
}

function Intel::pull () {
   if( ! this.rxq ) { return; }
   var lo = this.output.output;
   if( lo == null ) { return; }

   var pkts = 0;
   while( band(this.rxdesc[this.rdt].status, 0x01) == 1 && pkts < engine.pull_npackets ) {
      var p = this.rxqueue[this.rdt];
      p.length = this.rxdesc[this.rdt].length;
      transmit(lo, p);

      var np = packet.allocate();
      this.rxqueue[this.rdt] = np;
      this.rxdesc[this.rdt].address = tophysical(np.data);
      this.rxdesc[this.rdt].status = 0;

      this.rdt = band(this.rdt + 1, this.ndesc-1);
      ++pkts    ;
   }
   // This avoids RDT == RDH when every descriptor is available.
   this.r.RDT(band(this.rdt - 1, this.ndesc-1));

   // Sync device statistics if we are master.
   if( this.run_stats && this.sync_timer() ) {
      this->sync_stats();
   }
}

function Intel::unlock_sw_sem() {
   this.r.SWSM->clr(bits ({ SMBI = 0 }));
}

function Intel::ringnext (index) {
   return band(index+1, this.ndesc-1);
}

function Intel::can_transmit () {
   return this->ringnext(this.tdt) != this.tdh;
}

function Intel::transmit (p) {
   this.txdesc[this.tdt].address = tophysical(p.data);
   this.txdesc[this.tdt].flags =
      bor(p.length, this.txdesc_flags, lshift(p.length+0ULL, 46));
   this.txqueue[this.tdt] = p;
   this.tdt = this->ringnext(this.tdt);
}

function Intel::rss_enable () {
   // set default q = 0 on i350,i210 noop on 82599
   this.r.MRQC(0);
   this.r.MRQC->set(bits ({ RSS = this->offset("MRQC", "RSS") }));
   // Enable all RSS hash on all available input keys
   this.r.MRQC->set(bits ({
      TcpIPv4 = 16, IPv4 = 17, IPv6 = 20,
      TcpIPv6 = 21, UdpIPv4 = 22, UdpIPv6 = 23
   }));
   this->rss_tab({0});
   this->rss_key();
}
function Intel::rss_key () {
   for( i=0,9,1 ) {
      this.r.RSSRK[i](math.random(2**32));
   }
}

// Set RSS redirection table, which has 64 * 2 entries which contain
// RSS indices, the lower 4 bits (or fewer) of which are used to
// select an RSS queue.
//
// Also returns the current state of the redirection table
function Intel::rss_tab (newtab) {
   var current = {};
   var pos = 0;

   for( i=0,31,1 ) {
      for( j=0,3,1 ) {
         current[this.r.RETA[i]->byte(j)] = 1;
         if( newtab != null ) {
            var new = newtab[pos%#newtab+1];
            this.r.RETA[i]->byte(j, new);
         }
         ++pos    ;
      }
   }
   return current;
}
function Intel::rss_tab_build () {
   var tab = {};
   for( i=0,this.max_q-1,1 ) {
      if( band(this.r.ALLRXDCTL[i](), bits ({ Enable = 25 })) > 0 ) {
         table.insert(tab, i);
      }
   }
   this->rss_tab(tab);
}
function Intel::stop () {
   if( this.rxq ) {
      // 4.5.9
      // PBRWAC.PBE is mentioned in i350 only, not implemented here.
      this.r.RXDCTL->clr(bits ({ ENABLE = 25 }));
      this.r.RXDCTL->wait(bits ({ ENABLE = 25 }), 0);
      // removing the queue from rss first would be better but this
      // is easier :(, we are going to throw the packets away anyway
      this->lock_sw_sem();
      this->rss_tab_build();
      this->unlock_sw_sem();
      C.usleep(100);
      // TODO
      // zero rxd.status, set rdt = rdh - 1
      // poll for RXMEMWRAP to loop twice or buffer to empty
      this.r.RDT(0);
      this.r.RDH(0);
      this.r.RDBAL(0);
      this.r.RDBAH(0);
      for( i = 0, this.ndesc-1 ) {
         if( this.rxqueue[i] ) {
            packet.free(this.rxqueue[i]);
            this.rxqueue[i] = null;
         }
      }
   }
   if( this.txq ) {
      //TODO
      //TXDCTL[n].SWFLSH and wait
      //wait until tdh == tdt
      //wait on rxd[tdh].status = dd
      this->discard_unsent_packets();
      this.r.TXDCTL(0);
      this.r.TXDCTL->wait(bits ({ ENABLE = 25 }), 0);
   }
   if( this.vmdq ) {
      this->unset_MAC();
      this->unset_VLAN();
      this->unset_mirror();
      this->unset_pool();
   }
   this->unset_tx_rate();
   if( this.fd->flock("nb, ex") ) {
      // delete shm state for this NIC
      shm.unlink(this.shm_root);
      this.r.CTRL->clr( bits ({ SETLINKUP = 6 }) );
      //self.r.CTRL_EXT:clear( bits { DriverLoaded = 28 })
      pci.set_bus_master(this.pciaddress, false);
      pci.close_pci_resource(this.fd, this.base);
   }
   if( this.run_stats ) {
      shm.delete_frame(this.stats);
   }
}

function Intel::discard_unsent_packets () {
   var old_tdt = this.tdt;
   this.tdt = this.r.TDT();
   this.tdh = this.r.TDH();
   this.r.TDT(this.tdh);
   while( old_tdt != this.tdh ) {
      old_tdt = band(old_tdt - 1, this.ndesc - 1);
      packet.free(this.txqueue[old_tdt]);
      this.txdesc[old_tdt].address = -1;
      this.txdesc[old_tdt].flags = 0;
   }
   this.tdt = this.tdh;
}

function Intel::sync_stats () {
   var set, stats = counter.set, this.stats;
   set(stats.speed, this->link_speed());
   set(stats.status, this->link_status() && 1 || 2);
   set(stats.promisc, this->promisc() && 1 || 2);
   set(stats.rxbytes, this->rxbytes());
   set(stats.rxpackets, this->rxpackets());
   set(stats.rxmcast, this->rxmcast());
   set(stats.rxbcast, this->rxbcast());
   set(stats.rxdrop, this->rxdrop());
   set(stats.rxerrors, this->rxerrors());
   set(stats.txbytes, this->txbytes());
   set(stats.txpackets, this->txpackets());
   set(stats.txmcast, this->txmcast());
   set(stats.txbcast, this->txbcast());
   set(stats.txdrop, this->txdrop());
   set(stats.txerrors, this->txerrors());
   set(stats.rxdmapackets, this->rxdmapackets());
   for( idx = 1, #this.queue_stats, 2 ) {
      var name, register = this.queue_stats[idx], this.queue_stats[idx+1];
      set(stats[name], register());
   }
}

// set MAC address (4.6.10.1.4)
function Intel::set_MAC () {
   if( ! this.macaddr ) { return; }
   var mac = macaddress->new(this.macaddr);
   this->add_receive_MAC(mac);
   this->set_transmit_MAC(mac);
}

function Intel::add_receive_MAC (mac) {
   var mac_index;

   // scan to see if the MAC is already recorded or find the
   // first free MAC index
   //
   // the lock protects the critical section so that driver apps on
   // separate processes do not use conflicting registers
   this->lock_sw_sem();
   for( idx=1, this.max_mac_addr ) {
      var valid = this.r.RAH[idx]->bits(31, 1);

      if( valid == 0 ) {
         mac_index = idx;
         this.r.RAL[mac_index](mac->subbits(0,32));
         this.r.RAH[mac_index](bits({AV=31},mac->subbits(32,48)));
         break;
      } else {
         if( this.r.RAL[idx]() == mac->subbits(0, 32) &&
            this.r.RAH[idx]->bits(0, 15) == mac->subbits(32, 48) ) {
            mac_index = idx;
            break;
         }
      }
   }
   this->unlock_sw_sem();

   assert(mac_index, "Max number of MAC addresses reached");

   // associate MAC with the app's VMDq pool
   this->enable_MAC_for_pool(mac_index);
}

function Intel::set_transmit_MAC (mac) {
   var poolnum = this.poolnum || 0;
   this.r.PFVFSPOOF[math.floor(poolnum/8)]->set(bits({MACAS=poolnum%8}));
}

// set VLAN for the driver instance
function Intel::set_VLAN () {
   var vlan = this.vlan;
   if( ! vlan ) { return; }
   assert(vlan>=0 && vlan<4096, "bad VLAN number");
   this->add_receive_VLAN(vlan);
   this->set_tag_VLAN(vlan);
}

function Intel::add_receive_VLAN (vlan) {
   assert(vlan>=0 && vlan<4096, "bad VLAN number");
   var vlan_index, first_empty;

   // works the same as add_receive_MAC
   this->lock_sw_sem();
   for( idx=0, this.max_vlan-1 ) {
      var valid = this.r.PFVLVF[idx]->bits(31, 1);

      if( valid == 0 ) {
         if( ! first_empty ) {
            first_empty = idx;
         }
      } else if( this.r.PFVLVF[idx]->bits(0, 11) == vlan ) {
         vlan_index = idx;
         break;
      }
   }
   this->unlock_sw_sem();

   if( ! vlan_index && first_empty ) {
      vlan_index = first_empty;
      this.r.VFTA[math.floor(vlan/32)]->set(bits({Ena=vlan%32}));
      this.r.PFVLVF[vlan_index](bits({Vl_En=31},vlan));
   }

   assert(vlan_index, "Max number of VLAN IDs reached");

   this.r.PFVLVFB[2*vlan_index + math.floor(this.poolnum/32)]
      ->set(bits({PoolEna=this.poolnum%32}));
}

function Intel::set_tag_VLAN (vlan) {
   var poolnum = this.poolnum || 0;
   this.r.PFVFSPOOF[math.floor(poolnum/8)]->set(bits({VLANAS=poolnum%8+8}));
   // set Port VLAN ID & VLANA to always add VLAN tag
   // TODO: on i350 it's the VMVIR register
   this.r.PFVMVIR[poolnum](bits({VLANA=30}, vlan));
}

function Intel::unset_VLAN () {
   var r = this.r;
   var offs, mask = math.floor(this.poolnum/32), bits({PoolEna=this.poolnum%32});

   for( vln_ndx = 0, 63 ) {
      if( band(r.PFVLVFB[2*vln_ndx+offs](), mask) != 0 ) {
         // found a vlan this pool belongs to
         r.PFVLVFB[2*vln_ndx+offs]->clr(mask);
         if( r.PFVLVFB[2*vln_ndx+offs]() == 0 ) {
            // it was the last pool of the vlan
            var vlan = tonumber(band(r.PFVLVF[vln_ndx](), 0xFFF));
            r.PFVLVF[vln_ndx](0x0);
            r.VFTA[math.floor(vlan/32)]->clr(bits({Ena=vlan%32}));
         }
      }
   }
}

function Intel::set_mirror () {
   if( ! this.want_mirror ) { return; }
   want_mirror = this.want_mirror;

   // set MAC promiscuous
   this.r.PFVML2FLT[this.poolnum]->set(bits({
      AUPE=24, ROMPE=25, ROPE=26, BAM=27, MPE=28}));

   // pick one of a limited (4) number of mirroring rules
   for( idx=0, 3 ) {
      // check if no mirroring enable bits (3:0) are set
      // (i.e., this rule is unused and available)
      if( this.r.PFMRCTL[idx]->bits(0, 4) == 0 ) {
         mirror_ndx = idx;
         break;
      // there's already a rule for this pool, overwrite
      } else if( this.r.PFMRCTL[idx]->bits(8, 5) == this.poolnum ) {
         mirror_ndx = idx;
         break;
      }
   }

   assert(mirror_ndx, "Max number of mirroring rules reached");

   var mirror_rule = 0ULL;

   // mirror some or all pools
   if( want_mirror.pool ) {
      mirror_rule = bor(bits({VPME=0}), mirror_rule);
      if( want_mirror.pool == true ) { // mirror all pools
         this.r.PFMRVM[mirror_ndx](0xFFFFFFFF);
         this.r.PFMRVM[mirror_ndx+4](0xFFFFFFFF);
      } else if( type(want_mirror.pool) == 'table' ) {
         var bm0 = this.r.PFMRVM[mirror_ndx]();
         var bm1 = this.r.PFMRVM[mirror_ndx+4]();
         for( _, pool in ipairs(want_mirror.pool) ) {
            if( pool <= 64 ) {
               bm0 = bor(lshift(1, pool), bm0);
            } else {
               bm1 = bor(lshift(1, pool-64), bm1);
            }
         }
         this.r.PFMRVM[mirror_ndx](bm0);
         this.r.PFMRVM[mirror_ndx+4](bm1);
      }
   }

   // mirror hardware port
   if( want_mirror.port ) {
      if( want_mirror.port == true ||
            want_mirror.port == 'in' ||
            want_mirror.port == 'inout' ) {
         mirror_rule = bor(bits({UPME=1}), mirror_rule);
      }
      if( want_mirror.port == true ||
            want_mirror.port == 'out' ||
            want_mirror.port == 'inout' ) {
         mirror_rule = bor(bits({DPME=2}), mirror_rule);
      }
   }

   // TODO: implement VLAN mirroring

   if( mirror_rule != 0 ) {
      mirror_rule = bor(mirror_rule, lshift(this.poolnum, 8));
      this.r.PFMRCTL[mirror_ndx]->set(mirror_rule);
   }
}

function Intel::unset_mirror () {
   for( rule_i = 0, 3 ) {
      // check if any mirror rule points here
      var rule_dest = band(bit.rshift(this.r.PFMRCTL[rule_i](), 8), 63);
      var bits = band(this.r.PFMRCTL[rule_i](), 0x07);
      if( bits != 0 && rule_dest == this.poolnum ) {
         this.r.PFMRCTL[rule_i](0x0);     // clear rule
         this.r.PFMRVLAN[rule_i](0x0);    // clear VLANs mirrored
         this.r.PFMRVLAN[rule_i+4](0x0);
         this.r.PFMRVM[rule_i](0x0);      // clear pools mirrored
         this.r.PFMRVM[rule_i+4](0x0);
      }
   }
}

function Intel::rxpackets () { return this.r.GPRC();                 }
function Intel::txpackets () { return this.r.GPTC();                 }
function Intel::rxmcast   () { return this.r.MPRC() + this.r.BPRC(); }
function Intel::rxbcast   () { return this.r.BPRC();                 }
function Intel::txmcast   () { return this.r.MPTC() + this.r.BPTC(); }
function Intel::txbcast   () { return this.r.BPTC();                 }

Intel1g.driver = "Intel1g";
Intel1g.offsets = {
    SRRCTL = {
       Drop_En = 31
    },
    MRQC = {
       RSS = 1
    }
};
Intel1g.max_mac_addr = 15;
Intel1g.max_vlan = 8;
function Intel1g::init_phy () {
   // 4.3.1.4 PHY Reset
   this.r.MANC->wait(bits ({ BLK_Phy_Rst_On_IDE = 18 }), 0);

   // 4.6.1  Acquiring Ownership Over a Shared Resource
   this->lock_fw_sem();
   this.r.SW_FW_SYNC->wait(bits ({ SW_PHY_SM = 1 }), 0);
   this.r.SW_FW_SYNC->set(bits ({ SW_PHY_SM = 1 }));
   this->unlock_fw_sem();

   this.r.CTRL->set(bits ({ PHYreset = 31 }));
   C.usleep(1*100);
   this.r.CTRL->clr(bits ({ PHYreset = 31 }));

   // 4.6.2 Releasing Ownership Over a Shared Resource
   this->lock_fw_sem();
   this.r.SW_FW_SYNC->clr(bits ({ SW_PHY_SM = 1 }));
   this->unlock_fw_sem();

   // Determine PCI function to physical port mapping
   var lan_id = this.r.STATUS->bits(2,2);
   this.r.EEMNGCTL->wait(bits ({ CFG_DONE = 18 + lan_id }));

   /*
   self:lock_fw_sem()
   self.r.SW_FW_SYNC:wait(bits { SW_PHY_SM = 1}, 0)
   self.r.SW_FW_SYNC:set(bits { SW_PHY_SM = 1 })
   self:unlock_fw_sem()

   -- If you where going to configure the PHY to none defaults
   -- this is where you would do it

   self:lock_fw_sem()
   self.r.SW_FW_SYNC:clr(bits { SW_PHY_SM = 1 })
   self:unlock_fw_sem()
   */
}
function Intel1g::lock_fw_sem() {
   this.r.SWSM->set(bits ({ SWESMBI = 1 }));
   while( band(this.r.SWSM(), 0x02) == 0 ) {
      this.r.SWSM->set(bits ({ SWESMBI = 1 }));
   }
}
function Intel1g::unlock_fw_sem() {
   this.r.SWSM->clr(bits ({ SWESMBI = 1 }));
}
function Intel1g::init () {
   if( ! this.master ) { return; }
   pci.unbind_device_from_linux(this.pciaddress);
   pci.set_bus_master(this.pciaddress, true);
   pci.disable_bus_master_cleanup(this.pciaddress);

   // 4.5.3  Initialization Sequence
   this->disable_interrupts();
   // 4.3.1 Software Reset (RST)
   this.r.CTRL(bits ({ RST = 26 }));
   C.usleep(4*1000);
   this.r.EEC->wait(bits ({ Auto_RD = 9 }));
   this.r.STATUS->wait(bits ({ PF_RST_DONE = 21 }));
   this->disable_interrupts();                        // 4.5.4

   // use Internal PHY                             -- 8.2.5
   this.r.MDICNFG(0);
   this->init_phy();

   this->rss_enable();

   this.r.RCTL->clr(bits ({ RXEN = 1 }));
   this.r.RCTL(bits ({
      UPE = 3,       // Unicast Promiscuous
      MPE = 4,       // Mutlicast Promiscuous
      LPE = 5,       // Long Packet Reception / Jumbos
      BAM = 15,      // Broadcast Accept Mode
      SECRC = 26,    // Strip ethernet CRC
   }));

   this.r.CTRL->set(bits ({ SETLINKUP = 6 }));
   this.r.CTRL_EXT->clr( bits ({ LinkMode0 = 22, LinkMode1 = 23}) );
   this.r.CTRL_EXT->clr( bits ({ PowerDown = 20 }) );
   this.r.CTRL_EXT->set( bits ({ AutoSpeedDetect = 12, DriverLoaded = 28 }));
   this.r.RLPML(this.mtu + 4); // mtu + crc
   this->unlock_sw_sem();
   if( this.wait_for_link ) { this->wait_linkup(); }
}

function Intel1g::link_status () {
   var mask = lshift(1, 1);
   return bit.band(this.r.STATUS(), mask) == mask;
}
function Intel1g::link_speed () {
   return ({10000,100000,1000000,1000000})[1+bit.band(bit.rshift(this.r.STATUS(), 6),3)];
}
function Intel1g::promisc () {
   return band(this.r.RCTL(), lshift(1, 3)) != 0ULL;
}
function Intel1g::rxbytes   () { return this.r.GORCH()*2**32 + this.r.GORCL(); }
function Intel1g::rxdrop    () { return this.r.MPC() + this.r.RNBC();         }
function Intel1g::rxerrors  () {
   return this.r.CRCERRS() + this.r.RLEC()
      + this.r.RXERRC() + this.r.ALGNERRC();
}
function Intel1g::txbytes   () { return this.r.GOTCH()*2**32 + this.r.GOTCL(); }
function Intel1g::txdrop    () { return this.r.ECOL();                        }
function Intel1g::txerrors  () { return this.r.LATECOL();                     }
function Intel1g::rxdmapackets () {
   return this.r.RPTHC();
}

function Intel1g::init_queue_stats (frame) {
   var perqregs = {
      rxdrops = "RQDPC",
      txdrops = "TQDPC",
      rxpackets = "PQGPRC",
      txpackets = "PQGPTC",
      rxbytes = "PQGORC",
      txbytes = "PQGOTC",
      rxmcast = "PQMPRC"
   };
   this.queue_stats = {};
   for( i=0,this.max_q-1 ) {
      for( k,v in pairs(perqregs) ) {
         var name = "q" .. i .. "_" .. k;
         table.insert(this.queue_stats, name);
         table.insert(this.queue_stats, this.r[v][i]);
         frame[name] = {counter};
      }
   }
}

function Intel1g::get_rxstats () {
   assert(this.rxq, "cannot retrieve rxstats without rxq");
   var frame = shm.open_frame("pci/"..this.pciaddress);
   var rxc   = this.rxq;
   return {
      counter_id = rxc,
      packets = counter.read(frame["q"..rxc.."_rxpackets"]),
      dropped = counter.read(frame["q"..rxc.."_rxdrops"]),
      bytes = counter.read(frame["q"..rxc.."_rxbytes"])
   };
}

function Intel1g::get_txstats () {
   assert(this.txq, "cannot retrieve rxstats without txq");
   var frame = shm.open_frame("pci/"..this.pciaddress);
   var txc   = this.txq;
   return {
      counter_id = txc,
      packets = counter.read(frame["q"..txc.."_txpackets"]),
      bytes = counter.read(frame["q"..txc.."_txbytes"])
   };
}

// noop because 1g NICs have per-queue counters that aren't
// configurable
function Intel1g::set_rxstats () { return; }
function Intel1g::set_txstats () { return; }

function Intel1g::check_vmdq () { return; }
function Intel1g::vmdq_enable () {
   error("unimplemented");
}
function Intel1g::select_pool () { return; }

function Intel1g::enable_MAC_for_pool(mac_index) {
   this.r.RAH[mac_index]->set(bits ({ Ena = 18 + this.poolnum }));
}

function Intel1g::unset_MAC () {
   var msk = bits ({ Ena = 18 + this.poolnum });
   for( mac_index = 0, this.max_mac_addr ) {
      pf.r.RAH[mac_index]->clr(msk);
   }
}

function Intel1g::set_tx_rate () { return; }
function Intel1g::unset_tx_rate () { return; }

Intel82599.driver = "Intel82599";
Intel82599.offsets = {
   SRRCTL = {
      Drop_En = 28
   },
   MRQC = {
       RSS = 0
   }
};
Intel82599.max_mac_addr = 127;
Intel82599.max_vlan = 64;

function Intel82599::link_status () {
   var mask = lshift(1, 30);
   return bit.band(this.r.LINKS(), mask) == mask;
}
function Intel82599::link_speed () {
   var links = this.r.LINKS();
   var speed1, speed2 = lib.bitset(links, 29), lib.bitset(links, 28);
   return (speed1 && speed2 && 10000000000)    //  10 GbE
      ||  (speed1 && ! speed2 && 1000000000) //   1 GbE
      ||  1000000;                                // 100 Mb/s
}
function Intel82599::promisc () {
   return band(this.r.FCTRL(), lshift(1, 9)) != 0ULL;
}
function Intel82599::rxbytes  () { return this.r.GORC64();   }
function Intel82599::rxdrop   () { return this.r.QPRDC[0](); }
function Intel82599::rxerrors () {
   return this.r.CRCERRS() + this.r.ILLERRC() + this.r.ERRBC() +
      this.r.RUC() + this.r.RFC() + this.r.ROC() + this.r.RJC();
}
function Intel82599::txbytes   () { return this.r.GOTC64(); }
function Intel82599::txdrop    () { return 0;               }
function Intel82599::txerrors  () { return 0;               }
function Intel82599::rxdmapackets () {
   return this.r.RXDGPC();
}

function Intel82599::init_queue_stats (frame) {
   var perqregs = {
      rxdrops = "QPRDC",
      rxpackets = "QPRC",
      txpackets = "QPTC",
      rxbytes = "QBRC64",
      txbytes = "QBTC64",
   };
   this.queue_stats = {};
   for( i=0,15 ) {
      for( k,v in pairs(perqregs) ) {
         var name = "q" .. i .. "_" .. k;
         table.insert(this.queue_stats, name);
         table.insert(this.queue_stats, this.r[v][i]);
         frame[name] = {counter};
      }
   }
}

// C type for VMDq enabled state
vmdq_enabled_t = ffi.typeof("struct { uint8_t enabled; }");

function Intel82599::init () {
   if( ! this.master ) { return; }
   pci.unbind_device_from_linux(this.pciaddress);
   pci.set_bus_master(this.pciaddress, true);
   pci.disable_bus_master_cleanup(this.pciaddress);

   // The 82599 devices sometimes just don't come up, especially when
   // there is traffic already on the link.  If 2s have passed and the
   // link is still not up, loop and retry.
   var reset_timeout = math.max(this.linkup_wait_recheck, 2);
   var reset_count = math.max(math.floor(this.linkup_wait / reset_timeout), 1);
   for( i=1,reset_count ) {
      this->disable_interrupts();
      var reset = bits({ LinkReset=3, DeviceReset=26 });
      this.r.CTRL(reset);
      C.usleep(1000);
      this.r.CTRL->wait(reset, 0);
      this.r.EEC->wait(bits({AutoreadDone=9}));           // 3.
      this.r.RDRXCTL->wait(bits({DMAInitDone=3}));        // 4.

      // 4.6.4.2
      // 3.7.4.2
      this.r.AUTOC->set(bits ({ LMS0 = 13, LMS1 = 14 }));
      this.r.AUTOC2(0);
      this.r.AUTOC2->set(bits ({ tenG_PMA_PMD_Serial = 17 }));
      this.r.AUTOC->set(bits({restart_AN=12}));

      if( ! this.wait_for_link ) { break; }
      if( this->wait_linkup(reset_timeout) ) { break; }
   }

   // 4.6.7
   this.r.RXCTRL(0);                             // disable receive
   this.r.RXDSTATCTRL(0x10); // map all queues to RXDGPC
   for( i=1,127 ) { // preserve device MAC
      this.r.RAL[i](0);
      this.r.RAH[i](0);
   }
   for( i=0,127 ) {
      this.r.PFUTA[i](0);
      this.r.VFTA[i](0);
      this.r.PFVLVFB[i](0);
      this.r.SAQF[i](0);
      this.r.DAQF[i](0);
      this.r.SDPQF[i](0);
      this.r.FTQF[i](0);
   }
   for( i=0,63 ) {
      this.r.PFVLVF[i](0);
      this.r.MPSAR[i](0);
   }
   for( i=0,255 ) {
      this.r.MPSAR[i](0);
   }

   this.r.FCTRL->set(bits ({
      MPE = 8,
      UPE = 9,
      BAM = 10
   }));

   this.r.VLNCTRL(0x8100);                    // explicity set default
   this.r.RXCSUM(0);                          // turn off all checksum offload

   this.r.RXPBSIZE[0]->bits(10,10, 0x200);
   this.r.TXPBSIZE[0]->bits(10,10, 0xA0);
   this.r.TXPBTHRESH[0](0xA0);
   for( i=1,7 ) {
      this.r.RXPBSIZE[i]->bits(10,10, 0);
      this.r.TXPBSIZE[i]->bits(10,10, 0);
      this.r.TXPBTHRESH[i](0);
   }

   this.r.MTQC(0);
   this.r.PFVTCTL(0);
   this.r.RTRUP2TC(0);
   this.r.RTTUP2TC(0);
   this.r.DTXMXSZRQ(0xFFF);

   this.r.MFLCN(bits({RFCE=3}));
   this.r.FCCFG(bits({TFCE=3}));

   for( i=0,7 ) {
      this.r.RTTDT2C[i](0);
      this.r.RTTPT2C[i](0);
      this.r.RTRPT4C[i](0);
      this.r.ETQF[i](0);
      this.r.ETQS[i](0);
   }

   this.r.HLREG0(bits({
      TXCRCEN=0, RXCRCSTRP=1, JUMBOEN=2, rsv2=3,
      TXPADEN=10, rsvd3=11, rsvd4=13, MDCSPD=16
   }));
   this.r.MAXFRS(lshift(this.mtu + 4, 16)); // mtu + crc

   this.r.RDRXCTL(bits ({ CRCStrip = 1 }));
   this.r.CTRL_EXT->set(bits ({NS_DIS = 1}));

   this->rss_enable();

   // set shm to indicate whether the NIC is in VMDq mode
   var vmdq_shm = shm.create(this.shm_root .. "vmdq_enabled", vmdq_enabled_t);
   vmdq_shm.enabled = this.vmdq;
   shm.unmap(vmdq_shm);

   if( this.vmdq ) {
      this->vmdq_enable();
   }

   this->unlock_sw_sem();
}

// Implements various status checks related to VMDq configuration.
// Also checks that the main process used the same VMDq setting if
// this is a worker process
function Intel82599::check_vmdq () {
   var vmdq_shm = shm.open(this.shm_root .. "vmdq_enabled", vmdq_enabled_t);

   if( ! this.vmdq ) {
      assert(! this.macaddr, "VMDq must be set to use MAC address");
      assert(! this.mirror, "VMDq must be set to specify mirroring rules");

      if( ! this.master ) {
         assert(vmdq_shm.enabled == 0,
                "VMDq was set by the main process for this NIC");
      }
   } else {
      assert(this.driver == "Intel82599", "VMDq only supported on 82599");
      assert(this.macaddr, "MAC address must be set in VMDq mode");

      if( ! this.master ) {
         assert(vmdq_shm.enabled == 1,
                "VMDq not set by the main process for this NIC");
      }
   }
}

// C type for shared memory indicating which pools are used
var vmdq_pools_t = ffi.typeof("struct { uint8_t pools[64]; }");
// C type for VMDq queuing mode
// mode = 0 for 32 pools/4 queues, 1 for 64 pools/2 queues
var vmdq_queuing_mode_t = ffi.typeof("struct { uint8_t mode; }");

// enable VMDq mode, see 4.6.10.1
// follows the configuration flow in 4.6.11.3.3
// (should only be called on the master instance)
function Intel82599::vmdq_enable () {
   // create shared memory for tracking VMDq pools
   var vmdq_shm = shm.create(this.shm_root .. "vmdq_pools", vmdq_pools_t);
   // explicitly initialize to 0 since we can't rely on cleanup
   for( i=0, 63 ) { vmdq_shm.pools[i] = 0; }
   shm.unmap(vmdq_shm);

   // set VMDq queuing mode for all instances on this NIC
   var mode_shm = shm.create(this.shm_root .. "vmdq_queuing_mode",
                               vmdq_queuing_mode_t);
   if( this.vmdq_queuing_mode == "rss-32-4" ) {
      mode_shm.mode = 0;
   } else if( this.vmdq_queuing_mode == "rss-64-2" ) {
      mode_shm.mode = 1;
   } else {
      error("Invalid VMDq queuing mode");
   }
   shm.unmap(mode_shm);

   // must be set prior to setting MTQC (7.2.1.2.1)
   this.r.RTTDCS->set(bits ({ ARBDIS=6 }));

   if( this.vmdq_queuing_mode == "rss-32-4" ) {
      // 1010 -> 32 pools, 4 RSS queues each
      this.r.MRQC->bits(0, 4, 0xA);
      // Num_TC_OR_Q=10b -> 32 pools (4.6.11.3.3 and 8.2.3.9.15)
      this.r.MTQC(bits ({ VT_Ena=1, Num_TC_OR_Q=3 }));
   } else {
      // 1011 -> 64 pools, 2 RSS queues each
      this.r.MRQC->bits(0, 4, 0xB);
      // Num_TC_OR_Q=01b -> 64 pools
      this.r.MTQC(bits ({ VT_Ena=1, Num_TC_OR_Q=2 }));
   }

   // TODO: not sure this is needed, but it's in intel10g
   // disable RSC (7.11)
   this.r.RFCTL->set(bits ({ RSC_Dis=5 }));

   // enable virtualization, replication enabled, disable default pool
   this.r.PFVTCTL(bits ({ VT_Ena=0, Rpl_En=30, DisDefPool=29 }));

   // enable VMDq Tx to Rx loopback
   this.r.PFDTXGSWC->set(bits ({ LBE=0 }));

   // needs to be set for loopback (7.10.3.4)
   this.r.FCRTH[0](0x10000);

   // enable vlan filter (4.6.7, 7.1.1.2)
   this.r.VLNCTRL->set(bits ({ VFE=30 }));

   // RTRUP2TC/RTTUP2TC cleared above in init

   // DMA TX TCP max allowed size requests (set to 1MB)
   this.r.DTXMXSZRQ(0xFFF);

   // disable PFC, enable legacy control flow
   this.r.MFLCN(bits ({ RFCE=3 }));
   this.r.FCCFG(bits ({ TFCE=3 }));

   // RTTDT2C, RTTPT2C, RTRPT4C cleared above in init()

   // QDE bit = 0 for all queues
   for( i = 0, 127 ) {
      this.r.PFQDE(bor(lshift(1,16), lshift(i,8)));
   }

   // clear RTTDT1C, PFVLVF for all pools, set them later
   for( i = 0, 63 ) {
      this.r.RTTDQSEL(i);
      this.r.RTTDT1C(0x00);
   }

   // disable TC arbitrations, enable packet buffer free space monitor
   this.r.RTTDCS->clr(bits ({ TDPAC=0, TDRM=4, BPBFSM=23 }));
   this.r.RTTDCS->set(bits ({ VMPAC=1, BDPM=22 }));
   this.r.RTTPCS->clr(bits ({ TPPAC=5, TPRM=8 }));
   // set RTTPCS.ARBD
   this.r.RTTPCS->bits(22, 10, 0x244);
   this.r.RTRPCS->clr(bits ({ RAC=2, RRM=1 }));

   // must be cleared after MTQC configuration (7.2.1.2.1)
   this.r.RTTDCS->clr(bits ({ ARBDIS=6 }));
}

// In VMDq mode, selects an available pool if one isn't provided by the user.
//
// This method runs before rxq/txq registers are loaded, because the rxq/txq registers
// depend on the pool number prior to loading.
function Intel82599::select_pool() {
   if( ! this.vmdq ) { return; }

   this->lock_sw_sem();

   // check the queueing mode in shm, adjust max pools based on that
   var mode_shm = shm.open(this.shm_root .. "vmdq_queuing_mode", vmdq_queuing_mode_t);
   if( mode_shm.mode == 0 ) {
      this.max_pool = 32;
   } else {
      this.max_pool = 64;
   }
   shm.unmap(mode_shm);

   // We use some shared memory to track which pool numbers are claimed
   var pool_shm = shm.open(this.shm_root .. "vmdq_pools", vmdq_pools_t);

   // if the poolnum was set manually in the config, just use that
   if( ! this.poolnum ) {
      var available_pool;

      for( poolnum = 0, this.max_pool-1 ) {
         if( pool_shm.pools[poolnum] == 0 ) {
            available_pool = poolnum;
            break;
         }
      }

      assert(available_pool, "No free VMDq pools are available");
      this.poolnum = available_pool;
   } else {
      assert(this.poolnum < this.max_pool,
             string.format("Pool overflow: Intel 82599 supports up to %d VMDq pools",
                           this.max_pool));
   }

   pool_shm.pools[this.poolnum] = 1;
   shm.unmap(pool_shm);

   this->unlock_sw_sem();

   // Once we know the pool number, figure out txq and rxq numbers. This
   // needs to be done prior to loading registers.
   //
   // for VMDq, make rxq/txq relative to the pool number
   var max_rxq_or_txq = 128 / this.max_pool;
   assert(this.rxq >= 0 && this.rxq < max_rxq_or_txq,
          "rxqueue must be in 0.." .. max_rxq_or_txq-1);
   this.rxq = this.rxq + max_rxq_or_txq * this.poolnum;
   assert(this.txq >= 0 && this.txq < max_rxq_or_txq,
          "txqueue must be in 0.." .. max_rxq_or_txq-1);
   this.txq = this.txq + max_rxq_or_txq * this.poolnum;

   // max queue number is different in VMDq mode
   this.max_q = 128;
}

// used to disable the pool number for this instance on stop()
function Intel82599::unset_pool () {
  this->lock_sw_sem();

  var pool_shm = shm.open(this.shm_root .. "vmdq_pools", vmdq_pools_t);
  pool_shm.pools[this.poolnum] = 0;
  shm.unmap(pool_shm);

  this->unlock_sw_sem();
}

function Intel82599::enable_MAC_for_pool (mac_index) {
   this.r.MPSAR[2*mac_index + math.floor(this.poolnum/32)]
      ->set(bits({Ena=this.poolnum%32}));
}

function Intel82599::unset_MAC () {
   var msk = bits ({ Ena=this.poolnum%32 });
   for( mac_index = 0, this.max_mac_addr ) {
      this.r.MPSAR[2*mac_index + math.floor(this.poolnum/32)]->clr(msk);
   }
}

function Intel82599::set_tx_rate () {
   if( ! this.txq ) { return; }
   this.r.RTTDQSEL(this.poolnum || this.txq);
   if( this.rate_limit >= 10 ) {
      // line rate = 10,000 Mb/s
      var factor = 10000 / tonumber(this.rate_limit);
      // 10.14 bits
      factor = bit.band(math.floor(factor*2**14+0.5), 2**24-1);
      this.r.RTTBCNRC(bits({RS_ENA=31}, factor));
   } else {
      this.r.RTTBCNRC(0x00);
   }
   this.r.RTTDT1C(bit.band(math.floor(this.priority * 0x80), 0x3FF));
}

function Intel82599::unset_tx_rate () {
   this.rate_limit = 0;
   this.priority = 0;
   this->set_tx_rate();
}

// return rxstats for the counter assigned to this queue
// the data has to be read from the shm frame since the main instance
// is in control of the counter registers (and clears them on read)
function Intel82599::get_rxstats () {
   assert(this.rxcounter && this.rxq, "cannot retrieve rxstats");
   var frame = shm.open_frame("pci/"..this.pciaddress);
   var rxc   = this.rxcounter;
   return {
      counter_id = rxc,
      packets = counter.read(frame["q"..rxc.."_rxpackets"]),
      dropped = counter.read(frame["q"..rxc.."_rxdrops"]),
      bytes = counter.read(frame["q"..rxc.."_rxbytes"])
   };
}

function Intel82599::get_txstats () {
   assert(this.txcounter && this.txq, "cannot retrieve txstats");
   var frame = shm.open_frame("pci/"..this.pciaddress);
   var txc   = this.txcounter;
   return {
      counter_id = txc,
      packets = counter.read(frame["q"..txc.."_txpackets"]),
      bytes = counter.read(frame["q"..txc.."_txbytes"])
   };
}

// enable the given counter for this app's rx queue
function Intel82599::set_rxstats () {
   if( ! this.rxcounter || ! this.rxq ) { return; }
   var counter = this.rxcounter;
   assert(counter>=0 && counter<16, "bad Rx counter");
   this.r.RQSMR[math.floor(this.rxq/4)]->set(lshift(counter,8*(this.rxq%4)));
}

// enable the given counter for this app's tx queue
function Intel82599::set_txstats () {
   if( ! this.txcounter || ! this.txq ) { return; }
   var counter = this.txcounter;
   assert(counter>=0 && counter<16, "bad Tx counter");
   this.r.TQSM[math.floor(this.txq/4)]->set(lshift(counter,8*(this.txq%4)));
}

function Intel::debug (args) {
   args = args || {};
   var pfx = args.prefix || "DEBUG_";
   var prnt = args.print || true;
   var r = { rss = "", rxds = 0 };
   r.LINK_STATUS = this->link_status();
   r.rdt = this.rdt;
   if( this.output.output ) {
      r.txpackets = counter.read(this.output.output.stats.txpackets);
   }
   if( this.input.input ) {
      r.rxpackets = counter.read(this.input.input.stats.rxpackets);
   }
   r.rdtstatus = band(this.rxdesc[this.rdt].status, 1) == 1;
   this->lock_sw_sem();
   for( k,_ in pairs(this->rss_tab()) ) {
      r.rss = r.rss .. k .. " ";
   }
   this->unlock_sw_sem();

   r.rxds = 0;
   for( i=0,this.ndesc-1 ) {
      if( band(this.rxdesc[i].status, 1) == 1 ) {
         r.rxds = r.rxds + 1;
      }
   }
   r.rdbal = tophysical(this.rxdesc) % 2**32;
   r.rdbah = tophysical(this.rxdesc) / 2**32;
   r.rdlen = this.ndesc * 16;
   r.ndesc = this.ndesc;

   r.master = this.master;

   for( _,k in pairs({"RDH", "RDT", "RDBAL", "RDBAH", "RDLEN"}) ) {
      r[k] = tonumber(this.r[k]());
   }

   var master_regs = {};
   if( this.driver == "Intel82599" ) {
      r.rxdctrl =
         band(this.r.RXDCTL(), bits({enabled = 25})) == bits({enabled = 25});
      master_regs = {"RXCTRL"};
   } else if( this.driver == "Intel1g" ) {
      r.rxen = band(this.r.RCTL(), bits({ RXEN = 1 })) == bits({ RXEN = 1 });
   }
   if( this.run_stats ) {
      for( k,v in pairs(this.stats) ) {
         r[k] = counter.read(v);
      }
   }
   if( r.master ) {
      for( _,k in pairs(master_regs) ) {
         r[k] = tonumber(this.r[k]());
      }
   }

   if( prnt ) {
     var keys = {};
     for( k,_ in pairs(r) ) {
       table.insert(keys, k);
     }
     table.sort(keys);
     for( _,k in ipairs(keys) ) {
        print(pfx..k, r[k]);
     }
   }
   return r;
}
