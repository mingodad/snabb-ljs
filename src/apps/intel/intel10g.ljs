// Use of this source code is governed by the Apache 2.0 license; see COPYING.

//- Device driver for the Intel 82599 10-Gigabit Ethernet controller.
//- This is one of the most popular production 10G Ethernet
//- controllers on the market and it is readily available in
//- affordable (~$400) network cards made by Intel and others.
//-
//- You will need to familiarize yourself with the excellent [data
//- sheet](http://www.intel.com/content/dam/www/public/us/en/documents/datasheets/82599-10-gbe-controller-datasheet.pdf)
//- to understand this module.

module(...,package.seeall);

var ffi      = require ("ffi");
var C        = ffi.C;
var lib      = require("core.lib");
var pci      = require("lib.hardware.pci");
var register = require("lib.hardware.register");
var index_set = require("lib.index_set");
var macaddress = require("lib.macaddress");
var timer = require("core.timer");

var bits, bitset = lib.bits, lib.bitset;
var band, bor, lshift = bit.band, bit.bor, bit.lshift;

var num_descriptors = 1024;
function ring_buffer_size (arg) {
   if( ! arg ) { return num_descriptors; }
   var ring_size = assert(tonumber(arg), "bad ring size: " .. arg);
   if( ring_size > 32*1024 ) {
      error("ring size too large for hardware: " .. ring_size);
   }
   if( math.log(ring_size)/math.log(2) % 1 != 0 ) {
      error("ring size is not a power of two: " .. arg);
   }
   num_descriptors = assert(tonumber(arg));
}

// Defaults for configurable items
var default = {
   // The MTU configured through the MAXFRS.MFS register includes the
   // Ethernet header and CRC. It is limited to 65535 bytes.  We use
   // the convention that the configurable MTU includes the Ethernet
   // header but not the CRC.  This is "natural" in the sense that the
   // unit of data handed to the driver contains a complete Ethernet
   // packet.
   //
   // For untagged packets, the Ethernet overhead is 14 bytes.  If
   // 802.1q tagging is used, the Ethernet overhead is increased by 4
   // bytes per tag.  This overhead must be included in the MTU if
   // tags are handled by the software.  However, the NIC always
   // accepts packets of size MAXFRS.MFS+4 and MAXFRS.MFS+8 if single-
   // or double tagged packets are received (see section 8.2.3.22.13).
   // In this case, we will actually accept packets which exceed the
   // MTU.
   //
   // XXX If hardware support for VLAN tag adding or stripping is
   // enabled, one should probably not include the tags in the MTU.
   //
   // The default MTU allows for an IP packet of a total size of 9000
   // bytes without VLAN tagging.
   mtu = 9014,
};

var function pass (...) { return ...; }


//- ### SF: single function: non-virtualized device
var M_sf = {}; M_sf.__index = M_sf;

function new_sf (conf) {
   var dev = { pciaddress = conf.pciaddr, // PCI device address
                 mtu = (conf.mtu || default.mtu),
                 fd = false,       // File descriptor for PCI memory
                 r = {},           // Configuration registers
                 s = {},           // Statistics registers
                 qs = {},          // queue statistic registers
                 txdesc = 0,     // Transmit descriptors (pointer)
                 txdesc_phy = 0, // Transmit descriptors (physical address)
                 txpackets = {},   // Tx descriptor index -> packet mapping
                 tdh = 0,          // Cache of transmit head (TDH) register
                 tdt = 0,          // Cache of transmit tail (TDT) register
                 rxdesc = 0,     // Receive descriptors (pointer)
                 rxdesc_phy = 0, // Receive descriptors (physical address)
                 rxpackets = {},   // Rx descriptor index -> packet mapping
                 rdh = 0,          // Cache of receive head (RDH) register
                 rdt = 0,          // Cache of receive tail (RDT) register
                 rxnext = 0,       // Index of next buffer to receive
              };
   return setmetatable(dev, M_sf);
}

function M_sf::open () {
   pci.unbind_device_from_linux(this.pciaddress);
   pci.set_bus_master(this.pciaddress, true);
   this.base, this.fd = pci.map_pci_memory_locked(this.pciaddress, 0);
   register.define(config_registers_desc, this.r, this.base);
   register.define(transmit_registers_desc, this.r, this.base);
   register.define(receive_registers_desc, this.r, this.base);
   register.define_array(packet_filter_desc, this.r, this.base);
   register.define(statistics_registers_desc, this.s, this.base);
   register.define_array(queue_statistics_registers_desc, this.qs, this.base);
   this.txpackets = ffi.new("struct packet *[?]", num_descriptors);
   this.rxpackets = ffi.new("struct packet *[?]", num_descriptors);
   return this->init();
}

function M_sf::close() {
   pci.set_bus_master(this.pciaddress, false);
   if( this.free_receive_buffers ) {
      this->free_receive_buffers();
   }
   if( this.discard_unsent_packets ) {
      this->discard_unsent_packets();
      C.usleep(1000);
   }
   if( this.fd ) {
      pci.close_pci_resource(this.fd, this.base);
      this.fd = false;
   }
   this->free_dma_memory();
}

//- See data sheet section 4.6.3 "Initialization Sequence."

function M_sf::init () {
   this->init_dma_memory();

   this.redos = 0;
   var mask = bits({Link_up=30});
   for( i = 1, 100 ) {
      this
         ->disable_interrupts()
         ->global_reset();
      if( i%5 == 0 ) { this->autonegotiate_sfi(); }
      this
         ->wait_eeprom_autoread()
         ->wait_dma()
         ->init_statistics()
         ->init_receive()
         ->init_transmit()
         ->init_txdesc_prefetch()
         ->wait_enable()
         ->wait_linkup();

      if( band(this.r.LINKS(), mask) == mask ) {
         this.redos = i;
         return this;
      }
   }
   io.write ('never got link up: ', this.pciaddress, '\n');
   os.exit(2);
   return this;
}


{
   var _rx_pool = {};
   var _tx_pool = {};

   var function get_ring(ct, pool) {
      var spot, v = next(pool);
      if( spot && v ) {
         pool[spot] = null;
         return v.ptr, v.phy;
      }
      var ptr, phy =
         memory.dma_alloc(num_descriptors * ffi.sizeof(ct));
      // Initialize unused DMA memory with -1. This is so that
      // accidental premature use of DMA memory will cause a DMA error
      // (write to illegal address) instead of overwriting physical
      // memory near address 0.
      ffi.fill(ptr, 0xff, num_descriptors * ffi.sizeof(ct));
      // ptr = lib.bounds_checked(ct, ptr, 0, num_descriptors)
      ptr = ffi.cast(ffi.typeof("$*", ct), ptr);
      return ptr, phy;
   }

   function M_sf::init_dma_memory () {
      this.rxdesc, this.rxdesc_phy = get_ring(rxdesc_t, _rx_pool);
      this.txdesc, this.txdesc_phy = get_ring(txdesc_t, _tx_pool);
      return this;
   }

   function M_sf::free_dma_memory() {
      _rx_pool[#_rx_pool+1] = {ptr = this.rxdesc, phy = this.rxdesc_phy};
      _tx_pool[#_tx_pool+1] = {ptr = this.txdesc, phy = this.txdesc_phy};
      return this;
   }
}

function M_sf::rxdrop () { return this.qs.QPRDC[0](); }

function M_sf::global_reset () {
   var reset = bits({LinkReset=3, DeviceReset=26});
   this.r.CTRL(reset);
   C.usleep(1000);
   this.r.CTRL->wait(reset, 0);
   return this;
}

function M_sf::disable_interrupts () { return this; } //- XXX do this
function M_sf::wait_eeprom_autoread () {
   this.r.EEC->wait(bits({AutoreadDone=9}));
   return this;
}

function M_sf::wait_dma () {
   this.r.RDRXCTL->wait(bits({DMAInitDone=3}));
   return this;
}

function M_sf::init_statistics () {
   // Read and then zero each statistic register
   for( _,reg in pairs(this.s) ) { reg->read(); reg->reset(); }
   // Make sure RX Queue #0 is mapped to the stats register #0.  In
   // the default configuration, all 128 RX queues are mapped to this
   // stats register.  In non-virtualized mode, only queue #0 is
   // actually used.
   this.qs.RQSMR[0]->set(0);
   return this;
}

function M_sf::init_receive () {
   this.r.RXCTRL->clr(bits({RXEN=0}));
   this->set_promiscuous_mode(); // NB: don't need to program MAC address filter
   this.r.HLREG0(bits({
      TXCRCEN=0, RXCRCSTRP=1, rsv2=3, TXPADEN=10,
      rsvd3=11, rsvd4=13, MDCSPD=16
   }));
   if( this.mtu > 1514 ) {
      this.r.HLREG0->set(bits({ JUMBOEN=2 }));
      // MAXFRS is set to a hard-wired default of 1518 if JUMBOEN is
      // not set.  The MTU does *not* include the 4-byte CRC, but
      // MAXFRS does.
      this.r.MAXFRS(lshift(this.mtu+4, 16));
   }
   this->set_receive_descriptors();
   this.r.RXCTRL->set(bits({RXEN=0}));
   if( this.r.DCA_RXCTRL ) { // Register may be undefined in subclass (PF)
      // Datasheet 4.6.7 says to clear this bit.
      // Have observed payload corruption when this is not done.
      this.r.DCA_RXCTRL->clr(bits({RxCTRL=12}));
   }
   return this;
}

function M_sf::set_rx_buffersize(rx_buffersize) {
   rx_buffersize = math.min(16, math.floor((rx_buffersize || 16384) / 1024));  // size in KB, max 16KB
   assert (rx_buffersize > 0, "rx_buffersize must be more than 1024");
   assert(rx_buffersize*1024 >= this.mtu, "rx_buffersize is too small for the MTU");
   this.rx_buffersize = rx_buffersize * 1024;
   this.r.SRRCTL(bits({DesctypeLSB=25}, rx_buffersize));
   this.r.SRRCTL->set(bits({Drop_En=28})); // Enable RX queue drop counter
   return this;
}

function M_sf::set_receive_descriptors () {
   this->set_rx_buffersize(16384);        // start at max

   this.r.RDBAL(this.rxdesc_phy % 2**32);
   this.r.RDBAH(this.rxdesc_phy / 2**32);
   this.r.RDLEN(num_descriptors * ffi.sizeof(rxdesc_t));
   return this;
}

function M_sf::wait_enable () {
   this.r.RXDCTL(bits({Enable=25}));
   this.r.RXDCTL->wait(bits({enable=25}));
   this.r.TXDCTL->wait(bits({Enable=25}));
   return this;
}

function M_sf::set_promiscuous_mode () {
   this.r.FCTRL(bits({MPE=8, UPE=9, BAM=10}));
   return this;
}

function M_sf::init_transmit () {
   this.r.HLREG0->set(bits({TXCRCEN=0}));
   this->set_transmit_descriptors();
   this.r.DMATXCTL->set(bits({TE=0}));
   return this;
}

function M_sf::init_txdesc_prefetch () {
   this.r.TXDCTL->set(bits({SWFLSH=26, hthresh=8}) + 32);
   return this;
}

function M_sf::set_transmit_descriptors () {
   this.r.TDBAL(this.txdesc_phy % 2**32);
   this.r.TDBAH(this.txdesc_phy / 2**32);
   this.r.TDLEN(num_descriptors * ffi.sizeof(txdesc_t));
   return this;
}


//- ### Transmit

//- See datasheet section 7.1 "Inline Functions -- Transmit Functionality."

var txdesc_flags = bits({ifcs=25, dext=29, dtyp0=20, dtyp1=21, eop=24});

function M_sf::transmit (p) {
   this.txdesc[this.tdt].address = memory.virtual_to_physical(p.data);
   this.txdesc[this.tdt].options = bor(p.length, txdesc_flags, lshift(p.length+0ULL, 46));
   this.txpackets[this.tdt] = p;
   this.tdt = band(this.tdt + 1, num_descriptors - 1);
}

function M_sf::sync_transmit () {
   var old_tdh = this.tdh;
   this.tdh = this.r.TDH();
   C.full_memory_barrier();
   // Release processed buffers
   if( old_tdh != this.tdh ) {
      while( old_tdh != this.tdh ) {
         packet.free(this.txpackets[old_tdh]);
         this.txpackets[old_tdh] = null;
         old_tdh = band(old_tdh + 1, num_descriptors - 1);
      }
   }
   this.r.TDT(this.tdt);
}

function M_sf::can_transmit () {
   return band(this.tdt + 1, num_descriptors - 1) != this.tdh;
}

function M_sf::discard_unsent_packets() {
   var old_tdt = this.tdt;
   this.tdt = this.r.TDT();
   this.tdh = this.r.TDH();
   this.r.TDT(this.tdh);
   while( old_tdt != this.tdh ) {
      old_tdt = band(old_tdt - 1, num_descriptors - 1);
      packet.free(this.txpackets[old_tdt]);
      this.txdesc[old_tdt].address = -1;
      this.txdesc[old_tdt].options = 0;
   }
   this.tdt = this.tdh;
}

//- See datasheet section 7.1 "Inline Functions -- Receive Functionality."

function M_sf::receive () {
   assert(this->can_receive());
   var wb = this.rxdesc[this.rxnext].wb;
   var p = this.rxpackets[this.rxnext];
   p.length = wb.pkt_len;
   this.rxpackets[this.rxnext] = null;
   this.rxnext = band(this.rxnext + 1, num_descriptors - 1);
   return p;
}

function M_sf::can_receive () {
   return this.rxnext != this.rdh && band(this.rxdesc[this.rxnext].wb.xstatus_xerror, 1) == 1;
}

function M_sf::can_add_receive_buffer () {
   return band(this.rdt + 1, num_descriptors - 1) != this.rxnext;
}

function M_sf::add_receive_buffer (p) {
   assert(this->can_add_receive_buffer());
   var desc = this.rxdesc[this.rdt].data;
   desc.address, desc.dd = memory.virtual_to_physical(p.data), 0;
   this.rxpackets[this.rdt] = p;
   this.rdt = band(this.rdt + 1, num_descriptors - 1);
}

function M_sf::free_receive_buffers () {
   while( this.rdt != this.rdh ) {
      this.rdt = band(this.rdt - 1, num_descriptors - 1);
      var desc = this.rxdesc[this.rdt].data;
      desc.address, desc.dd = -1, 0;
      packet.free(this.rxpackets[this.rdt]);
      this.rxpackets[this.rdt] = null;
   }
}

function M_sf::sync_receive () {
   // XXX I have been surprised to see RDH = num_descriptors,
   //     must check what that means. -luke
   this.rdh = math.min(this.r.RDH(), num_descriptors-1);
   assert(this.rdh < num_descriptors);
   C.full_memory_barrier();
   this.r.RDT(this.rdt);
}

function M_sf::wait_linkup () {
   this.waitlu_ms = 0;
   var mask = bits({Link_up=30});
   for( count = 1, 1000 ) {
      if( band(this.r.LINKS(), mask) == mask ) {
         this.waitlu_ms = count;
         return this;
      }
      C.usleep(1000);
   }
   this.waitlu_ms = 1000;
   return this;
}

//- ### Status and diagnostics


// negotiate access to software/firmware shared resource
// section 10.5.4
function negotiated_autoc (dev, f) {
   var function waitfor (test, attempts, interval) {
      interval = interval || 100;
      for( count = 1,attempts ) {
         if( test() ) { return true; }
         C.usleep(interval);
         io.flush();
      }
      return false;
   }
   var function tb (reg, mask, val) {
      return function() { return bit.band(reg(), mask) == (val || mask); };
   }

   var gotresource = waitfor(function() {
      var accessible = false;
      var softOK = waitfor (tb(dev.r.SWSM, bits({SMBI=0}),0), 30100);
      dev.r.SWSM->set(bits({SWESMBI=1}));
      var firmOK = waitfor (tb(dev.r.SWSM, bits({SWESMBI=1})), 30000);
      accessible = bit.band(dev.r.SW_FW_SYNC(), 0x108) == 0;
      if( ! firmOK ) {
         dev.r.SW_FW_SYNC->clr(0x03E0);   // clear all firmware bits
         accessible = true;
      }
      if( ! softOK ) {
         dev.r.SW_FW_SYNC->clr(0x1F);     // clear all software bits
         accessible = true;
      }
      if( accessible ) {
         dev.r.SW_FW_SYNC->set(0x8);
      }
      dev.r.SWSM->clr(bits({SMBI=0, SWESMBI=1}));
      if( ! accessible ) { C.usleep(100); }
      return accessible;
   }, 10000);   // TODO: only twice
   if( ! gotresource ) { error("Can't acquire shared resource"); }

   var r = f(dev);

   waitfor (tb(dev.r.SWSM, bits({SMBI=0}),0), 30100);
   dev.r.SWSM->set(bits({SWESMBI=1}));
   waitfor (tb(dev.r.SWSM, bits({SWESMBI=1})), 30000);
   dev.r.SW_FW_SYNC->clr(0x108);
   dev.r.SWSM->clr(bits({SMBI=0, SWESMBI=1}));
   return r;
}


function set_SFI (dev, lms) {
   lms = lms || bit.lshift(0x3, 13);         // 10G SFI
   var autoc = dev.r.AUTOC();
   if( bit.band(autoc, bit.lshift(0x7, 13)) == lms ) {
      dev.r.AUTOC(bits({restart_AN=12}, bit.bxor(autoc, 0x8000)));      // flip LMS[2] (15)
      lib.waitfor(function () {
         return bit.band(dev.r.ANLP1(), 0xF0000) != 0;
      });
   }

   dev.r.AUTOC(bit.bor(bit.band(autoc, 0xFFFF1FFF), lms));
   return dev;
}

function M_sf::autonegotiate_sfi () {
   return negotiated_autoc(this, function() {
      set_SFI(this);
      this.r.AUTOC->set(bits({restart_AN=12}));
      this.r.AUTOC2(0x00020000);
      return this;
   });
}


//- ### PF: the physiscal device in a virtualized setup
var M_pf = {}; M_pf.__index = M_pf;

function new_pf (conf) {
   var dev = { pciaddress = conf.pciaddr, // PCI device address
                 mtu = (conf.mtu || default.mtu),
                 r = {},           // Configuration registers
                 s = {},           // Statistics registers
                 qs = {},          // queue statistic registers
                 mac_set = index_set->new(127, "MAC address table"),
                 vlan_set = index_set->new(64, "VLAN Filter table"),
                 mirror_set = index_set->new(4, "Mirror pool table"),
              };
   return setmetatable(dev, M_pf);
}

function M_pf::open () {
   pci.unbind_device_from_linux(this.pciaddress);
   pci.set_bus_master(this.pciaddress, true);
   this.base, this.fd = pci.map_pci_memory_locked(this.pciaddress, 0);
   register.define(config_registers_desc, this.r, this.base);
   register.define_array(switch_config_registers_desc, this.r, this.base);
   register.define_array(packet_filter_desc, this.r, this.base);
   register.define(statistics_registers_desc, this.s, this.base);
   register.define_array(queue_statistics_registers_desc, this.qs, this.base);
   return this->init();
}

function M_pf::close() {
   pci.set_bus_master(this.pciaddress, false);
   if( this.fd ) {
      pci.close_pci_resource(this.fd, this.base);
      this.fd = false;
   }
}

function M_pf::init () {
   this.redos = 0;
   var mask = bits({Link_up=30});
   for( i = 1, 100 ) {
      this
         ->disable_interrupts()
         ->global_reset();
      if( i%5 == 0 ) { this->autonegotiate_sfi(); }
      this
         ->wait_eeprom_autoread()
         ->wait_dma()
         ->set_vmdq_mode()
         ->init_statistics()
         ->init_receive()
         ->init_transmit()
         ->wait_linkup();
      if( band(this.r.LINKS(), mask) == mask ) {
         return this;
      }
      this.redos = i;
   }
   io.write ('never got link up: ', this.pciaddress, '\n');
   os.exit(2);
   return this;
}

M_pf.global_reset = M_sf.global_reset;
M_pf.disable_interrupts = M_sf.disable_interrupts;
M_pf.set_receive_descriptors = pass;
M_pf.set_transmit_descriptors = pass;
M_pf.autonegotiate_sfi = M_sf.autonegotiate_sfi;
M_pf.wait_eeprom_autoread = M_sf.wait_eeprom_autoread;
M_pf.wait_dma = M_sf.wait_dma;
M_pf.init_statistics = M_sf.init_statistics;
M_pf.set_promiscuous_mode = M_sf.set_promiscuous_mode;
M_pf.init_receive = M_sf.init_receive;
M_pf.init_transmit = M_sf.init_transmit;
M_pf.wait_linkup = M_sf.wait_linkup;

function M_pf::set_vmdq_mode () {
   this.r.RTTDCS(bits({VMPAC=1,ARBDIS=6,BDPM=22}));       // clear TDPAC,TDRM=4, BPBFSM
   this.r.RFCTL->set(bits({RSC_Dis=5}));             // no RSC
   this.r.MRQC(0x08);     // 1000b -> 64 pools, x2queues, no RSS, no IOV
   this.r.MTQC(bits({VT_Ena=1, Num_TC_OR_Q=2}));    // 128 Tx Queues, 64 VMs (4.6.11.3.3)
   this.r.PFVTCTL(bits({VT_Ena=0, Rpl_En=30, DisDefPool=29}));     // enable virtualization, replication enabled
   this.r.PFDTXGSWC->set(bits({LBE=0}));             // enable Tx to Rx loopback
   this.r.RXPBSIZE[0](0x80000);             // no DCB: all queues to PB0 (0x200<<10)
   this.r.TXPBSIZE[0](0x28000);             // (0xA0<<10)
   this.r.TXPBTHRESH[0](0xA0);
   this.r.FCRTH[0](0x10000);
   this.r.RXDSTATCTRL(0x10);                 // Rx DMA Statistic for all queues
   this.r.VLNCTRL->set(bits({VFE=30}));         // Vlan filter enable
   for( i = 1, 7 ) {
      this.r.RXPBSIZE[i](0x00);
      this.r.TXPBSIZE[i](0x00);
      this.r.TXPBTHRESH[i](0x00);
   }
   for( i = 0, 7 ) {
      this.r.RTTDT2C[i](0x00);
      this.r.RTTPT2C[i](0x00);
      this.r.ETQF[i](0x00);                 // disable ethertype filter
      this.r.ETQS[0](0x00);
   }
   // clear PFQDE.QDE (queue drop enable) for each queue
   for( i = 0, 127 ) {
      this.r.PFQDE(bor(lshift(1,16), lshift(i,8)));
      this.r.FTQF[i](0x00);                 // disable L3/4 filter
      this.r.RAH[i](0);
      this.r.RAL[i](0);
      this.r.VFTA[i](0);
      this.r.PFVLVFB[i](0);
   }
   for( i = 0, 63 ) {
      this.r.RTTDQSEL(i);
      this.r.RTTDT1C(0x00);
      this.r.PFVLVF[i](0);
   }
   for( i = 0, 31 ) {
      this.r.RETA[i](0x00);                 // clear redirection table
   }

   this.r.RTRUP2TC(0x00);                   // Rx UPnMAP = 0
   this.r.RTTUP2TC(0x00);                   // Tx UPnMAP = 0
      // move to vf initialization
//    set_pool_transmit_weight(dev, 0, 0x1000)     -- pool 0 must be initialized, set at range midpoint
   this.r.DTXMXSZRQ(0xFFF);
   this.r.MFLCN(bits({RFCE=3}));            // optional? enable legacy flow control
   this.r.FCCFG(bits({TFCE=3}));
   this.r.RTTDCS->clr(bits({ARBDIS=6}));
   return this;
}

//- ### VF: virtualized device
var M_vf = {}; M_vf.__index = M_vf;

// it's the PF who creates a VF
function M_pf::new_vf (poolnum) {
   assert(poolnum < 64, "Pool overflow: Intel 82599 can only have up to 64 virtualized devices.");
   var txqn = poolnum*2;
   var rxqn = poolnum*2;
   var vf = {
      pf = this,
      // some things are shared with the main device...
      base = this.base,             // mmap()ed register file
      s = this.s,                   // Statistics registers
      mtu = this.mtu,
      // and others are our own
      r = {},                       // Configuration registers
      poolnum = poolnum,
      txqn = txqn,                  // Transmit queue number
      txdesc = 0,                   // Transmit descriptors (pointer)
      txdesc_phy = 0,               // Transmit descriptors (io address)
      txpackets = {},               // Tx descriptor index -> packet mapping
      tdh = 0,                      // Cache of transmit head (TDH) register
      tdt = 0,                      // Cache of transmit tail (TDT) register
      rxqn = rxqn,                   // receive queue number
      rxdesc = 0,                   // Receive descriptors (pointer)
      rxdesc_phy = 0,               // Receive descriptors (physical address)
      rxpackets = {},               // Rx descriptor index -> packet mapping
      rdh = 0,                      // Cache of receive head (RDH) register
      rdt = 0,                      // Cache of receive tail (RDT) register
      rxnext = 0,                   // Index of next buffer to receive
   };
   return setmetatable(vf, M_vf);
}

function M_vf::open (opts) {
   register.define(transmit_registers_desc, this.r, this.base, this.txqn);
   register.define(receive_registers_desc, this.r, this.base, this.rxqn);
   this.txpackets = ffi.new("struct packet *[?]", num_descriptors);
   this.rxpackets = ffi.new("struct packet *[?]", num_descriptors);
   return this->init(opts);
}

function M_vf::close() {
   var poolnum = this.poolnum || 0;
   var pf = this.pf;

   if( this.free_receive_buffers ) {
      this->free_receive_buffers();
   }
   if( this.discard_unsent_packets ) {
      this->discard_unsent_packets();
      C.usleep(1000);
   }

   // unset_tx_rate
   this->set_tx_rate(0, 0);
   this
      ->unset_mirror()
      ->unset_VLAN();
   // unset MAC
   {
      var msk = bits({Ena=this.poolnum%32});
      for( mac_index = 0, 127 ) {
         pf.r.MPSAR[2*mac_index + math.floor(poolnum/32)]->clr(msk);
      }
   }

   this->disable_transmit()
      ->disable_receive()
      ->free_dma_memory();

   return this;
}

function M_vf::reconfig(opts) {
   var poolnum = this.poolnum || 0;
   var pf = this.pf;

   this
      ->unset_mirror()
      ->unset_VLAN()
      ->unset_MAC();
   {
      var msk = bits({Ena=this.poolnum%32});
      for( mac_index = 0, 127 ) {
         pf.r.MPSAR[2*mac_index + math.floor(poolnum/32)]->clr(msk);
      }
   }

   return this
      ->set_MAC(opts.macaddr)
      ->set_mirror(opts.mirror)
      ->set_VLAN(opts.vlan)
      ->set_rx_stats(opts.rxcounter)
      ->set_tx_stats(opts.txcounter)
      ->set_tx_rate(opts.rate_limit, opts.priority)
      ->enable_receive()
      ->enable_transmit();
}

function M_vf::init (opts) {
   return this
      ->init_dma_memory()
      ->init_receive()
      ->init_transmit()
      ->set_MAC(opts.macaddr)
      ->set_mirror(opts.mirror)
      ->set_VLAN(opts.vlan)
      ->set_rx_stats(opts.rxcounter)
      ->set_tx_stats(opts.txcounter)
      ->set_tx_rate(opts.rate_limit, opts.priority)
      ->enable_receive()
      ->enable_transmit();
}

M_vf.init_dma_memory = M_sf.init_dma_memory;
M_vf.free_dma_memory = M_sf.free_dma_memory;
M_vf.set_receive_descriptors = M_sf.set_receive_descriptors;
M_vf.set_transmit_descriptors = M_sf.set_transmit_descriptors;
M_vf.can_transmit = M_sf.can_transmit;
M_vf.transmit = M_sf.transmit;
M_vf.sync_transmit = M_sf.sync_transmit;
M_vf.discard_unsent_packets = M_sf.discard_unsent_packets;
M_vf.can_receive = M_sf.can_receive;
M_vf.receive = M_sf.receive;
M_vf.can_add_receive_buffer = M_sf.can_add_receive_buffer;
M_vf.set_rx_buffersize = M_sf.set_rx_buffersize;
M_vf.add_receive_buffer = M_sf.add_receive_buffer;
M_vf.free_receive_buffers = M_sf.free_receive_buffers;
M_vf.sync_receive = M_sf.sync_receive;

function M_vf::init_receive () {
   var poolnum = this.poolnum || 0;
   this.pf.r.PSRTYPE[poolnum](0);        // no splitting, use pool's first queue
   this.r.RSCCTL(0x0);                   // no RSC
   this->set_receive_descriptors();
   this.pf.r.PFVML2FLT[poolnum]->set(bits({MPE=28, BAM=27, AUPE=24}));
   return this;
}

function M_vf::enable_receive() {
   this.r.RXDCTL(bits({Enable=25, VME=30}));
   this.r.RXDCTL->wait(bits({enable=25}));
   this.r.DCA_RXCTRL->clr(bits({RxCTRL=12}));
   this.pf.r.PFVFRE[math.floor(this.poolnum/32)]->set(bits({VFRE=this.poolnum%32}));
   return this;
}

function M_vf::disable_receive(reenable) {
   this.r.RXDCTL->clr(bits({Enable=25}));
   this.r.RXDCTL->wait(bits({Enable=25}), 0);
   C.usleep(100);
   // TODO free packet buffers
   this.pf.r.PFVFRE[math.floor(this.poolnum/32)]->clr(bits({VFRE=this.poolnum%32}));

   if( reenable ) {
      this.r.RXDCTL(bits({Enable=25, VME=30}));
   //    self.r.RXDCTL:wait(bits{enable=25})
   }
   return this;
}

function M_vf::init_transmit () {
   var poolnum = this.poolnum || 0;
   this.r.TXDCTL->clr(bits({Enable=25}));
   this->set_transmit_descriptors();
   this.pf.r.PFVMTXSW[math.floor(poolnum/32)]->clr(bits({LLE=poolnum%32}));
   this.pf.r.PFVFTE[math.floor(poolnum/32)]->set(bits({VFTE=poolnum%32}));
   this.pf.r.RTTDQSEL(poolnum);
   this.pf.r.RTTDT1C(0x80);
   this.pf.r.RTTBCNRC(0x00);         // no rate limiting
   return this;
}

function M_vf::enable_transmit() {
   this.pf.r.DMATXCTL->set(bits({TE=0}));
   this.r.TXDCTL->set(bits({Enable=25, SWFLSH=26, hthresh=8}) + 32);
   this.r.TXDCTL->wait(bits({Enable=25}));
   return this;
}

function M_vf::disable_transmit(reenable) {
   // TODO: wait TDH==TDT
   // TODO: wait all is written back: DD bit or Head_WB
   this.r.TXDCTL->clr(bits({Enable=25}));
   this.r.TXDCTL->set(bits({SWFLSH=26}));
   this.r.TXDCTL->wait(bits({Enable=25}), 0);
   this.pf.r.PFVFTE[math.floor(this.poolnum/32)]->clr(bits({VFTE=this.poolnum%32}));

   if( reenable ) {
      this.r.TXDCTL->set(bits({Enable=25, SWFLSH=26, hthresh=8}) + 32);
   //    self.r.TXDCTL:wait(bits{Enable=25})
   }
   return this;
}

function M_vf::set_MAC (mac) {
   if( ! mac ) { return this; }
   mac = macaddress->new(mac);
   return this
      ->add_receive_MAC(mac)
      ->set_transmit_MAC(mac);
}

function M_vf::unset_MAC() {
}

function M_vf::add_receive_MAC (mac) {
   mac = macaddress->new(mac);
   var pf = this.pf;
   var mac_index, is_new = pf.mac_set->add(tostring(mac));
   if( is_new ) {
      pf.r.RAL[mac_index](mac->subbits(0,32));
      pf.r.RAH[mac_index](bits({AV=31},mac->subbits(32,48)));
   }
   pf.r.MPSAR[2*mac_index + math.floor(this.poolnum/32)]
      ->set(bits({Ena=this.poolnum%32}));

   return this;
}

function M_vf::set_transmit_MAC (mac) {
   var poolnum = this.poolnum || 0;
   this.pf.r.PFVFSPOOF[math.floor(poolnum/8)]->set(bits({MACAS=poolnum%8}));
   return this;
}

function M_vf::set_mirror (want_mirror) {
   if( want_mirror ) {
      // set MAC promiscuous
      this.pf.r.PFVML2FLT[this.poolnum]->set(bits({
         AUPE=24, ROMPE=25, ROPE=26, BAM=27, MPE=28}));

      // pick one of a limited (4) number of mirroring rules
      var mirror_ndx, is_new = this.pf.mirror_set->add(this.poolnum);
      var mirror_rule = 0ULL;

      // mirror some or all pools
      if( want_mirror.pool ) {
         mirror_rule = bor(bits({VPME=0}), mirror_rule);
         if( want_mirror.pool == true ) {       // mirror all pools
            this.pf.r.PFMRVM[mirror_ndx](0xFFFFFFFF);
            this.pf.r.PFMRVM[mirror_ndx+4](0xFFFFFFFF);
         } else if( type(want_mirror.pool) == 'table' ) {
            var bm0 = this.pf.r.PFMRVM[mirror_ndx];
            var bm1 = this.pf.r.PFMRVM[mirror_ndx+4];
            for( _, pool in ipairs(want_mirror.pool) ) {
               if( pool <= 32 ) {
                  bm0 = bor(lshift(1, pool), bm0);
               } else {
                  bm1 = bor(lshift(1, pool-32), bm1);
               }
            }
            this.pf.r.PFMRVM[mirror_ndx](bm0);
            this.pf.r.PFMRVM[mirror_ndx+4](bm1);
         }
      }

      // mirror hardware port
      if( want_mirror.port ) {
         if( want_mirror.port == true || want_mirror.port == 'in' || want_mirror.port == 'inout' ) {
            mirror_rule = bor(bits({UPME=1}), mirror_rule);
         }
         if( want_mirror.port == true || want_mirror.port == 'out' || want_mirror.port == 'inout' ) {
            mirror_rule = bor(bits({DPME=2}), mirror_rule);
         }
      }

      // mirror some or all vlans
      if( want_mirror.vlan ) {
         mirror_rule = bor(bits({VLME=3}), mirror_rule);
            // TODO: set which vlan's want to mirror
      }
      if( mirror_rule != 0 ) {
         mirror_rule = bor(mirror_rule, lshift(this.poolnum, 8));
         this.pf.r.PFMRCTL[mirror_ndx]->set(mirror_rule);
      }
   }
   return this;
}

function M_vf::unset_mirror() {
   for( rule_i = 0, 3 ) {
      // check if any mirror rule points here
      var rule_dest = band(bit.rshift(this.pf.r.PFMRCTL[rule_i](), 8), 63);
      var bits = band(this.pf.r.PFMRCTL[rule_i](), 0x07);
      if( bits != 0 && rule_dest == this.poolnum ) {
         this.pf.r.PFMRCTL[rule_i](0x0);     // clear rule
         this.pf.r.PFMRVLAN[rule_i](0x0);    // clear VLANs mirrored
         this.pf.r.PFMRVLAN[rule_i+4](0x0);
         this.pf.r.PFMRVM[rule_i](0x0);      // clear pools mirrored
         this.pf.r.PFMRVM[rule_i+4](0x0);
      }
   }
   this.pf.mirror_set->pop(this.poolnum);
   return this;
}

function M_vf::set_VLAN (vlan) {
   if( ! vlan ) { return this; }
   assert(vlan>=0 && vlan<4096, "bad VLAN number");
   return this
      ->add_receive_VLAN(vlan)
      ->set_tag_VLAN(vlan);
}

function M_vf::add_receive_VLAN (vlan) {
   assert(vlan>=0 && vlan<4096, "bad VLAN number");
   var pf = this.pf;
   var vlan_index, is_new = pf.vlan_set->add(vlan);
   if( is_new ) {
      pf.r.VFTA[math.floor(vlan/32)]->set(bits({Ena=vlan%32}));
      pf.r.PFVLVF[vlan_index](bits({Vl_En=31},vlan));
   }
   pf.r.PFVLVFB[2*vlan_index + math.floor(this.poolnum/32)]
      ->set(bits({PoolEna=this.poolnum%32}));
   return this;
}
function M_vf::set_tag_VLAN(vlan) {
   var poolnum = this.poolnum || 0;
   this.pf.r.PFVFSPOOF[math.floor(poolnum/8)]->set(bits({VLANAS=poolnum%8+8}));
   this.pf.r.PFVMVIR[poolnum](bits({VLANA=30}, vlan));  // always add VLAN tag
   return this;
}


function M_vf::unset_VLAN() {
   var r = this.pf.r;
   var offs, mask = math.floor(this.poolnum/32), bits({PoolEna=this.poolnum%32});

   for( vln_ndx = 0, 63 ) {
      if( band(r.PFVLVFB[2*vln_ndx+offs](), mask) != 0 ) {
         // found a vlan this pool belongs to
         r.PFVLVFB[2*vln_ndx+offs]->clr(mask);
         if( r.PFVLVFB[2*vln_ndx+offs]() == 0 ) {
            // it was the last pool of the vlan
            var vlan = tonumber(band(r.PFVLVF[vln_ndx](), 0xFFF));
            r.PFVLVF[vln_ndx](0x0);
            r.VFTA[math.floor(vlan/32)]->clr(bits({Ena=vlan%32}));
            this.pf.vlan_set->pop(vlan);
         }
      }
   }
   return this;
}

function M_vf::set_rx_stats (counter) {
   if( ! counter ) { return this; }
   assert(counter>=0 && counter<16, "bad Rx counter");
   this.rxstats = counter;
   this.pf.qs.RQSMR[math.floor(this.rxqn/4)]->set(lshift(counter,8*(this.rxqn%4)));
   return this;
}

function M_vf::set_tx_stats (counter) {
   if( ! counter ) { return this; }
   assert(counter>=0 && counter<16, "bad Tx counter");
   this.txstats = counter;
   this.pf.qs.TQSM[math.floor(this.txqn/4)]->set(lshift(counter,8*(this.txqn%4)));
   return this;
}

function M_vf::get_rxstats () {
   return {
      counter_id = this.rxstats,
      packets = tonumber(this.pf.qs.QPRC[this.rxstats]()),
      dropped = tonumber(this.pf.qs.QPRDC[this.rxstats]()),
      bytes = tonumber(lshift(this.pf.qs.QBRC_H[this.rxstats]()+0LL, 32)
               + this.pf.qs.QBRC_L[this.rxstats]())
   };
}

function M_vf::get_txstats () {
   return {
      counter_id = this.txstats,
      packets = tonumber(this.pf.qs.QPTC[this.txstats]()),
      bytes = tonumber(lshift(this.pf.qs.QBTC_H[this.txstats]()+0LL, 32)
               + this.pf.qs.QBTC_L[this.txstats]())
   };
}

function M_vf::set_tx_rate (limit, priority) {
   this.pf.r.RTTDQSEL(this.poolnum);
   if( limit >= 10 ) {
      var factor = 10000 / tonumber(limit);       // line rate = 10,000 Mb/s
      factor = bit.band(math.floor(factor*2**14+0.5), 2**24-1); // 10.14 bits
      this.pf.r.RTTBCNRC(bits({RS_ENA=31}, factor));
   } else {
      this.pf.r.RTTBCNRC(0x00);
   }
   this.pf.r.RTTDT1C(bit.band(math.floor(priority * 0x80), 0x3FF));
   return this;
}

function M_vf::rxdrop () { return this.pf.qs.QPRDC[this.rxstats](); }

rxdesc_t = ffi.typeof ([=[
   union {
      struct {
         uint64_t address;
         uint64_t dd;
      } __attribute__((packed)) data;
      struct {
         uint16_t rsstype_packet_type;
         uint16_t rsccnt_hdrlen_sph;
         uint32_t xargs;
         uint32_t xstatus_xerror;
         uint16_t pkt_len;
         uint16_t vlan;
      } __attribute__((packed)) wb;
   }
]=]);

txdesc_t = ffi.typeof ([=[
   struct {
      uint64_t address, options;
   }
]=]);

//- ### Configuration register description.

config_registers_desc = [=[
ANLP1     0x042B0 -            RO Auto Negotiation Link Partner
ANLP2     0x042B4 -            RO Auto Negotiation Link Partner 2
AUTOC     0x042A0 -            RW Auto Negotiation Control
AUTOC2    0x042A8 -            RW Auto Negotiation Control 2
CTRL      0x00000 -            RW Device Control
CTRL_EX   0x00018 -            RW Extended Device Control
DCA_ID    0x11070 -            RW DCA Requester ID Information
DCA_CTRL  0x11074 -            RW DCA Control Register
DMATXCTL  0x04A80 -            RW DMA Tx Control
DTXMXSZRQ 0x08100 -            RW DMA Tx Map Allow Size Requests
DTXTCPFLGL 0x04A88 -           RW DMA Tx TCP Flags Control Low
DTXTCPFLGH 0x04A88 -           RW DMA Tx TCP Flags Control High
EEC       0x10010 -            RW EEPROM/Flash Control
FCTRL     0x05080 -            RW Filter Control
FCCFG     0x03D00 -            RW Flow Control Configuration
HLREG0    0x04240 -            RW MAC Core Control 0
LINKS     0x042A4 -            RO Link Status Register
LINKS2    0x04324 -            RO Second status link register
MANC      0x05820 -            RW Management Control Register
MAXFRS    0x04268 -            RW Max Frame Size
MNGTXMAP  0x0CD10 -            RW Mangeability Tranxmit TC Mapping
MFLCN     0x04294 -            RW MAC Flow Control Register
MTQC      0x08120 -            RW Multiple Transmit Queues Command Register
MRQC      0x0EC80 -            RW Multiple Receive Queues Command Register
PFQDE     0x02F04 -            RW PF Queue Drop Enable Register
PFVTCTL   0x051B0 -             RW PF Virtual Control Register
RDRXCTL   0x02F00 -            RW Receive DMA Control
RTRUP2TC  0x03020 -            RW DCB Receive Use rPriority to Traffic Class
RTTBCNRC  0x04984 -            RW DCB Transmit Rate-Scheduler Config
RTTDCS    0x04900 -            RW DCB Transmit Descriptor Plane Control
RTTDQSEL  0x04904 -            RW DCB Transmit Descriptor Plane Queue Select
RTTDT1C   0x04908 -            RW DCB Transmit Descriptor Plane T1 Config
RTTUP2TC  0x0C800 -            RW DCB Transmit User Priority to Traffic Class
RXCTRL    0x03000 -            RW Receive Control
RXDSTATCTRL 0x02F40 -          RW Rx DMA Statistic Counter Control
SECRXCTRL 0x08D00 -            RW Security RX Control
SECRXSTAT 0x08D04 -            RO Security Rx Status
SECTXCTRL 0x08800 -            RW Security Tx Control
SECTXSTAT 0x08804 -            RO Security Tx Status
STATUS    0x00008 -            RO Device Status
SWSM      0x10140 -            RW Software Semaphore Register
SW_FW_SYNC 0x10160 -           RW Software–Firmware Synchronization
]=];

switch_config_registers_desc = [=[
PFMRCTL   0x0F600 +0x04*0..3    RW PF Mirror Rule Control
PFMRVLAN  0x0F610 +0x04*0..7    RW PF mirror Rule VLAN
PFMRVM    0x0F630 +0x04*0..7    RW PF Mirror Rule Pool
PFVFRE    0x051E0 +0x04*0..1    RW PF VF Receive Enable
PFVFTE    0x08110 +0x04*0..1    RW PF VF Transmit Enable
PFVMTXSW  0x05180 +0x04*0..1    RW PF VM Tx Switch Loopback Enable
PFVMVIR   0x08000 +0x04*0..63   RW PF VM VLAN Insert Register
PFVFSPOOF 0x08200 +0x04*0..7    RW PF VF Anti Spoof control
PFDTXGSWC 0x08220 -             RW PFDMA Tx General Switch Control
RTTDT2C   0x04910 +0x04*0..7    RW DCB Transmit Descriptor Plane T2 Config
RTTPT2C   0x0CD20 +0x04*0..7    RW DCB Transmit Packet Plane T2 Config
RXPBSIZE  0x03C00 +0x04*0..7    RW Receive Packet Buffer Size
TXPBSIZE  0x0CC00 +0x04*0..7    RW Transmit Packet Buffer Size
TXPBTHRESH 0x04950 +0x04*0..7   RW Tx Packet Buffer Threshold
]=];

receive_registers_desc = [=[
DCA_RXCTRL 0x0100C +0x40*0..63   RW Rx DCA Control Register
DCA_RXCTRL 0x0D00C +0x40*64..127 RW Rx DCA Control Register
RDBAL      0x01000 +0x40*0..63   RW Receive Descriptor Base Address Low
RDBAL      0x0D000 +0x40*64..127 RW Receive Descriptor Base Address Low
RDBAH      0x01004 +0x40*0..63   RW Receive Descriptor Base Address High
RDBAH      0x0D004 +0x40*64..127 RW Receive Descriptor Base Address High
RDLEN      0x01008 +0x40*0..63   RW Receive Descriptor Length
RDLEN      0x0D008 +0x40*64..127 RW Receive Descriptor Length
RDH        0x01010 +0x40*0..63   RO Receive Descriptor Head
RDH        0x0D010 +0x40*64..127 RO Receive Descriptor Head
RDT        0x01018 +0x40*0..63   RW Receive Descriptor Tail
RDT        0x0D018 +0x40*64..127 RW Receive Descriptor Tail
RXDCTL     0x01028 +0x40*0..63   RW Receive Descriptor Control
RXDCTL     0x0D028 +0x40*64..127 RW Receive Descriptor Control
SRRCTL     0x01014 +0x40*0..63   RW Split Receive Control Registers
SRRCTL     0x0D014 +0x40*64..127 RW Split Receive Control Registers
RSCCTL     0x0102C +0x40*0..63   RW RSC Control
RSCCTL     0x0D02C +0x40*64..127 RW RSC Control
]=];

transmit_registers_desc = [=[
DCA_TXCTRL 0x0600C +0x40*0..127 RW Tx DCA Control Register
TDBAL      0x06000 +0x40*0..127 RW Transmit Descriptor Base Address Low
TDBAH      0x06004 +0x40*0..127 RW Transmit Descriptor Base Address High
TDH        0x06010 +0x40*0..127 RW Transmit Descriptor Head
TDT        0x06018 +0x40*0..127 RW Transmit Descriptor Tail
TDLEN      0x06008 +0x40*0..127 RW Transmit Descriptor Length
TDWBAL     0x06038 +0x40*0..127 RW Tx Desc Completion Write Back Address Low
TDWBAH     0x0603C +0x40*0..127 RW Tx Desc Completion Write Back Address High
TXDCTL     0x06028 +0x40*0..127 RW Transmit Descriptor Control
]=];

packet_filter_desc = [=[
FCTRL     0x05080 -             RW Filter Control Register
FCRTL     0x03220 +0x04*0..7    RW Flow Control Receive Threshold Low
FCRTH     0x03260 +0x04*0..7    RW Flow Control Receive Threshold High
VLNCTRL   0x05088 -             RW VLAN Control Register
MCSTCTRL  0x05090 -             RW Multicast Control Register
PSRTYPE   0x0EA00 +0x04*0..63   RW Packet Split Receive Type Register
RXCSUM    0x05000 -             RW Receive Checksum Control
RFCTL     0x05008 -             RW Receive Filter Control Register
PFVFRE    0x051E0 +0x04*0..1    RW PF VF Receive Enable
PFVFTE    0x08110 +0x04*0..1    RW PF VF Transmit Enable
MTA       0x05200 +0x04*0..127  RW Multicast Table Array
RAL       0x0A200 +0x08*0..127  RW Receive Address Low
RAH       0x0A204 +0x08*0..127  RW Receive Address High
MPSAR     0x0A600 +0x04*0..255  RW MAC Pool Select Array
VFTA      0x0A000 +0x04*0..127  RW VLAN Filter Table Array
RQTC      0x0EC70 -             RW RSS Queues Per Traffic Class Register
RSSRK     0x0EB80 +0x04*0..9    RW RSS Random Key Register
RETA      0x0EB00 +0x04*0..31   RW Redirection Rable
SAQF      0x0E000 +0x04*0..127  RW Source Address Queue Filter
DAQF      0x0E200 +0x04*0..127  RW Destination Address Queue Filter
SDPQF     0x0E400 +0x04*0..127  RW Source Destination Port Queue Filter
FTQF      0x0E600 +0x04*0..127  RW Five Tuple Queue Filter
SYNQF     0x0EC30 -             RW SYN Packet Queue Filter
ETQF      0x05128 +0x04*0..7    RW EType Queue Filter
ETQS      0x0EC00 +0x04*0..7    RW EType Queue Select
PFVML2FLT 0x0F000 +0x04*0..63   RW PF VM L2 Control Register
PFVLVF    0x0F100 +0x04*0..63   RW PF VM VLAN Pool Filter
PFVLVFB   0x0F200 +0x04*0..127  RW PF VM VLAN Pool Filter Bitmap
PFUTA     0X0F400 +0x04*0..127  RW PF Unicast Table Array
]=];
//- ### Statistics register description.

statistics_registers_desc = [=[
CRCERRS       0x04000 -           RC CRC Error Count
ILLERRC       0x04004 -           RC Illegal Byte Error Count
ERRBC         0x04008 -           RC Error Byte Count
MLFC          0x04034 -           RC MAC Local Fault Count
MRFC          0x04038 -           RC MAC Remote Fault Count
RLEC          0x04040 -           RC Receive Length Error Count
SSVPC         0x08780 -           RC Switch Security Violation Packet Count
LXONRXCNT     0x041A4 -           RC Link XON Received Count
LXOFFRXCNT    0x041A8 -           RC Link XOFF Received Count
PXONRXCNT     0x04140 +4*0..7     RC Priority XON Received Count
PXOFFRXCNT    0x04160 +4*0..7     RC Priority XOFF Received Count
PRC64         0x0405C -           RC Packets Received [64 Bytes] Count
PRC127        0x04060 -           RC Packets Received [65-127 Bytes] Count
PRC255        0x04064 -           RC Packets Received [128-255 Bytes] Count
PRC511        0x04068 -           RC Packets Received [256-511 Bytes] Count
PRC1023       0x0406C -           RC Packets Received [512-1023 Bytes] Count
PRC1522       0x04070 -           RC Packets Received [1024 to Max Bytes] Count
BPRC          0x04078 -           RC Broadcast Packets Received Count
MPRC          0x0407C -           RC Multicast Packets Received Count
GPRC          0x04074 -           RC Good Packets Received Count
GORC64        0x04088 -           RC64 Good Octets Received Count 64-bit
GORCL         0x04088 -           RC Good Octets Received Count Low
GORCH         0x0408C -           RC Good Octets Received Count High
RXNFGPC       0x041B0 -           RC Good Rx Non-Filtered Packet Counter
RXNFGBCL      0x041B4 -           RC Good Rx Non-Filter Byte Counter Low
RXNFGBCH      0x041B8 -           RC Good Rx Non-Filter Byte Counter High
RXDGPC        0x02F50 -           RC DMA Good Rx Packet Counter
RXDGBCL       0x02F54 -           RC DMA Good Rx Byte Counter Low
RXDGBCH       0x02F58 -           RC DMA Good Rx Byte Counter High
RXDDPC        0x02F5C -           RC DMA Duplicated Good Rx Packet Counter
RXDDBCL       0x02F60 -           RC DMA Duplicated Good Rx Byte Counter Low
RXDDBCH       0x02F64 -           RC DMA Duplicated Good Rx Byte Counter High
RXLPBKPC      0x02F68 -           RC DMA Good Rx LPBK Packet Counter
RXLPBKBCL     0x02F6C -           RC DMA Good Rx LPBK Byte Counter Low
RXLPBKBCH     0x02F70 -           RC DMA Good Rx LPBK Byte Counter High
RXDLPBKPC     0x02F74 -           RC DMA Duplicated Good Rx LPBK Packet Counter
RXDLPBKBCL    0x02F78 -           RC DMA Duplicated Good Rx LPBK Byte Counter Low
RXDLPBKBCH    0x02F7C -           RC DMA Duplicated Good Rx LPBK Byte Counter High
GPTC          0x04080 -           RC Good Packets Transmitted Count
GOTC64        0x04090 -           RC64 Good Octets Transmitted Count 64-bit
GOTCL         0x04090 -           RC Good Octets Transmitted Count Low
GOTCH         0x04094 -           RC Good Octets Transmitted Count High
TXDGPC        0x087A0 -           RC DMA Good Tx Packet Counter
TXDGBCL       0x087A4 -           RC DMA Good Tx Byte Counter Low
TXDGBCH       0x087A8 -           RC DMA Good Tx Byte Counter High
RUC           0x040A4 -           RC Receive Undersize Count
RFC           0x040A8 -           RC Receive Fragment Count
ROC           0x040AC -           RC Receive Oversize Count
RJC           0x040B0 -           RC Receive Jabber Count
MNGPRC        0x040B4 -           RC Management Packets Received Count
MNGPDC        0x040B8 -           RC Management Packets Dropped Count
TORL          0x040C0 -           RC Total Octets Received
TORH          0x040C4 -           RC Total Octets Received
TPR           0x040D0 -           RC Total Packets Received
TPT           0x040D4 -           RC Total Packets Transmitted
PTC64         0x040D8 -           RC Packets Transmitted [64 Bytes] Count
PTC127        0x040DC -           RC Packets Transmitted [65-127 Bytes] Count
PTC255        0x040E0 -           RC Packets Transmitted [128-255 Bytes] Count
PTC511        0x040E4 -           RC Packets Transmitted [256-511 Bytes] Count
PTC1023       0x040E8 -           RC Packets Transmitted [512-1023 Bytes] Count
PTC1522       0x040EC -           RC Packets Transmitted [Greater than 1024 Bytes] Count
MPTC          0x040F0 -           RC Multicast Packets Transmitted Count
BPTC          0x040F4 -           RC Broadcast Packets Transmitted Count
MSPDC         0x04010 -           RC MAC short Packet Discard Count
XEC           0x04120 -           RC XSUM Error Count
FCCRC         0x05118 -           RC FC CRC Error Count
FCOERPDC      0x0241C -           RC FCoE Rx Packets Dropped Count
FCLAST        0x02424 -           RC FC Last Error Count
FCOEPRC       0x02428 -           RC FCoE Packets Received Count
FCOEDWRC      0x0242C -           RC FCOE DWord Received Count
FCOEPTC       0x08784 -           RC FCoE Packets Transmitted Count
FCOEDWTC      0x08788 -           RC FCoE DWord Transmitted Count
]=];

queue_statistics_registers_desc = [=[
RQSMR         0x02300 +0x4*0..31  RW Receive Queue Statistic Mapping Registers
TQSM          0x08600 +0x4*0..31  RW Transmit Queue Statistic Mapping Registers
QPRC          0x01030 +0x40*0..15 RC Queue Packets Received Count
QPRDC         0x01430 +0x40*0..15 RC Queue Packets Received Drop Count
QBRC_L        0x01034 +0x40*0..15 RC Queue Bytes Received Count Low
QBRC_H        0x01038 +0x40*0..15 RC Queue Bytes Received Count High
QPTC          0x08680 +0x4*0..15  RC Queue Packets Transmitted Count
QBTC_L        0x08700 +0x8*0..15  RC Queue Bytes Transmitted Count Low
QBTC_H        0x08704 +0x8*0..15  RC Queue Bytes Transmitted Count High
]=];
