// Use of this source code is governed by the Apache 2.0 license; see COPYING.

module(..., package.seeall);

var app = require("core.app");
var link = require("core.link");
var config = require("core.config");
var packet = require("core.packet");
var timer = require("core.timer");
var counter = require("core.counter");
var basic_apps = require("apps.basic.basic_apps");
var ffi = require("ffi");
var C = ffi.C;
var floor, min = math.floor, math.min;

//- # `Rate limiter` app: enforce a byte-per-second limit

// uses http://en.wikipedia.org/wiki/Token_bucket algorithm
// single bucket, drop non-conformant packets

// bucket capacity and content - bytes
// rate - bytes per second

RateLimiter = {
   config = {
      rate             = {required=true},
      bucket_capacity  = {required=true},
      initial_capacity = {required=false}
   }
};

// Source produces synthetic packets of such size
var PACKET_SIZE = 60;

function RateLimiter::new (conf) {
   conf.initial_capacity = conf.initial_capacity || conf.bucket_capacity;
   var o =
   {
      rate = conf.rate,
      bucket_capacity = conf.bucket_capacity,
      bucket_content = conf.initial_capacity,
      shm = { txdrop = {counter} }
    };
   return setmetatable(o, {__index=RateLimiter});
}

function RateLimiter::reset(rate, bucket_capacity, initial_capacity) {
   assert(rate);
   assert(bucket_capacity);
   this.rate = rate;
   this.bucket_capacity = bucket_capacity;
   this.bucket_content = initial_capacity || bucket_capacity;
}

// return statistics snapshot
function RateLimiter::get_stat_snapshot () {
   return
   {
      rx = link.stats(this.input.input).txpackets,
      tx = link.stats(this.output.output).txpackets,
      time = tonumber(C.get_time_ns()),
   };
}

function RateLimiter::push () {
   var i = assert(this.input.input, "input port not found");
   var o = assert(this.output.output, "output port not found");

   {
      var cur_now = tonumber(app.now());
      var last_time = this.last_time || cur_now;
      this.bucket_content = min(
            this.bucket_content + this.rate * (cur_now - last_time),
            this.bucket_capacity
         );
      this.last_time = cur_now;
   }


   while( ! link.empty(i) ) {
      var p = link.receive(i);
      var length = p.length;

      if( length <= this.bucket_content ) {
         this.bucket_content = this.bucket_content - length;
         link.transmit(o, p);
      } else {
         // discard packet
         counter.add(this.shm.txdrop);
         packet.free(p);
      }
   }
}

var function compute_effective_rate (rl, rate, snapshot) {
   var elapsed_time =
      (tonumber(C.get_time_ns()) - snapshot.time) / 1e9;
   var tx = link.stats(rl.output.output).txpackets - snapshot.tx;
   return floor(tx * PACKET_SIZE / elapsed_time);
}

function selftest () {
   print("Rate limiter selftest");
   
   var c = config.new();
   config.app(c, "source", basic_apps.Source);
//   app.apps.source = app.new(basic_apps.Source:new())

   var ok = true;
   var rate_non_busy_loop = 200000;
   var effective_rate_non_busy_loop;
   // bytes
   var bucket_size = rate_non_busy_loop / 4;
   // should be big enough to process packets generated by Source:pull()
   // during 100 ms - internal RateLimiter timer resolution
   // small value may limit effective rate

   var arg = { rate = rate_non_busy_loop,
                 bucket_capacity = rate_non_busy_loop / 4 };
   config.app(c, "ratelimiter", RateLimiter, arg);
   config.app(c, "sink", basic_apps.Sink);

   // Create a pipeline:
   // Source --> RateLimiter --> Sink
   config.link(c, "source.output -> ratelimiter.input");
   config.link(c, "ratelimiter.output -> sink.input");
   app.configure(c);
   
   // XXX do this in new () ?
   var rl = app.app_table.ratelimiter;

   var seconds_to_run = 5;
   // print packets statistics every second
   timer.activate(timer.new(
         "report",
         function () {
            app.report();
            --seconds_to_run    ;
         },
         1e9, // every second
         'repeating'
      ));

   // bytes per second
   {
      print("\ntest effective rate, non-busy loop");

      var snapshot = rl->get_stat_snapshot();

      // push some packets through it
      while( seconds_to_run > 0 ) {
         app.breathe();
         timer.run();
         C.usleep(10); // avoid busy loop
      }
      // print final report
      app.report();

      effective_rate_non_busy_loop = compute_effective_rate(
            rl,
            rate_non_busy_loop,
            snapshot
         );
      print("configured rate is", rate_non_busy_loop, "bytes per second");
      print(
            "effective rate is",
            effective_rate_non_busy_loop,
            "bytes per second"
         );
      var accepted_min = floor(rate_non_busy_loop * 0.9);
      var accepted_max = floor(rate_non_busy_loop * 1.1);

      if( effective_rate_non_busy_loop < accepted_min ||
         effective_rate_non_busy_loop > accepted_max ) {
         print("test failed");
         ok = false;
      }
   }

   {
      print("measure throughput on heavy load...");

      // bytes per second
      var rate_busy_loop = 1200000000;
      var effective_rate_busy_loop;

      // bytes
      var xbucket_size = rate_busy_loop / 10;
      // should be big enough to process packets generated by Source:pull()
      // during 100 ms - internal RateLimiter timer resolution
      // small value may limit effective rate
      // too big value may produce burst in the beginning

      rl->reset(rate_busy_loop, xbucket_size);

      var snapshot = rl->get_stat_snapshot();
      for( i = 1, 100000 ) {
         app.breathe();
         timer.run();
      }
      var elapsed_time =
         (tonumber(C.get_time_ns()) - snapshot.time) / 1e9;
      print("elapsed time ", elapsed_time, "seconds");

      var rx = link.stats(rl.input.input).txpackets - snapshot.rx;
      print("packets received", rx, floor(rx / elapsed_time / 1e6), "Mpps");

      effective_rate_busy_loop = compute_effective_rate(
            rl,
            rate_busy_loop,
            snapshot
         );
      print("configured rate is", rate_busy_loop, "bytes per second");
      print(
            "effective rate is",
            effective_rate_busy_loop,
            "bytes per second"
         );
      print(
            "throughput is",
            floor(effective_rate_busy_loop / PACKET_SIZE / 1e6),
            "Mpps");

      // on poor computer effective rate may be too small
      // so no formal checks
   }

   if( ! ok ) {
      print("selftest failed");
      os.exit(1);
   }
   print("selftest passed");
}
